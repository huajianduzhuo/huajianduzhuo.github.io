<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>serviceWorker介绍与使用</title>
      <link href="/serviceWorker%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/serviceWorker%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Service Worker 是一个运行在浏览器后台的线程，与网页不同的是，Service Worker 为那些无需页面和用户交互的功能开启了一扇大门。目前已经实现的功能包括 推送通知 和 后台同步。</p><p><a href="https://github.com/huajianduzhuo/pwa-learn" target="_blank" rel="noopener">demo 代码 GitHub 地址</a><br><a id="more"></a></p><h1 id="Service-Worker-介绍"><a href="#Service-Worker-介绍" class="headerlink" title="Service Worker 介绍"></a>Service Worker 介绍</h1><h2 id="Service-Worker-生命周期"><a href="#Service-Worker-生命周期" class="headerlink" title="Service Worker 生命周期"></a>Service Worker 生命周期</h2><p>Service Worker 的生命周期与我们的网页是完全分开的。</p><p>想要在网页中使用 Service Worker，需要在我们网页的 javascript 中注册它。注册一个 Service Worker，浏览器会在后台开始一个 Service Worker 的<strong>安装步骤</strong>。</p><p>代表性的，在安装 Service Worker 期间，我们会想要缓存一些静态资源。如果所有文件全部缓存成功，Service Worker 则为 <strong>installed</strong> 状态。如果任何一个文件加载并缓存失败，则安装步骤将会失败，Service Worker 则不会被激活。不过，如果文件加载失败，也无需担心，因为 Service Worker 会重新去尝试加载。</p><p>安装步骤成功之后，接下来便是<strong>激活步骤</strong>。激活步骤可以用来处理一些旧的版本的 Service Worker 中缓存的资源。</p><p>激活成功之后，serviceWorker 就可以控制页面了，但是只针对在成功注册了 Service Worker 后打开的页面。也就是说，页面打开时有没有 Service Worker，决定了接下来页面的生命周期内受不受 Service Worker 控制。所以，只有当页面刷新后，之前不受 Service Worker 控制的页面才有可能被控制起来。</p><p>一旦 Service Worker 控制了页面，它将会有两种状态：terminated（中止状态），可以节省内存，或者在网页发起请求时，处理 fetch 和 message 事件。</p><p>下面是一个简单版本的 Service Worker <strong>第一次安装时</strong>的生命周期图。</p><p><img src="https://developers.google.cn/web/fundamentals/primers/service-workers/images/sw-lifecycle.png" alt="image"></p><h2 id="使用-Service-Worker-的先决条件"><a href="#使用-Service-Worker-的先决条件" class="headerlink" title="使用 Service Worker 的先决条件"></a>使用 Service Worker 的先决条件</h2><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Service Worker 目前已经被 chrome、firefox、opera 支持。Edge 浏览器已经表示了支持，safari 未来也会支持 Service Worker。</p><h3 id="需要-HTTPS"><a href="#需要-HTTPS" class="headerlink" title="需要 HTTPS"></a>需要 HTTPS</h3><p>开发阶段，可以在 <code>localhost</code> 和 <code>127.0.0.1</code> 中使用 Service Worker，但是部署之后，则必需使用 HTTPS。</p><p>使用 Service Worker 我们可以劫持连接，伪造并过滤响应。这个强大的功能容易被黑客恶意使用，为了防止这种情况，我们必须使用 HTTPS 来保证连接不被干扰。</p><blockquote><p>可以使用 Github Pages 来调试我们的 demos。</p></blockquote><h2 id="注册一个-Service-Worker"><a href="#注册一个-Service-Worker" class="headerlink" title="注册一个 Service Worker"></a>注册一个 Service Worker</h2><p>首先需要创建一个 Service Worker 线程的 js 文件（<code>/public/sw.js</code>）</p><p>页面添加下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./sw.js'</span>, &#123;</span><br><span class="line">        scope: <span class="string">'/'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, registration.scope)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册失败:(</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中打开页面，查看 application –&gt; service wrokers，就可以看到当前 serviceWorker</p><ul><li><p>查看上面 then 方法的参数 <code>registration</code>，是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerRegistration" target="_blank" rel="noopener">ServiceWorkerRegistration</a> 类型的对象</p></li><li><p>在 <code>sw.js</code> 中查看 <code>this</code>，是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope" target="_blank" rel="noopener">ServiceWorkerGlobalScope</a> 类型的对象</p></li></ul><p>我们可以没有负担的在每一次页面加载时调用 <code>register()</code>，浏览器会去查看当前网页是否已经注册过 Service Worker 线程并做出相应的处理。</p><p>需要注意 register 函数的第一个参数 <code>sw.js</code>，即 Service Worker 的 javascript 文件的位置。如果该文件位于项目的根目录，则 Service Worker 的作用域即为整个域名，换句话说，Service Worker 将会捕捉该域名下所有的 fetch 事件。如果 Service Worker 文件放在 <code>/example/sw.js</code>，则 Service Worker 仅捕捉 <code>/example/</code> URL 下的 fetch 事件。</p><p>register 函数的 <code>scope</code> 参数是可选的，用于指定想要 Service Worker 控制的内容的目录。如本例中，因为 <code>sw.js</code> 文件不是位于根目录，指定 scope 为 ‘/‘，则可以让 Service Worker 捕捉整个页面的 fetch 事件。</p><h2 id="安装一个-Service-Worker"><a href="#安装一个-Service-Worker" class="headerlink" title="安装一个 Service Worker"></a>安装一个 Service Worker</h2><p>当页面已经成功注册了一个 Service Worker，我们就可以将注意力转移到 Service Worker 的 js 文件，在该文件中我们可以处理 <code>install</code> 事件。</p><p>最基本的例子，我们需要为 install 事件添加一个 callback，并确定需要缓存的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform install steps</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 install callback 中，我们需要遵从以下步骤：</p><ul><li>打开一个 Cache</li><li>缓存文件</li><li>确认是否所有需要缓存的文件全部缓存成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_NAME = <span class="string">'my-first-cache-v1'</span></span><br><span class="line"><span class="keyword">var</span> urlsToCache = [</span><br><span class="line">  <span class="string">'/style.css'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'opened cache'</span>)</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(urlsToCache)</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>event.waitUntil()</code> 方法接收一个 promise，并通过它知道安装消耗的时间，以及是否安装成功。</p><p>如果所有文件缓存成功，Service Worker 则为 installed。如果任何一个文件缓存失败，则 Service Worker 安装失败。</p><p>我们还可以在 install 事件中执行其他任务，或者避免把所有任务放在一个 install 事件中。</p><h2 id="缓存和返回请求"><a href="#缓存和返回请求" class="headerlink" title="缓存和返回请求"></a>缓存和返回请求</h2><p>Service Worker 安装成功，并且用户跳转到一个不同的页面或者刷新之后，Service Worker 将开始捕捉 fetch 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// cache 命中 - 返回response</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response'</span>, response)</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request)</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 chrome 中测试发现，仅刷新页面缓存的文件没有从 cache 中获取，新打开一个页面可以看到 Service Worker 的 fetch 事件的效果。</p></blockquote><p>如果你想要渐进式的缓存资源，可以通过处理 fetch request 的 response，将其添加进 cache。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// cache 命中 - 返回response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cache 没命中，请求资源并且将响应添加进缓存</span></span><br><span class="line">        <span class="comment">// 因为 request 和 response 都是 stream，仅可以被使用一次，</span></span><br><span class="line">        <span class="comment">// 但是我们的浏览器页面和 cache 都要使用，所有需要复制一份</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone()</span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          response =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone()</span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">                cache.put(event.request, responseToCache)</span><br><span class="line">              &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>response 的 type 为 basic，说明请求的资源来自当前域名。上面的代码校验不等于 basic 直接返回，意为来自其他域名的资源不进行缓存。</p><h2 id="Service-Worker-版本更新"><a href="#Service-Worker-版本更新" class="headerlink" title="Service Worker 版本更新"></a>Service Worker 版本更新</h2><p>更新 Service Worker 需要遵从以下步骤：</p><ol><li>更新 Service Worker javascript 文件。当用户打开我们的网站，浏览器会重新加载 Service Worker 的 js 文件，只要有改动，即会被视为新的。</li><li>开启新的 Service Worker，并触发 <code>install</code> 事件。</li><li>此时，旧的 Service Worker 仍然在控制当前页面，所以新的 Service Worker 将会进入 <code>waiting</code> 状态。</li><li>所有已打开的页面关闭之后，旧的 Service Worker 自动停止，新的 Service Worker 会在重新打开的页面生效。</li><li>一旦新的 Service Worker 生效，它的 <code>activate</code> 事件会被触发。</li></ol><p>在 <code>activate</code> 事件回调里，一个共同的任务是 cache 管理。必须在 <code>activate</code> 事件清理旧版本的 Service Worker，而不是在 <code>install</code> 事件中清理的原因是，如果在 <code>install</code> 事件中清理，则包括正在控制当前页面的 Service Worker 在内的所有旧版本 Service Worker，都会被停止，使得当前页面没有可以使用的 Service Worker。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>英文：<a href="https://developers.google.cn/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">https://developers.google.cn/web/fundamentals/primers/service-workers/</a></p><p>中文：<a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/how-to-use-service-worker" target="_blank" rel="noopener">https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/how-to-use-service-worker</a></p><h1 id="在项目中使用-Service-Worker"><a href="#在项目中使用-Service-Worker" class="headerlink" title="在项目中使用 Service Worker"></a>在项目中使用 Service Worker</h1><p>目前已经有成熟的 webpack 插件支持我们在项目中使用 Service Worker。</p><h2 id="sw-precache-webpack-plugin"><a href="#sw-precache-webpack-plugin" class="headerlink" title="sw-precache-webpack-plugin"></a>sw-precache-webpack-plugin</h2><p><a href="https://www.npmjs.com/package/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a> 使用 <code>sw-precache</code> 来生成 service worker 文件，并添加到构建目录。</p><p>由于 <code>sw-precache</code> 和 <code>sw-toolbox</code> 已经被弃用，所以我之前使用此插件到代码就不贴出来了。</p><h2 id="workbox-webpack-plugin"><a href="#workbox-webpack-plugin" class="headerlink" title="workbox-webpack-plugin"></a>workbox-webpack-plugin</h2><p><a href="https://www.npmjs.com/package/workbox-webpack-plugin" target="_blank" rel="noopener">workbox-webpack-plugin</a></p><p>npm 网站上此插件到文档链接无法打开，正确链接为 </p><p><a href="https://developers.google.cn/web/tools/workbox/modules/workbox-webpack-plugin" target="_blank" rel="noopener">https://developers.google.cn/web/tools/workbox/modules/workbox-webpack-plugin</a></p>]]></content>
      
      
      <categories>
          
          <category> pwa </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwa </tag>
            
            <tag> serviceWorker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>generator 学习笔记</title>
      <link href="/generator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/generator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考：<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">阮一峰ES6 generator教程</a></p><p>demos 代码 github 地址：<a href="https://github.com/huajianduzhuo/es6/tree/master/generator" target="_blank" rel="noopener">https://github.com/huajianduzhuo/es6/tree/master/generator</a></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br><a id="more"></a></p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><ul><li>function 关键字与函数名之间有一个星号</li><li>函数体内部使用 yield 表达式，定义不同的内部状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（ hello 和 world ），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>执行 Generator 函数会返回一个遍历器对象（Iterator），也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用 Generator 函数后，该<strong>函数并不执行</strong>，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就<strong>从函数头部或上一次停下来的地方开始执行</strong>，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo 02-generator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'卫庄'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'盖聂'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'韩非'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generatorFun() <span class="comment">// 无 log</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 1 &#123; value: "卫庄", done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 2 &#123; value: '盖聂', done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 3 &#123; value: '韩非', done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><p>遍历器对象的 next 方法的运行逻辑如下</p><ul><li><p>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</p></li><li><p>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</p></li><li><p>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</p></li><li><p>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。</p></li></ul><h2 id="yield-和-return"><a href="#yield-和-return" class="headerlink" title="yield 和 return"></a>yield 和 return</h2><ul><li>相同点：都能返回紧跟在语句后面的那个表达式的值</li><li>不同点：<ul><li>每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能</li><li>一个函数里面，只能执行一次（或者说一个） return 语句，但是可以执行多次（或者说多个） yield 表达式。</li><li>正常函数只能返回一个值，因为只能执行一次 return；Generator 函数可以返回一系列的值，因为可以有任意多个 yield。</li></ul></li></ul><blockquote><p>yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p></blockquote><h2 id="yield-表达式在另一个表达式里面"><a href="#yield-表达式在另一个表达式里面" class="headerlink" title="yield 表达式在另一个表达式里面"></a>yield 表达式在另一个表达式里面</h2><p>yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h1 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h1><p>yield 表达式本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f()</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><blockquote><p>由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p></blockquote><h1 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h1><p>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g()</span><br><span class="line">i.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>)</span><br><span class="line">  i.throw(<span class="string">'b'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。</p><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><ul><li>如果 Generator 函数内部没有部署 try…catch 代码块，那么 throw 方法抛出的错误，将被外部 try…catch 代码块捕获。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g()</span><br><span class="line">i.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>)</span><br><span class="line">  i.throw(<span class="string">'b'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><ul><li>如果 Generator 函数内部和外部，都没有部署 try…catch 代码块，那么程序将报错，直接中断执行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.throw()</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Uncaught undefined</span></span><br></pre></td></tr></table></figure><ul><li>throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.throw(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><ul><li>throw 方法被捕获以后，会附带执行下一条 yield 表达式。也就是说，会附带执行一次 next 方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// a</span></span><br><span class="line">g.throw() <span class="comment">// b</span></span><br><span class="line">g.next() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，g.throw 方法被捕获以后，自动执行了一次 next 方法，所以会打印 b。另外，也可以看到，只要 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误，不影响下一次遍历。</p><ul><li>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase()</span><br><span class="line">  <span class="keyword">yield</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo()</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个 next 方法向函数体内传入一个参数 42，数值是没有 toUpperCase 方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获。</p><ul><li>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'throwing an exception'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'generator broke!'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'starting generator'</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caller done'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(g())</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><h1 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h1><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果 return 方法调用时，不提供参数，则返回值的 value 属性为 undefined。</p></blockquote><h2 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h2><p>如果 Generator 函数内部有 try…finally 代码块，那么 return 方法会<strong>推迟到 finally 代码块执行完再执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers()</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h1><p>yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">yield</span>* foo()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure><p>从语法角度看，如果 yield 表达式后面跟的是一个遍历器对象，需要在 yield 表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为 yield*表达式。</p><p>yield*后面的 Generator 函数（<strong>没有 return 语句时</strong>），等同于在 Generator 函数内部，部署一个 for…of 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1</span><br><span class="line">  <span class="keyword">yield</span>* iter2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，yield<em> 后面的 Generator 函数（没有 return 语句时），不过是 for…of 的一种简写形式，完全可以用后者替代前者。反之，在<strong>有 return 语句时</strong>，则需要用 `var value = yield</em> iterator` 的形式获取 return 语句的值。</p><h2 id="yield-数组"><a href="#yield-数组" class="headerlink" title="yield* 数组"></a>yield* 数组</h2><p>如果 yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen().next() <span class="comment">// &#123; value:"a", done:false &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上，任何数据结构只要有 Iterator 接口，就可以被 yield*遍历。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">'hello'</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">read.next().value <span class="comment">// "hello"</span></span><br><span class="line">read.next().value <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure><h2 id="展开嵌套数组"><a href="#展开嵌套数组" class="headerlink" title="展开嵌套数组"></a>展开嵌套数组</h2><p>demo 05-yield-xing.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = tree[i]</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...iterTree(arr)]) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><h1 id="作为对象属性的-generator-函数"><a href="#作为对象属性的-generator-函数" class="headerlink" title="作为对象属性的 generator 函数"></a>作为对象属性的 generator 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="generator-函数的-this"><a href="#generator-函数的-this" class="headerlink" title="generator 函数的 this"></a>generator 函数的 this</h1><ul><li>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也 <strong>继承了 Generator 函数的 prototype 对象上的方法</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g()</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.hello() <span class="comment">// 'hi!'</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototype。</p><ul><li>但是，如果把 g 当作普通的构造函数，并不会生效，因为 <strong>g 返回的总是遍历器对象，而不是 this 对象</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g()</span><br><span class="line">obj.next()</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>Generator 函数也<strong>不能跟 new 命令一起用</strong>，会报错。</li></ul><h1 id="使用-generator-封装异步任务"><a href="#使用-generator-封装异步任务" class="headerlink" title="使用 generator 封装异步任务"></a>使用 generator 封装异步任务</h1><p>使用 generator 封装异步任务，由下面的例子可以看出，异步任务定义很简单，但是流程管理很复杂。</p><p>demo: 07-async.js，在 index.html 中引入，使用浏览器查看结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> url = <span class="string">'https://api.github.com/users/github'</span></span><br><span class="line"> <span class="keyword">let</span> result = <span class="keyword">yield</span> fetch(url)</span><br><span class="line"> <span class="built_in">console</span>.log(result.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = gen()</span><br><span class="line"><span class="keyword">let</span> pro = it.next().value</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> res.json()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"> it.next(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> generator </tag>
            
            <tag> yield </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言学习笔记</title>
      <link href="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>慕课网课程地址：<a href="https://www.imooc.com/learn/249" target="_blank" rel="noopener">https://www.imooc.com/learn/249</a></p><a id="more"></a><h1 id="认识C程序"><a href="#认识C程序" class="headerlink" title="认识C程序"></a>认识C程序</h1><p>简单来说，一个C程序就是由若干<strong>头文件</strong>和<strong>函数</strong>组成。</p><p>一个简单的 Hello World C 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上C程序代码中，<code>#include&lt;stdio.h&gt;</code> 为包含头文件，<code>int main(){}</code> 为主函数。</p><ul><li><p><code>#include&lt;stdio.h&gt;</code> 就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需要做一些预处理工作</p></li><li><p>函数就是实现代码逻辑的一个小的单元</p><blockquote><p>在最新的C标准中，main 函数前的类型为 int 而不是 void</p></blockquote></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>一个C程序<strong>有且只有一个主函数</strong>，即 <strong>main</strong> 函数。C程序就是执行主函数里的代码，也可以说主函数就是C语言中的<strong>唯一入口</strong>。</p><p>main 前面的 <strong>int</strong> 就是主<strong>函数的类型</strong>。</p><p>printf() 是格式输出函数，功能就是在屏幕上输出指定的信息。</p><p><strong>return 是函数的返回值</strong>，根据函数类型的不同，返回的值也是不同的。</p><p>\n 是转义字符。</p><h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ul><li>一个说明或一个语句占一行，例如：包含头文件、一个可执行语句结束都需要换行</li><li>函数体内的语句要有明显缩进</li><li>括号要成对写</li><li>当一句可执行语句结束的时候末尾需要有分号</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>多行注释： /* 注释内容 */<br>单行注释： // 注释一行</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>C语言中，数据类型可分为：<strong>基本数据类型、构造数据类型、指针类型、空类型</strong>四大类。</p><p><img src="http://ovqy85q1k.bkt.clouddn.com/datatype.jpg" alt="datatype"></p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给变量或者函数起的名字就是标识符，标识符可以是<strong>字母（A~Z, a~z）、数字（0~9）、下划线_</strong>组成的字符串，并且<strong>第一个字符必须是字母或者下划线</strong>。</p><p>在使用标识符时还要注意以下几点：</p><ul><li>长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符</li><li>标识符是严格<strong>区分大小写</strong>的</li><li>最好选择有意义的英文单词</li><li>标识符<strong>不能是C语言的关键字</strong></li></ul><h2 id="变量及赋值"><a href="#变量及赋值" class="headerlink" title="变量及赋值"></a>变量及赋值</h2><p>变量定义的一半形式：<strong>数据类型 变量名;</strong></p><p>多个类型相同的变量：<strong>数据类型 变量名, 变量名, 变量名…;</strong></p><p>变量的赋值：</p><ul><li>先声明再赋值</li><li>声明的同时赋值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">说明</th><th style="text-align:center">字节</th><th style="text-align:center">应用</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">字符型</td><td style="text-align:center">1</td><td style="text-align:center">用于存储单个字符</td><td style="text-align:center">char sex = ‘m’;</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">整型</td><td style="text-align:center">2</td><td style="text-align:center">用于存储整数</td><td style="text-align:center">int height = 18;</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度浮点型</td><td style="text-align:center">4</td><td style="text-align:center">用于存储小数</td><td style="text-align:center">float price = 11.1;</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度浮点型</td><td style="text-align:center">8</td><td style="text-align:center">用于存储位数更多的小数</td><td style="text-align:center">double pi = 3.1415926;</td></tr></tbody></table><blockquote><p>C语言中不存在字符串变量，字符串只能存在于字符数组中。</p></blockquote><h2 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h2><p>格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。</p><p>格式：<strong>printf(“输出格式符”, 输出项);</strong></p><p>常用格式化符：</p><table><thead><tr><th style="text-align:center">格式符</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">%d</td><td style="text-align:center">带符号十进制整数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">单个字符</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">6位小数</td></tr></tbody></table><p>输出多个变量，变量之间用逗号隔开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">7.56</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"整数：%d，小数：%f，字符：%c"</span>, a, b, c);</span><br><span class="line"><span class="comment">// 整数：10，小数：7.560000，字符：c</span></span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>C语言中常量可以分为<strong>直接常量和符号常量</strong></p><p>直接常量也成为字面量，可以直接拿来使用，无需定义。</p><p>可以使用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，一般形式为：</p><p><strong>#define 标识符 常量值</strong></p><p>符号常量的标识符一般习惯使用大写字母，变量的标识符习惯使用小写字母，加以区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"圆周率：%f\n"</span>, PI);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动转换发生在不同数据类型运算时，在编译的时候自动完成。自动转换遵循的规则就好比小盒子可以放进大盒子里，下图表示自动转换规则：</p><p><img src="http://ovqy85q1k.bkt.clouddn.com/typetransform.jpg" alt="typetransform"></p><p>char类型数据转换为int类型数据遵循ASCII码中的对应值</p><blockquote><p>字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">int</span> n = c;        <span class="comment">//将c赋值给n</span></span><br><span class="line">    <span class="keyword">float</span> f = c;      <span class="comment">//将c赋值给f</span></span><br><span class="line">    <span class="keyword">double</span> d = c;     <span class="comment">//将c赋值给d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n); <span class="comment">// 97</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,f); <span class="comment">// 97.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d); <span class="comment">// 97.000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换是通过定义类型转换运算来实现的。一般形式为：</p><p><strong>(数据类型)(表达式)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">6.777</span>;</span><br><span class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>)a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a); <span class="comment">// 6.777000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>使用强制类型转换应注意以下问题：</p><ul><li>数据类型和表达式都必须加括号，如 (int)(x/2+y)</li><li><strong>转换后不会改变原数据的类型及变量值</strong>，只在本次运算中临时性转换</li><li>强制转换后的运算结果<strong>不遵循四舍五入原则</strong></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">运算符号</th></tr></thead><tbody><tr><td style="text-align:center">加法</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">减法</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">乘法</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">除法</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">求余（模运算符）</td><td style="text-align:center">%</td></tr><tr><td style="text-align:center">自增</td><td style="text-align:center">++</td></tr><tr><td style="text-align:center">自减</td><td style="text-align:center">--</td></tr></tbody></table><ul><li><p><strong>除法</strong>运算中，如果相除的<strong>两个数都是整数</strong>的话，则<strong>结果也为整数</strong>，小数部分省略。两数中<strong>有一个为小数，结果则为小数</strong>。</p></li><li><p><strong>求余</strong>运算，<strong>只适合用两个整数</strong>进行求余运算。运算后的符号<strong>取决于被模数的符号</strong>，如 (-10)%3 = -1，而 10%(-3) = 1.</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>C语言中的赋值运算符分为<strong>简单赋值运算符和复合赋值运算符</strong>。</p><p>简单赋值运算符：”=”</p><p>复合赋值运算符就是在简单赋值符 “=” 之前加上其他运算符构成，例如：+=、-=、*=、/=、%=</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">></td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">>=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr></tbody></table><p>关系表达式的值是“真”和“假”，在C程序用<strong>整数 1 和 0 表示</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑与</td></tr><tr><td style="text-align:center">&#124;&#124;</td><td style="text-align:center">逻辑或</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td></tr></tbody></table><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><p><strong>表达式1 ? 表达式2 : 表达式3;</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="http://ovqy85q1k.bkt.clouddn.com/youxianji.jpg" alt="youxianji"></p><p>优先级别为 1 的最高，级别为 10 的最低。</p><h1 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h1><h2 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块1;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式m)</span><br><span class="line">&#123;</span><br><span class="line">  执行代码块m;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  执行代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  执行代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>for 循环中的 表达式1、2、3 均可以省略，但<strong>分号不能缺省</strong></li><li>表达式1和表达式3可以是多个表达式，以<strong>逗号分隔</strong></li><li>表达式2一般是关系表达式或逻辑表达式，但也可以是数值表达式或字符表达式，只要其<strong>值非零</strong>，就执行循环体</li><li>各<strong>表达式中的变量一定要在 for 循环之前定义（与其他语言不同）</strong></li></ul><h2 id="三种循环比较"><a href="#三种循环比较" class="headerlink" title="三种循环比较"></a>三种循环比较</h2><ul><li>在知道循环次数的情况下，更适合使用 for 循环</li><li>不知道循环次数的情况下，使用 while 或 do-while 循环</li></ul><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>break 语句可以中断循环</p><ul><li>在没有循环结构的情况下，break <strong>不能用在单独的 if-else 语句中</strong></li><li>在多层循环中，一个 break 语句<strong>只跳出当前循环</strong></li></ul><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>continue 语句结束本次循环开始执行下一次循环</p><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">    执行代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">    执行代码块n</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    执行代码块n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>case 子句后如果没有 break，会一直往后执行一直到遇到 break，才跳出 switch 语句</li><li>switch 后面的表达式语句只能是<strong>整型或者字符类型</strong></li><li>在 case 后，允许有多个语句，可以不用 {} 括起来</li></ul><h2 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h2><p>使用格式：</p><p><strong>goto 语句标号;</strong></p><p>其中语句标号是一个标识符，该标识符一般用英文大写并遵守标识符命名规则，这个标识符加上一个“:”一起出现在函数内某处，执行 goto 语句后，程序将跳转到该标号处并执行其后的语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// LOOP就是一个有效的标识符</span></span><br><span class="line">  LOOP:<span class="keyword">if</span>(i&lt;=<span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">goto</span> LOOP; <span class="comment">// 跳转到LOOP所在位置继续执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sum=%d\n"</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>C语言提供了大量的库函数，比如stdio.h提供输出函数。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><img src="http://ovqy85q1k.bkt.clouddn.com/defineFun.jpg" alt="defineFun"></p><ul><li>[] 包含的内容可以省略，数据类型省略，默认是 <strong>int</strong> 类型函数；</li><li>自定义函数尽量放在 main 函数之前，如果放在main函数后面，需要在main函数之前先声明，声明格式为：<strong>[数据类型说明] 函数名称 ([参数])</strong></li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>调用形式：</p><p><strong>函数名([参数]);</strong></p><h2 id="有参函数"><a href="#有参函数" class="headerlink" title="有参函数"></a>有参函数</h2><p>[数据类型说明] 函数名称(<strong>参数类型 参数名</strong>, …)<br>{<br>　　执行代码块;<br>　　return 表达式;<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">learn</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"小明在慕课网上已经参与学习了%d门课程\n"</span>, n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><p>形参是定义函数和函数体时使用的参数，实参是在调用时传递给该函数的参数。</p><ul><li>形参只有在<strong>被调用时才分配内存单元</strong>，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。</li><li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们必须具有明确的值。</li><li>在参数传递时，实参和形参在<strong>数量上、类型上、顺序上应严格一致</strong>，否则会发生类型不匹配的错误。</li></ul><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><strong>return 表达式</strong> 或者 <strong>return (表达式)</strong></p><blockquote><p>如果函数返回值的类型与函数定义中函数的类型不一致，则以函数返回类型为准，自动进行类型转换</p></blockquote><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在<strong>函数内部、复合语句内部</strong>定义的变量</p><h2 id="变量存储类别"><a href="#变量存储类别" class="headerlink" title="变量存储类别"></a>变量存储类别</h2><p>C语言根据变量的生存周期来划分，可以分为<strong>静态存储方式</strong>和<strong>动态存储方式</strong>。</p><ul><li><p>静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了<strong>在整个程序执行过程中都存在的变量，如全局变量</strong>。</p></li><li><p>动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。<strong>动态存储区中存放的变量是根据程序运行的需要而建立和释放的</strong>，通常包括：函数形参、自动变量、函数调用时的现场保护和返回地址等。</p></li></ul><p>C语言中存储类别又分为四类：<strong>自动（auto）、静态（static）、寄存器的（register）和外部的（extern）</strong>。</p><ul><li><p>用关键字 auto 定义的变量为自动变量，auto 可以省略，auto不写则隐含定义为“自动存储类别”，属于动态存储方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> b, c;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 static 修饰的为静态变量，如果定义在函数内部，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在<strong>整个程序运行期间都不释放</strong>；静态局部变量<strong>在编译时赋初值，即只赋初值一次</strong>；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p></blockquote><ul><li>为了提高效率，C语言允许将<strong>局部变量</strong>的值放在 CPU 中的寄存器中，这种变量叫“寄存器变量”，用关键字 register 作声明。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>只有<strong>局部自动变量和形参</strong>可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；<strong>局部静态变量不能定义为寄存器变量</strong>。</p></blockquote><ul><li>用 extern 声明的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> x; <span class="comment">// 这里声明使用的是外部全局变量</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"extern x=%d\n"</span>, x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内部函数与外部函数"><a href="#内部函数与外部函数" class="headerlink" title="内部函数与外部函数"></a>内部函数与外部函数</h2><p>在C语言中不能被其他源文件调用的函数称为内部函数，由 static 关键字来定义，又被称为静态函数。形式为：</p><p><strong>static [数据类型] 函数名()</strong></p><p>在C语言中能被其他源文件调用的函数称为外部函数，由 extern 关键字来定义。形式为：</p><p><strong>extern [数据类型] 函数名()</strong></p><p>在没有指定函数的作用范围时，<strong>默认为外部函数</strong>，因此 extern 可以省略。</p><blockquote><p>引入源文件<code>#include &quot;test.c&quot;</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IOS下input的placeholder不垂直居中的问题</title>
      <link href="/IOS%E4%B8%8Binput%E7%9A%84placeholder%E4%B8%8D%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/IOS%E4%B8%8Binput%E7%9A%84placeholder%E4%B8%8D%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>为 <code>input</code> 设置 <code>lineHeight: 1;</code>, 可以使 input 输入框内用户输入的文本垂直居中，但是在 IOS 的 Safari 浏览器中查看， <code>placeholder</code> 提示文字垂直方向靠上，解决此问题，可以为该 input 设置 <code>lineHeight: normal;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IOS </tag>
            
            <tag> safari </tag>
            
            <tag> placeholder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue项目使用WebViewJavascriptBridge</title>
      <link href="/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8WebViewJavascriptBridge/"/>
      <url>/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8WebViewJavascriptBridge/</url>
      
        <content type="html"><![CDATA[<p>现在在做的项目是 hybrid 开发，H5 页面会嵌入到 IOS 客户端 app 中，于是就涉及到了 H5 与 IOS 交互的问题。在这里记录一下项目中用到的交互方式，重点介绍 <code>WebViewJavascriptBridge</code>。<br><a id="more"></a></p><h1 id="H5-调用-IOS，无返回"><a href="#H5-调用-IOS，无返回" class="headerlink" title="H5 调用 IOS，无返回"></a>H5 调用 IOS，无返回</h1><p>项目中最简单的一个交互需求，是在客户端打开 H5 页面后，页面上有一个后退按钮，可以退回到客户端页面。这个需求纯前端是无法做到的，前端必须调用 IOS 的退回方法。</p><p>H5 页面需要调用 IOS 端的方法，且不需要获取返回值时，可以很简单的使用 <code>schema</code> 的方式，而不需要通过第三方库来实现。具体方式是：</p><ul><li>前端与客户端约定好一个 schema 的名称，比如退回就叫做 goback</li><li>前端通过 <code>location.href=&quot;goback://&quot;</code> 或 <code>iframe.src=&quot;goback://&quot;</code> 的方式发起请求</li><li>IOS 端拦截 goback 这个 schema，执行后退逻辑</li><li>如果需要向客户端传递参数，直接在该 url 后面拼接参数即可，客户端可以进行解析</li></ul><h1 id="使用-WebViewJavascriptBridge"><a href="#使用-WebViewJavascriptBridge" class="headerlink" title="使用 WebViewJavascriptBridge"></a>使用 WebViewJavascriptBridge</h1><p>当 H5 页面与 IOS 端交互比较复杂时，比如页面需要获取 IOS 端传回的返回值，或者 IOS 端需要调用 js 方法。</p><p>可以通过第三方库来实现，我们项目用的是 <code>WebViewJavascriptBridge</code>。下面介绍我怎么在 vue 项目中使用 <code>WebViewJavascriptBridge</code></p><p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge GitHub 地址</a></p><ul><li>创建 src/config/bridge.js 文件，用于封装 WebViewJavascriptBridge </li><li><p>将以下代码拷贝到 bridge.js 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="built_in">window</span>.WebViewJavascriptBridge)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.WVJBCallbacks = [callback]</span><br><span class="line">  <span class="keyword">let</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">  WVJBIframe.style.display = <span class="string">'none'</span></span><br><span class="line">  WVJBIframe.src = <span class="string">'https://__bridge_loaded__'</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  callhandler (name, data, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.callHandler(name, data, callback)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  registerhandler (name, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.registerHandler(name, <span class="function"><span class="keyword">function</span> (<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">        callback(data, responseCallback)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 main.js 中引入该文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bridge <span class="keyword">from</span> <span class="string">'./config/bridge.js'</span></span><br><span class="line">Vue.prototype.$bridge = Bridge</span><br></pre></td></tr></table></figure></li><li><p>在需要调用客户端方法的组件中（事先需要与客户端同事约定好方法名）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$bridge.callhandler(<span class="string">'ObjC Echo'</span>, params, (data) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理返回数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当客户端需要调用 js 函数时,事先注册约定好的函数即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$bridge.registerhandler(<span class="string">'JS Echo'</span>, (data, responseCallback) =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'JS Echo called with:'</span>, data)</span><br><span class="line">  responseCallback(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> WebViewJavascriptBridge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件委托touchmove事件获取target</title>
      <link href="/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98touchmove%E4%BA%8B%E4%BB%B6%E8%8E%B7%E5%8F%96target/"/>
      <url>/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98touchmove%E4%BA%8B%E4%BB%B6%E8%8E%B7%E5%8F%96target/</url>
      
        <content type="html"><![CDATA[<p>　　今天做项目时发现，移动端 touchmove 事件获取到的 target 元素，总是 touchstart 事件时的 target，而不能跟随手指的移动动态得到当前 target。</p><a id="more"></a><p>　　最近项目需要做一个通讯录页面，并且要仿照 iPhone 原生的通讯录，其中有一个功能，即滑动右侧的英文字母列表，通讯录列表要相应滑动到对应的位置。如下图所示：</p><style>#imgWrapper {  width: 200px;  overflow: hidden;  margin: 0 auto;}</style><div id="imgWrapper"><br>  <img src="http://ovqy85q1k.bkt.clouddn.com/mobile.gif" alt="mobile"><br></div><p>右侧字母列表的代码如下（vue 实现）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"letter-list"</span> @<span class="attr">touchmove.prevent</span>=<span class="string">"scrollToLetter()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(letter, index) in letters"</span> <span class="attr">:id</span>=<span class="string">"letter"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    &#123;&#123; letter &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　如代码所示，我想要使用事件委托，为 ul 绑定 touchmove 事件，通过 <code>e.changedTouches[0].target.id</code> ，可以获取当前触摸到的字符，并将联系人列表移动到相应字符的位置。</p><p>　　然而，当我这样写完，测试时发现效果不对，联系人列表只能滑动到 touchstart 时对应的字符位置，通过 log 打印发现，<code>e.changedTouches[0].target</code> 获取到的永远是 touchstart 时的 target，所有这种方式获取 target 是错误的。</p><p>　　通过上网查阅资料，最终通过以下方式获取到了正确的 target：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touch = event.changedTouches[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> letterE = <span class="built_in">document</span>.elementFromPoint(touch.clientX, touch.clientY)</span><br><span class="line"><span class="built_in">console</span>.log(letterE);</span><br><span class="line"><span class="keyword">if</span> (!letterE) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> letter = letterE.id</span><br></pre></td></tr></table></figure><p><code>document.elementFromPoint</code> 方法的浏览器兼容性如下：</p><ul><li><strong>desktop</strong></li></ul><table><thead><tr><th>Feature</th><th>Chrome</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari (WebKit)</th></tr></thead><tbody><tr><td>Basic support</td><td>53.0</td><td>?</td><td>?</td><td></td><td>?</td></tr></tbody></table><ul><li><strong>mobile</strong></li></ul><table><thead><tr><th>Feature</th><th>Android</th><th>Android Webview</th><th>Firefox Mobile (Gecko)</th><th>Firefox OS</th><th>IE Mobile</th><th>Opera Mobile</th><th>Safari Mobile</th><th>Chrome for Android</th></tr></thead><tbody><tr><td>Basic support</td><td>未实现</td><td>53.0</td><td>?</td><td>?</td><td>?</td><td></td><td>?</td><td>53.0</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> touchmove </tag>
            
            <tag> target </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol数据类型</title>
      <link href="/Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol-概述"><a href="#Symbol-概述" class="headerlink" title="Symbol 概述"></a>Symbol 概述</h1><p><code>Symbol</code> 是ES6引入的一种新的原始数据类型，表示独一无二的值。<br><a id="more"></a><br>Symbol 值通过 Symbol 函数生成。Symbol 函数前不能使用 <code>new</code> 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'haha'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Symbol(haha)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>: <span class="string">'weizhuang'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Symbol([object Object])</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === d); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> f = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(e === f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-与其他数据类型"><a href="#Symbol-与其他数据类型" class="headerlink" title="Symbol 与其他数据类型"></a>Symbol 与其他数据类型</h2><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line">a + <span class="string">'lian'</span>  <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line">a + <span class="number">10</span>      <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line">a + <span class="literal">true</span>    <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><p>Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(a)); <span class="comment">// Symbol(zhuang)</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// Symbol(zhuang)</span></span><br></pre></td></tr></table></figure><p>Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(a));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(a));  <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><p>Symbol 值可以作为对象的属性名。由于每一个 Symbol 值都是不相等的，这样就可以保证不会出现同名的属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [a]: <span class="string">'weizhuang'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj[a]); <span class="comment">// weizhuang</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p></blockquote><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 Symbol 属性名。</p><p><code>Object.getOwnPropertySymbols</code> 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [a]: <span class="string">'weizhuang'</span>,</span><br><span class="line">  b: <span class="string">'honglian'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + obj[key]); <span class="comment">// b: honglian</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// ["b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// ["b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;"b":"honglian"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [Symbol(a)]</span></span><br></pre></td></tr></table></figure><p>另一个新的 API，<code>Reflect.ownKeys</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)); <span class="comment">// ["b", Symbol(a)]</span></span><br></pre></td></tr></table></figure><h1 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h1><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code> 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><p>Symbol.for() 与 Symbol() 这两种写法，都会生成新的 Symbol。它们的区别是，<strong>前者会被登记在全局环境中供搜索，后者不会</strong>。Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s3 === s4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>(<span class="string">'fei'</span>)</span><br><span class="line"><span class="keyword">let</span> s6 = <span class="built_in">Symbol</span>.for(<span class="string">'fei'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s5 === s6); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Symbol.keyFor</code> 方法返回一个<strong>已登记</strong>的 Symbol 类型值的key。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// zhuang</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s3)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 s3 属于未登记的 Symbol 值，所以返回 undefined。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Symbol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6函数参数解构赋值</title>
      <link href="/ES6%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
      <url>/ES6%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="函数参数解构赋值"><a href="#函数参数解构赋值" class="headerlink" title="函数参数解构赋值"></a>函数参数解构赋值</h2><p>函数的参数可以使用解构赋值。<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">5</span>&#125;); <span class="comment">// [3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move2</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">move2([<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// &#123;x: 4, y: 5&#125;;</span></span><br></pre></td></tr></table></figure><p>但是，以上写法，当函数调用没有传递参数时，就会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move(); <span class="comment">// ​​Cannot destructure property `x` of 'undefined' or 'null'.​</span></span><br><span class="line">move2(); <span class="comment">// ​​Cannot read property 'Symbol(Symbol.iterator)' of undefined​​</span></span><br></pre></td></tr></table></figure><p>所以，当参数使用解构赋值时，需要为参数设置一个默认值。上面的函数改写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">5</span>&#125;); <span class="comment">// [3, 5]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move2</span>(<span class="params">[x, y] = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">move2([<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// &#123;x: 4, y: 5&#125;</span></span><br><span class="line">move2([<span class="number">4</span>]); <span class="comment">// &#123;x: 4, y: undefined&#125;</span></span><br><span class="line">move2(); <span class="comment">// &#123;x: undefined, y: undefined&#125;</span></span><br></pre></td></tr></table></figure><h2 id="函数参数解构赋值默认值"><a href="#函数参数解构赋值默认值" class="headerlink" title="函数参数解构赋值默认值"></a>函数参数解构赋值默认值</h2><p>如下函数 move，接受一个对象为参数，并被解构为变量 x 和 y。变量 x 和 y 使用默认值，可以写成如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;); <span class="comment">// [1, 2]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，ES6 内部使用严格相等运算符（===），判断一个位置是否有值，只有一个解构的成员严格等于 undefined，才会触发默认值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;); <span class="comment">// [null, 0]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ES6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
            <tag> 解构赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue实现思路简单分析</title>
      <link href="/Vue%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
      <url>/Vue%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><div class="vuedata"><br>  <img src="/uploads/Vue/data.png" alt="image"><br></div></p><style>@media screen and (min-width: 768px) {  .posts-expand .post-body .vuedata {    position: relative;    margin: 0 auto;    line-height: 1.2;    width: 300px;    height: 250px;  }  .posts-expand .post-body .vuedata img {    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);    border: 0;    margin: 0 auto;    padding: 0;    width: 450px;    max-width: 450px;  }}</style><a id="more"></a><p>主要分析 Vue 数据代理、模板解析、数据绑定等方面，配合一些代码，简单实现 Vue 基本功能。</p><blockquote><p>注意：本文并没有直接参考 Vue 源码，参考源码为：<a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a></p></blockquote><h1 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h1><p>Vue 中，配置对象中的 data 对象中的数据，保存在 vm 对象的 <code>$data</code> 属性中，由 vm 对象进行代理。</p><p>创建如下 vm 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'cencen'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过 vm 代理读取 <code>$data</code> 中的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.msg); <span class="comment">// cencen</span></span><br></pre></td></tr></table></figure></p><p>通过 vm 代理更改 <code>$data</code> 中的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.msg = <span class="string">'岑大王'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(vm.$data.msg); <span class="comment">// 岑大王</span></span><br></pre></td></tr></table></figure></p><p><strong>模拟实现原理</strong></p><ul><li><p>将传入的选项对象中的 data 属性值，保存在 vm 实例的 <code>$data</code> 属性中</p></li><li><p>遍历 data 对象的所有属性，添加到 vm 实例上。</p></li><li><p>在 vm 上定义新的属性时，使用访问描述符</p><ul><li>属性的 get 方法返回 vm 实例上的 <code>$data</code> 属性对象上对应的属性值</li><li>set 方法将新的属性值设置到 <code>$data</code> 对象上对应的属性。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$option = option;</span><br><span class="line">  <span class="comment">// 将 option 选项对象的 data 属性，保存到变量 data和 vm 的 $data 属性</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>.$data = <span class="keyword">this</span>.$option.data;</span><br><span class="line">  <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 遍历 data 对象的所有属性，添加 vm 代理</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    vm._proxy(key);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype = &#123;</span><br><span class="line">  <span class="comment">// 代理方法</span></span><br><span class="line">  _proxy (key)&#123;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 在 vm 实例上添加对应的属性，实现对 $data 对象上的属性的代理</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>, <span class="comment">// 不可重新定义</span></span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">      <span class="comment">// 代理读</span></span><br><span class="line">      <span class="keyword">get</span>: function proxyGetter()&#123;</span><br><span class="line">        <span class="keyword">return</span> vm.$data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 代理写</span></span><br><span class="line">      <span class="keyword">set</span>: function proxySetter(newVal)&#123;</span><br><span class="line">        vm.$data[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h1><p>Vue 使用模板，实现在页面上使用 model 中的数据。</p><p>模板解析，就是操作页面上的节点，按照相应的规则解析所使用的模板语法，并显示出理想的页面。</p><h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><p>解析模板时，为了防止多次操作页面上的节点，造成过多的重绘重排，可以采用<strong>批量更新</strong>的方法：</p><ul><li>将挂载元素下的所有子节点，移出到代码片段（fragment）中</li><li>在 fragment 中进行模板解析，编译所有子节点</li><li>解析完成后，再将 fragment 插入到挂载元素进行显示</li></ul><p>这样对于页面来说，只进行了移出所有子元素和插入编译好的代码片段两次重排操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="keyword">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$fragment = <span class="keyword">this</span>.node2Fragment(<span class="keyword">this</span>.$el); <span class="comment">// 移出</span></span><br><span class="line">        <span class="keyword">this</span>.init(); <span class="comment">// 解析 fragment</span></span><br><span class="line">        <span class="keyword">this</span>.$el.appendChild(<span class="keyword">this</span>.$fragment); <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  node2Fragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将 el 所有子节点取出，放入暂存元素</span></span><br><span class="line">    <span class="keyword">let</span> childStr = el.innerHTML;</span><br><span class="line">    el.innerHTML = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> tempEl = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    tempEl.innerHTML = childStr;</span><br><span class="line">    <span class="comment">// 创建fragment</span></span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">// 遍历暂存元素，将所有子节点放入fragment</span></span><br><span class="line">    <span class="keyword">while</span>(child = tempEl.firstChild)&#123;</span><br><span class="line">      fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isElementNode: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>在 fragment 中解析模板时，需要遍历 fragment 的所有子节点，根据节点类型，具有不同的解析方式。</p><ul><li>遍历子节点 <code>fragment.chileNodes</code></li><li>判断节点类型 <code>node.nodeType</code></li><li>若为元素节点：对指令属性进行解析<ul><li>事件指令解析</li><li>一般指令解析</li></ul></li><li>若为文本节点：解析表达式<ul><li>通过正则匹配表达式字符串：<code>/\{\{(.*)\}\}/</code></li><li><code>exp = RegExp.$1</code> 获取表达式名</li><li>得到表达式的值<code>vm[exp]</code>后，设置到该文本节点的 textContent</li></ul></li><li>若子节点还包含子节点 <code>if(node.childNodes &amp;&amp; node.childNodes.length)</code>，递归解析该子节点的所有子节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.compileElement(<span class="keyword">this</span>.$fragment);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> childNodes = el.childNodes, <span class="comment">// 获取所有子节点</span></span><br><span class="line">          me = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = node.textContent;</span><br><span class="line">          <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (me.isElementNode(node)) &#123; </span><br><span class="line">              <span class="comment">// 元素节点，解析指令</span></span><br><span class="line">              me.compile(node);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; </span><br><span class="line">              <span class="comment">// 包含表达式的文本节点，解析表达式</span></span><br><span class="line">              me.compileText(node, <span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 元素节点包含子节点，递归解析</span></span><br><span class="line">          <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">              me.compileElement(node);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素节点指令属性解析"><a href="#元素节点指令属性解析" class="headerlink" title="元素节点指令属性解析"></a>元素节点指令属性解析</h2><ul><li>获取元素所有属性：<code>attrs = node.attributes</code></li><li>遍历属性：<code>[].slice.call(attrs).forEach(function(attr){})</code></li><li>得到属性名：<code>attrName = attr.name</code></li><li>得到属性值（表达式名）：<code>exp = attr.value</code></li><li>判断是否是 Vue 指令：<code>attrName.indexOf(&#39;v-&#39;) == 0</code></li><li>获取指令名（不包含 v-）：<code>direcName = attrName.substring(2)</code></li><li>判断是否为事件指令：<code>direcName.indexOf(&#39;on&#39;) === 0</code><ul><li>事件名：<code>eventType = direcName.split(&#39;:&#39;)[1]</code></li><li>得到回调函数：<code>callback = vm.$options.methods[exp]</code></li><li>给元素绑定事件（事件函数绑定 this 为 vm）：<code>node.addEventListener(eventType, callback.bind(vm), false)</code></li></ul></li><li>不是事件指令，则为一般指令<ul><li><code>v-text</code>：操作节点 textContent</li><li><code>v-model</code>：操作节点 value</li><li><code>v-html</code>：操作节点 innerHTML</li><li><code>v-class</code>：操作节点 className</li></ul></li><li>移除指令属性：<code>node.removeAttribute(attrName)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nodeAttrs = node.attributes,</span><br><span class="line">            me = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        [].slice.call(nodeAttrs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name; <span class="comment">// 属性名</span></span><br><span class="line">            <span class="comment">// Vue 属性</span></span><br><span class="line">            <span class="keyword">if</span> (me.isDirective(attrName)) &#123;</span><br><span class="line">                <span class="keyword">var</span> exp = attr.value; <span class="comment">// 表达式</span></span><br><span class="line">                <span class="keyword">var</span> dir = attrName.substring(<span class="number">2</span>); <span class="comment">// 指令名</span></span><br><span class="line">                <span class="keyword">if</span> (me.isEventDirective(dir)) &#123;</span><br><span class="line">                    <span class="comment">// 事件指令</span></span><br><span class="line">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通指令</span></span><br><span class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node.removeAttribute(attrName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isDirective: <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attr.indexOf(<span class="string">'v-'</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isEventDirective: <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.indexOf(<span class="string">'on'</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compileUtil = &#123;</span><br><span class="line">    <span class="comment">// 事件处理</span></span><br><span class="line">    eventHandler: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> eventType = dir.split(<span class="string">':'</span>)[<span class="number">1</span>],</span><br><span class="line">            fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventType &amp;&amp; fn) &#123;</span><br><span class="line">            node.addEventListener(eventType, fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><p>数据绑定（model =&gt; view），一旦更新了 data 中的数据，页面中直接或间接使用了该属性的节点都会更新。</p><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h2 id="实现数据绑定的思想"><a href="#实现数据绑定的思想" class="headerlink" title="实现数据绑定的思想"></a>实现数据绑定的思想</h2><p>Vue 通过数据劫持实现数据绑定，最核心的方法就是<code>Object.defineProperty()</code>，在属性的 getter 方法中，将数据与页面中使用了该数据的节点进行绑定，在 setter 方法中，监视数据变化，当数据发生了变化，通知绑定了该数据的页面节点进行更新。</p><p>实现过程中，比较重要的几点：</p><ul><li>实现一个数据监听器 <strong>Observer</strong>，能够对数据对象 data 的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li><li>实现一个解析器 <strong>Compile</strong>，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li><li>实现一个 <strong>Watcher</strong>，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li><li>mvvm入口函数，整合以上三者</li></ul><p><img src="/uploads/Vue/2.png" alt="image"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li><p>定义 <code>observe</code> 方法，传入一个参数，判断参数如果是对象，则调用 Observer 构造函数，监视该对象所有属性。这里传入 data，监视 data 中所有属性。</p></li><li><p><code>Observer</code> 构造函数中，遍历 data 所有属性，进行如下操作：</p><ul><li>重新调用 <code>observe</code> 方法，传入当前属性，若该属性值是对象，则可以实现监视 data 任意层次数据</li><li>为每一个属性创建一个 dep （dependency）对象，该对象包含一个 id 属性（作为该 dep 的唯一标识），和一个 subs 属性（初始为空数组，用于存储订阅了该属性数据变化的 watcher）。</li><li>使用<code>defineProperty()</code>为 data 重新定义所有属性，定义 getter/setter 方法，实现数据劫持。</li><li><code>getter</code> 方法，用于获取值。当一个 watcher 获取值时，getter 方法会判断当前 dep 和 watcher 是否建立了数据订阅关系，如果没有，则在当前属性的 dep 对象的 subs 属性中，存储该 watcher，并在 watcher 对象的 depIds 属性中存储当前 dep。</li><li><code>setter</code> 方法，用于监视当前属性数据变化，当数据发生改变，则通知该属性的 dep，dep 通知 subs 属性中所有 watcher，watcher 则触发绑定的回调函数，更新视图。</li></ul></li></ul><blockquote><p>data 对象中每个层次的属性，都对应一个 dep 对象。</p></blockquote><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile 解析模板的过程，在第二章已经分析过，这里需要分析一下 Compile 解析模板过程中，是如何实现订阅数据变化的。</p><p>模板解析过程中，当解析表达式（{ {…} }）和元素节点的非事件指令（v-model、v-text、v-html、v-class等）时，将该模板替换成数据显示到页面后，会调用 Wacther 构造函数，为该节点创建一个 watcher 对象，并为该 watcher 对象绑定一个更新该节点视图的回调函数。</p><h3 id="Wacther"><a href="#Wacther" class="headerlink" title="Wacther"></a>Wacther</h3><p>watcher 对象在编译模板的过程中被创建，作为 data 中的数据和视图页面的桥梁。</p><blockquote><p>页面中每一个表达式、元素非事件指令，都对应一个 watcher 对象。</p></blockquote><p>watcher 对象中包含如下属性：</p><ul><li>vm  ： vm对象</li><li>exp ： 对应指令的表达式</li><li>cb  ： 当表达式所对应的数据发生改变时，用于更新页面的回调函数</li><li>value ： 表达式当前的值</li><li>depIds ： 存储表达式中各级属性所对应的 dep 对象的集合对象。属性名为 dep 的 id, 属性值为 dep</li></ul><p>由于 watcher 对象中存储了模板对应表达式的值，所以创建 watcher 对象时，会调用该表达式的各级属性的 getter 方法来获取当前值。在 Observer 中，已经介绍过，getter 方法会判断当前 watcher 对象的 depIds 属性中，是否包含该数据的 dep 对象，若没有，则会分别在 dep 对象的 subs 属性存储当前 watcher 对象，在 watcher 对象的 depIds 属性中，存储该数据的 dep 对象。</p><h3 id="model-到-view-绑定"><a href="#model-到-view-绑定" class="headerlink" title="model 到 view 绑定"></a>model 到 view 绑定</h3><p>watcher 对象中，存储了更新该对象对应的页面节点的回调函数，并且在相应表达式的各级属性中订阅了数据变化的通知。</p><p>当数据发生变化时，由于数据劫持，在 setter 方法中，会通过该数据对应的 dep 对象，通知所有订阅了该数据变化的 watcher，watcher 对象则调用存储的回调函数，更新视图。</p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>前面介绍了 model =&gt; view 的数据绑定，Vue 通过 <code>v-model</code> 指令实现了 view =&gt; model 的数据绑定。</p><p>当解析 <code>v-model</code> 指令时，会给当前元素添加 <code>input</code> 监听事件，当元素的值发生改变时，会将最新的值赋给当前表达式对应的 data 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">model: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bind(node, vm, exp, <span class="string">'model'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>,</span><br><span class="line">        val = <span class="keyword">this</span>._getVMVal(vm, exp);</span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newValue = e.target.value;</span><br><span class="line">        <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me._setVMVal(vm, exp, newValue);</span><br><span class="line">        val = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_getVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = vm._data;</span><br><span class="line">    exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line">    exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_setVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = vm._data;</span><br><span class="line">    exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line">    exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k, i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 非最后一个key，更新val的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">            val = val[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val[k] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据代理 </tag>
            
            <tag> 数据绑定 </tag>
            
            <tag> 模板解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebSocket和Socket.io介绍以及聊天室功能实现</title>
      <link href="/socket-io%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
      <url>/socket-io%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>我在做“你画我猜”小游戏时，为了实现画面实时传递，以及猜题时的聊天室功能，使用了 Socket.io，本文主要介绍 Socket.io 是什么，以及如何使用。<br><a id="more"></a></p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>在介绍 Socket.io 之前，首先需要说一说什么是 WebSocket。</p><p><strong>详细了解参考：</strong></p><ul><li>MDN上的介绍：<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a></li><li>知乎上的介绍：<a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">https://www.zhihu.com/question/20215561</a> </li><li>WebSocket 与 Socket.io 介绍：<a href="http://www.cnblogs.com/mazg/p/5467960.html" target="_blank" rel="noopener">http://www.cnblogs.com/mazg/p/5467960.html</a></li></ul><h2 id="为什么需要WebSocket"><a href="#为什么需要WebSocket" class="headerlink" title="为什么需要WebSocket"></a>为什么需要WebSocket</h2><p>我们知道，在 HTML5 之前，客户端和服务器通过 HTTP 协议交换数据，但是，HTTP 协议具有两个特点：</p><ul><li><p><strong>HTTP 协议是一种单向的网络协议</strong>。在建立连接后，它只允许客户端 Browser/UA (User Agent) 向服务器 WebServer 发送请求后，WebServer 才能返回相应的数据。而 WebServer 不能主动推送数据给 Browser/UA。</p></li><li><p><strong>HTTP 协议是无状态的</strong>。客户端向服务器发送连接请求中会包含 identity info（鉴别信息），每次当一个连接结束时，服务器就会将这些鉴别信息丢掉，客户端再次发送 HTTP 请求时，就需要重新发送这些信息。</p></li></ul><p>现在，假设我们需要开发一个基于 Web 的应用程序，需要获取服务器的实时数据，比如股票的实时行情、聊天室的聊天内容等，这就需要客户端和服务器之间反复进行 HTTP 通信，客户端不断发送请求，去获取当前的实时数据。下面介绍两种常见的方式：</p><ul><li><p><strong>ajax 轮询</strong><br>  ajax 轮询的原理非常简单，就是让浏览器定时（隔几秒）向服务器发送一次请求，询问是否有新的数据，如果有就返回最新数据，浏览器接收到后将最新数据显示出来，然后重复这一过程。</p></li><li><p><strong>Long Polling</strong><br>  Long Polling 的原理与 ajax 轮询的原理差不多，都是采用轮询的方式，它是 Polling 的一种改进。客户端发送请求到服务器后，服务器并不立即响应客户端，而是保持住这次连接，当有新的数据时，才返回给客户端，客户端接收到数据，进行展示，再立即发送一个新的请求给服务器，并重复这个过程。如果服务器的数据长期没有更新，一段时间后，这个请求就会超时，客户端收到超时消息后，再立即发送一个新的请求给服务器。</p></li></ul><p>从上面可以看出，这两种方式都需要不断的建立 HTTP 连接，然后等待服务器处理。</p><p>ajax 轮询假如某段时间内服务器没有更新的数据，但是客户端仍然需要定时发送请求，服务器再把以前的老数据返回过来，客户端拿到老数据，再把没有变化的数据再显示出来，即这段时间内，客户端和服务器会定时交换不变的数据信息，这样既浪费了带宽，又浪费了 CPU 的利用率。</p><p>Long Polling 虽然解决了带宽和 CPU 利用率的问题，但是如果服务器的数据更新的过快，服务器在返回给客户端一次数据包之后，只能等待客户端再次发送一次请求来之后，才能发送下一个数据包给客户端。在服务器两次返回数据之间，需要等待客户端接收到数据之后处理数据的时间，以及客户端再次发送连接请求后，服务器验证客户端的鉴别信息，并成功建立连接的时间，在网络拥塞的情况下，这个应该是用户不能接受的。</p><p>另外，由于 HTTP 协议是无状态的，每次建立连接都需要重新传输 identity info（鉴别信息），这些信息不仅浪费处理时间，而且在网络传输中会耗费大量的流量，往往比实际需要传输的数据量还要大。这样的数据包在网络上周期性的传输，对网络带宽也是一直浪费。</p><p>在这样的情况下，假如客户端能有一种新的网络协议，可以支持客户端和服务器的双向通信的就好了。于是，WebSocket 应运而生。</p><h2 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h2><p>WebSocket 是 HTML5 新增的一种通信协议。WebSocket 协议是一种持久化的双向通信协议，它建立在TCP之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大的不同有两点：</p><ul><li><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/UA 都能主动的向对方发送或接收数据，就像 Socket 一样，不同的是 WebSocket 是一种建立在 Web 基础上的一种简单模拟 Socket 的协议。</p></li><li><p>WebSocket 需要通过握手连接，类似于 TCP 它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。</p></li></ul><h2 id="WebSocket-工作流程"><a href="#WebSocket-工作流程" class="headerlink" title="WebSocket 工作流程"></a>WebSocket 工作流程</h2><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和传统轮询以技术比较，具有很大的性能优势。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 “Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><h2 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h2><p>下面是一个典型的 WebSocket 发送请求和响应请求的例子：</p><p><strong>浏览器向服务器发起 WebSocket 请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Host:127.0.0.1:8088</span><br><span class="line">Origin:null</span><br><span class="line">Sec-WebSocket-Extensions:x-webkit-deflate-frame</span><br><span class="line">Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure></p><p>这个请求与普通的 HTTP 请求有一些区别</p><blockquote><p>Upgrade: websocket<br>Connection: Upgrade</p></blockquote><p>表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议</p><blockquote><p>Sec-WebSocket-Key:<br>Sec-WebSocket-Extensions:<br>Sec-WebSocket-Version: </p></blockquote><p>客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息。Sec-WebSocket-Key 是一个 Base64 encode的值，这个是浏览器随机生成的，Sec-WebSocket-Version 是告诉服务器所使用的 Websocket Draft（协议版本）。</p><p><strong>服务器返回：</strong><br>服务器端返回以下信息，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Server:beetle websocket server</span><br><span class="line">Upgrade:WebSocket</span><br><span class="line">Date:Mon, 26 Nov 2013 23:42:44 GMT</span><br><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Headers:content-type</span><br><span class="line">Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=</span><br></pre></td></tr></table></figure></p><blockquote><p>Upgrade: websocket<br>Connection: Upgrade</p></blockquote><p>告诉客户端即将升级的是Websocket协议</p><blockquote><p>Sec-WebSocket-Accept </p></blockquote><p>这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。</p><h2 id="WebSocket-服务器"><a href="#WebSocket-服务器" class="headerlink" title="WebSocket 服务器"></a>WebSocket 服务器</h2><p>从握手的协议可以看出，如果我们要使用 WebSocket，我们需要一个实现 WebSocket 协议规范的服务器，这不在我们讨论的范围。</p><p>值得一提的是：WebSocket 是可以和 HTTP 共用监听端口的，也就是它可以公用端口完成 socket 任务。</p><h2 id="WebSocket-与-HTTP、TCP-的关系"><a href="#WebSocket-与-HTTP、TCP-的关系" class="headerlink" title="WebSocket 与 HTTP、TCP 的关系"></a>WebSocket 与 HTTP、TCP 的关系</h2><p>WebSocket 与 HTTP 协议一样都是基于 TCP 的，所以他们都是可靠的协议，Web 开发者调用的 WebSocket 的 send 函数在 browser 的实现中最终都是通过 TCP 的系统接口进行传输的。</p><p>WebSocket 和 Http 协议一样都属于应用层的协议，那么他们之间有没有什么关系呢？答案是肯定的，WebSocket 在建立握手连接时，数据是通过 HTTP 协议传输的，正如我们上面所看到的 “GET/chat HTTP/1.1”，这里面用到的只是 HTTP 协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要 HTTP 协议参与的。</p><p><img src="/uploads/websocket/websocket.png" alt="image"></p><h2 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(“ws://echo.websocket.org”);</span><br><span class="line">ws.onopen = function()&#123;ws.send(“Test!”); &#125;;</span><br><span class="line">ws.onmessage = function(evt)&#123;console.log(evt.data);ws.close();&#125;;</span><br><span class="line">ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;;</span><br><span class="line">ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;;</span><br></pre></td></tr></table></figure><p>上面的 JavaScript 代码中，调用了 WebSocket 的 API。</p><p>创建一个 WebSocket 对象，需要调用 WebSocket 的构造函数，并传入需要连接的服务器地址。WebSocket 的 URL 以 ws:// 开头。</p><p>WebSocket 对象具有4个事件：</p><ul><li>onopen：WebSocket 连接成功后触发</li><li>onmessage：浏览器接收到 WebSocket 服务器发送过来的数据时触发</li><li>onclose：浏览器接收到 WebSocket 服务器传来的关闭连接请求时触发</li><li>onerror：连接失败，发送、接收数据失败或者处理数据出现错误时触发</li></ul><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><style>    table {        font-size: 12px;        line-height: 1.2;    }    th:first-child, td:first-child:not(.gutter) {        width: 30%;    }    .post-body a img{        width: 350px;        height: 300px;    }</style><p><strong>Desktop</strong></p><table><thead><tr><th>Feature</th><th>Chrome</th><th>Edge</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari</th></tr></thead><tbody><tr><td>Version -76 support</td><td>6</td><td>No support</td><td>4.0 (2.0)</td><td>No support</td><td>11.00 (disabled)</td><td>5.0.1</td></tr><tr><td>Protocol version 7 support</td><td>No support</td><td>No support</td><td>6.0 (6.0)<code>Moz</code></td><td>No support</td><td>No support</td><td>No support</td></tr><tr><td>Protocol version 10 support</td><td>14</td><td>No support</td><td>7.0 (7.0)<code>Moz</code></td><td>HTML5 Labs</td><td>?</td><td>?</td></tr><tr><td>Standard - RFC 6455 Support</td><td>16</td><td>(Yes)</td><td>11.0 (11.0)</td><td>10</td><td>12.10</td><td>6.0</td></tr><tr><td>Usable in Workers</td><td>(Yes)</td><td>(Yes)</td><td>37.0 (37.0)</td><td>?</td><td>?</td><td>?</td></tr></tbody></table><p><strong>Mobile</strong></p><table><thead><tr><th>Feature</th><th>Android</th><th>Edge</th><th>Firefox Mobile (Gecko)</th><th>IE Mobile</th><th>Opera Mobile</th><th>Safari Mobile</th></tr></thead><tbody><tr><td>Version -76 support</td><td>?</td><td>No support</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Protocol version 7 support</td><td>?</td><td>No support</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Protocol version 8 support (IETF draft 10)</td><td>?</td><td>No support</td><td>7.0 (7.0)</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Standard - RFC 6455 Support</td><td>4.4</td><td>(Yes)</td><td>11.0 (11.0)</td><td>?</td><td>12.10</td><td>6.0</td></tr><tr><td>Usable in Workers</td><td>(Yes)</td><td>(Yes)</td><td>37.0 (37.0)</td><td>?</td><td>?</td><td>?</td></tr></tbody></table><h1 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h1><p>Socket.io 用于浏览器与 Node.js 之间实现实时通信。</p><ul><li>官网：<a href="https://socket.io/" target="_blank" rel="noopener">https://socket.io/</a></li><li>官网聊天室案例：<a href="https://socket.io/get-started/chat/" target="_blank" rel="noopener">https://socket.io/get-started/chat/</a></li><li>Socket.io 中文介绍：<a href="http://www.cnblogs.com/xiezhengcai/p/3956401.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiezhengcai/p/3956401.html</a></li><li>Socket.io 简述：<a href="http://blog.csdn.net/yczz/article/details/51743815" target="_blank" rel="noopener">http://blog.csdn.net/yczz/article/details/51743815</a></li></ul><p>在写这篇文章之前，我只是使用了 Socket.io，但对于它却并不是很了解，之前我一直认为 Socket.io 就是对 WebSocket 协议的实现。事实上，这种看法并不完全正确。</p><h2 id="Socket-io-介绍"><a href="#Socket-io-介绍" class="headerlink" title="Socket.io 介绍"></a>Socket.io 介绍</h2><p>Socket.io 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 协议的用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。</p><p>Socket.io 设计的目标是支持任何的浏览器，任何 Mobile 设备。支持主流的 PC 浏览器 (IE,Safari,Chrome,Firefox,Opera等)，Mobile 浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。</p><p>但是，WebSocket 协议是 HTML5 新推出的协议，浏览器对它的支持并不完善，由此可以看出，Socket.io 不可能仅仅是对 WebSocket 的实现，它还支持其他的通信方式，如上面介绍过的 ajax 轮询和 Long Polling。根据浏览器的支持程度，自主选择使用哪种方式进行通讯。</p><p><strong>Socket.io 支持的通信方式：</strong></p><ul><li>WebSocket</li><li>Adobe Flash Socket</li><li>AJAX long-polling</li><li>AJAX multipart streaming</li><li>Forever IFrame</li><li>JSONP polling</li></ul><h2 id="Socket-io-的使用"><a href="#Socket-io-的使用" class="headerlink" title="Socket.io 的使用"></a>Socket.io 的使用</h2><p>node 端使用 express 框架</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>服务器端：<br><code>npm install --save socket.io</code></p><p>浏览器端（引入本地文件）：<br><code>&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;</code></p><p>浏览器端（CDN 加速）：<br><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;&gt; &lt;/script&gt;</code></p><h3 id="创建-io-服务器"><a href="#创建-io-服务器" class="headerlink" title="创建 io 服务器"></a>创建 io 服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var app = require(&apos;express&apos;)();</span><br><span class="line">var server = require(&apos;http&apos;).Server(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;)(server);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">    res.sendFile(__dirname + &apos;/index.html&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log(&apos;App listening on port 3000!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>Socket.IO 提供了默认事件（如：connect, message, disconnect）。另外，Socket.IO允许发送并接收自定义事件。</p><p><strong>监听客户端连接，回调函数会传递本次连接的socket</strong></p><blockquote><p>io.on(‘connection’,function(socket){  });</p></blockquote><p><strong>给所有客户端广播消息</strong></p><blockquote><p>io.sockets.emit(‘String’,data);</p></blockquote><p><strong>给指定的客户端发送自定义事件</strong></p><blockquote><p>socket.emit(‘String’, data);<br>io.sockets.socket(socketid).emit(‘String’, data);</p></blockquote><p><strong>接收客户端发送的自定义事件</strong></p><blockquote><p>socket.on(‘String’,function(data));</p></blockquote><p><strong>给除了自己以外的客户端广播消息</strong></p><blockquote><p>socket.broadcast.emit(“msg”, data); </p></blockquote><h3 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h3><p>房间是 Socket.IO 提供的一个非常好用的功能。房间相当于为指定的一些客户端提供了一个命名空间，所有在房间里的广播和通信都不会影响到房间以外的客户端。</p><p><strong>使用 join() 方法将 socket 加入房间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class="line">    socket.on(&apos;group1&apos;, function (data) &#123;</span><br><span class="line">        socket.join(&apos;group1&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(&apos;group2&apos;,function(data)&#123;</span><br><span class="line">        socket.join(&apos;group2&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>使用 leave() 方法离开房间：</strong></p><blockquote><p>socket.leave(‘some room’);</p></blockquote><p><strong>向房间中除了当前 socket 的其他 socket 发送消息</strong></p><blockquote><p>socket.broadcast.to(‘group1’).emit(‘event_name’, data);<br>broadcast方法允许当前socket client不在该分组内</p></blockquote><p><strong>向房间中所有的 socket 发送消息</strong></p><blockquote><p>io.sockets.in(‘group1’).emit(‘event_name’, data);</p></blockquote><p><strong>获取连接的客户端 socket</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.clients().forEach(function (socket) &#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>获取所有房间（分组）信息</strong></p><blockquote><p>io.sockets.manager.rooms</p></blockquote><p><strong>来获取此socketid进入的房间信息</strong></p><blockquote><p>io.sockets.manager.roomClients[socket.id]</p></blockquote><p><strong>获取particular room中的客户端，返回所有在此房间的socket实例</strong></p><blockquote><p>io.sockets.clients(‘particular room’)</p></blockquote><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>通过命名空间可以为 Socket.IO 设置子程序。默认命名空间为 “/”，Socket.IO 默认连接该路径。</p><p>使用 of() 函数可以自定义命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var chat = io.of(&apos;/chat&apos;);</span><br><span class="line">chat.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class="line">  console.log(&apos;someone connected&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>建立一个 socket 连接</strong></p><blockquote><p>var socket = io.connect( window.location.protocol + ‘//‘ + window.location.host);</p></blockquote><p>或</p><blockquote><p>var socket = io( window.location.protocol + ‘//‘ + window.location.host);</p></blockquote><p><strong>建立有命名空间的 socket 连接</strong></p><blockquote><p>var chat = io.connect( window.location.protocol + ‘//‘ + window.location.host + ‘/chat’);</p></blockquote><p><strong>监听服务器消息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&apos;msg&apos;,function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>socket.on(“String”,function(data){}) 监听服务端发送的消息, String 参数与服务器端 socket.emit(‘String’, data) 第一个参数 String 相同。</p></blockquote><p><strong>向服务器发送消息</strong></p><blockquote><p>socket.emit(‘msg’, data);</p></blockquote><p><strong>监听 socket 断开与重连</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">    console.log(&quot;与服务器断开&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(&apos;reconnect&apos;, function() &#123;</span><br><span class="line">    console.log(&quot;重新连接到服务器&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>客户端 socket.on() 监听的事件</strong></p><ul><li>connect：连接成功</li><li>connecting：正在连接</li><li>disconnect：断开连接</li><li>connect_failed：连接失败</li><li>error：错误发生，并且无法被其他事件类型所处理</li><li>message：同服务器端message事件</li><li>anything：同服务器端anything事件</li><li>reconnect_failed：重连失败</li><li>reconnect：成功重连</li><li>reconnecting：正在重连</li></ul><h1 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h1><p>流程：</p><ul><li>创建 socket 服务器</li><li>浏览器建立 socket 连接</li><li>页面输入聊天内容，点击 “发送” 按钮，向自定义 socket 事件 “chat” 发送聊天信息</li><li>服务器监听浏览器 “chat” 事件，当接收到浏览器发来的聊天信息时，将信息发送给所有连接了 socket 的浏览器</li><li>浏览器监听服务器发来的 “chat” 事件，接收到聊天信息时，在页面上显示</li></ul><p><img src="/uploads/gif/chat.gif" alt="image"></p><p>node 端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">var server = require(&apos;http&apos;).Server(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;)(server);</span><br><span class="line"></span><br><span class="line">io.sockets.on(&apos;connection&apos;, function(socket) &#123;</span><br><span class="line">    // 监听客户端发送的 chat 事件</span><br><span class="line">    socket.on(&apos;chat&apos;, function (chatinfo) &#123;</span><br><span class="line">        // 向当前 socket 发送聊天信息</span><br><span class="line">        socket.emit(&apos;chat&apos;, chatinfo);</span><br><span class="line">        // 向除了当前 socket 外的所有 socket 发送聊天信息</span><br><span class="line">        socket.broadcast.emit(&apos;chat&apos;, chatinfo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log(&apos;App listening on port 3000!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>HTML 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;chat&quot;&gt;</span><br><span class="line">    &lt;ul id=&quot;chatList&quot;&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;chatContent&quot; id=&quot;chatContent&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;sendChatContent&quot; value=&quot;发送&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>浏览器 socket 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 建立 socket 连接</span><br><span class="line">var url = window.location.protocol+&apos;//&apos;+window.location.host;</span><br><span class="line">socket = io.connect(url);</span><br><span class="line"></span><br><span class="line">// 点击“发送”，向服务器发送聊天信息</span><br><span class="line">$(&apos;#sendChatContent&apos;).click(function (ev) &#123;</span><br><span class="line">    var username = $(&apos;#username&apos;).text();</span><br><span class="line">    var chatContent = $(&apos;#chatContent&apos;).val().trim();</span><br><span class="line">    if(!chatContent)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(socket)&#123;</span><br><span class="line">        // 向服务器 chat 事件，发送信息</span><br><span class="line">        socket.emit(&apos;chat&apos;, &#123;username: username, chatContent: chatContent&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    $(&apos;#chatContent&apos;).val(&apos;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 监听服务器发送来的 chat 事件</span><br><span class="line">socket.on(&apos;chat&apos;, function (chatinfo) &#123;</span><br><span class="line">    $(&apos;#chatList&apos;).append(&apos;&lt;li&gt;&lt;span class=&quot;chatusername&quot;&gt;&apos; + chatinfo.username + &apos;&lt;/span&gt;：&lt;span class=&quot;chatcontent&quot;&gt;&apos; + chatinfo.chatContent + &apos;&lt;/span&gt;&lt;/li&gt;&apos;);</span><br><span class="line">    $(&apos;#chatList&apos;).scrollTop(10000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> WebSocket </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
            <tag> Socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue学习笔记</title>
      <link href="/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><div class="vuel"><br>  <img src="/uploads/Vue/logo.png" alt="image"><br></div></p><style>  .posts-expand .post-body .vuel {    margin: 0 auto;    line-height: 1.2;  }  .posts-expand .post-body .vuel img {    border: 0;    margin: 0 auto;    padding: 0;    width: 150px;  }</style><a id="more"></a><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p><strong>beforeCreate</strong></p><p>数据代理<br>数据绑定</p></li><li><p><strong>created</strong>  =&gt;  异步任务（定时器、ajax、事件监听）</p><p>编译模板</p></li><li><p><strong>beforeMount</strong></p><p>批量更新到挂载元素</p></li><li><p><strong>mounted</strong>  =&gt;  异步任务（定时器、ajax、事件监听）</p><p>更新数据</p></li><li><p><strong>beforeUpdate</strong></p><p>重新渲染虚拟 DOM</p></li><li><p><strong>updated</strong></p><p>vm.$destroy()</p></li><li><p><strong>beforeDestroy</strong>   =&gt;  清除定时器</p></li><li><p><strong>destroyed</strong></p></li></ul><p><div class="lifecycle"><br>  <img src="/uploads/Vue/lifecycle.png" alt="image"><br></div></p><style>.posts-expand .post-body .lifecycle img {  margin: 0 auto;  padding: 0;  width: 380px;}</style><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>指令：自定义元素属性</p><p>Vue 预定义了一些指令，也可以自定义</p><h3 id="全局指令"><a href="#全局指令" class="headerlink" title="全局指令"></a>全局指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">  el.innerHTML = binding.value.toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部指令"><a href="#局部指令" class="headerlink" title="局部指令"></a>局部指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  <span class="string">'my-directive'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">    el.innerHTML = binding.value.toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>注册指令时，指令名不用写 <code>v-</code>，但是使用指令时，必须添加上。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-my-directive</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器线程机制与事件机制</title>
      <link href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p><strong>进程</strong></p><ul><li>程序的一次执行, 它占有一片独有的内存空间</li><li>可以通过 windows 任务管理器查看进程<a id="more"></a></li></ul><p><strong>线程</strong></p><ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul><p><strong>关系</strong></p><ul><li>程序是在某个进程中的某个线程执行的</li><li>一个进程中至少有一个运行的线程：主线程, 进程启动后自动创建</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li><li>线程池( thread pool )：保存多个线程对象的容器, 实现线程对象的反复利用</li></ul><h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>多进程：一应用程序可以同时启动多个实例运行。<br>多线程：在一个进程内, 同时有多个线程运行。</p><h2 id="比较单线程与多线程"><a href="#比较单线程与多线程" class="headerlink" title="比较单线程与多线程"></a>比较单线程与多线程</h2><table><thead><tr><th style="text-align:center">比较</th><th style="text-align:center">单线程</th><th style="text-align:center">多线程 </th></tr></thead><tbody><tr><td style="text-align:center">   优点</td><td style="text-align:center">顺序编程简单易懂</td><td style="text-align:center">能有效提升CPU的利用率</td></tr><tr><td style="text-align:center">   缺点</td><td style="text-align:center">效率低</td><td style="text-align:center">创建多线程开销<br>线程间切换开销<br>死锁与状态同步问题</td></tr></tbody></table><h2 id="浏览器运行是单进程还是多进程"><a href="#浏览器运行是单进程还是多进程" class="headerlink" title="浏览器运行是单进程还是多进程?"></a>浏览器运行是单进程还是多进程?</h2><ul><li>有的是单进程<ul><li>firefox</li><li>老版IE</li></ul></li><li>有的是多进程<ul><li>chrome</li><li>新版IE</li></ul></li></ul><blockquote><p>如何查看浏览器是否是多进程运行的呢? == 任务管理器==&gt;进程</p></blockquote><h2 id="浏览器运行是单线程还是多线程"><a href="#浏览器运行是单线程还是多线程" class="headerlink" title="浏览器运行是单线程还是多线程?"></a>浏览器运行是单线程还是多线程?</h2><p>浏览器都是多线程运行的</p><h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核（browser core）是支持浏览器运行的最核心的程序。</p><h2 id="各个浏览器的内核"><a href="#各个浏览器的内核" class="headerlink" title="各个浏览器的内核"></a>各个浏览器的内核</h2><table><thead><tr><th style="text-align:center">浏览器</th><th style="text-align:center">内核</th></tr></thead><tbody><tr><td style="text-align:center">Chrome、Safari</td><td style="text-align:center">webkit</td></tr><tr><td style="text-align:center">firefox</td><td style="text-align:center">Gecko</td></tr><tr><td style="text-align:center">IE</td><td style="text-align:center">Trident</td></tr><tr><td style="text-align:center">360、搜狗等国内浏览器</td><td style="text-align:center">Trident + webkit （双内核）</td></tr></tbody></table><h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul><li>主线程<ul><li>js 引擎模块 ：负责 js 程序的编译与运行</li><li>html，css 文档解析模块 ：负责页面文本的解析</li><li>DOM/CSS 模块 ：负责 dom/css 在内存中的相关处理 </li><li>布局和渲染模块 ：负责页面的布局和效果的绘制(内存中的对象)</li></ul></li><li>分线程<ul><li>定时器模块 ：负责定时器的管理</li><li>事件响应模块 ：负责事件的管理</li><li>网络请求模块 ：负责 Ajax 请求</li></ul></li></ul><h1 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h1><p>JavaScript 的执行是单线程的。所有的 JavaScript 代码，包括回调代码，最终都会在执行栈（execution stack）中执行。</p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><h1 id="浏览器的事件循环模型"><a href="#浏览器的事件循环模型" class="headerlink" title="浏览器的事件循环模型"></a>浏览器的事件循环模型</h1><p><strong>浏览器将代码分为两类：</strong></p><ul><li>初始化执行代码：普通代码，包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码：处理回调逻辑（回调函数）</li></ul><p><strong>模型的2个重要组成部分</strong></p><ul><li>事件管理模块（下图的 Web APIs部分）</li><li>回调队列（callback queue）</li></ul><style>    img {        transform: scale(0.8);    }</style><p><img src="/uploads/thread/事件循环模型.png" alt="image"></p><p><strong>事件循环模型的运转流程</strong></p><ul><li>执行执行栈中的初始化代码，将事件回调函数交给对应模块管理。</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队（callback queue）中。</li><li>只有当执行栈中的初始化代码执行完后（可能要一定时间）, 才会遍历读取回调队列中的回调函数并执行。</li></ul><h1 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题"></a>定时器问题</h1><p>通过上面介绍过的事件循环运转流程，可以得知，定时器（setTimeout）回调函数只有在执行栈中的初始化代码全部执行完后才执行。因此，定时器并不能保证真正定时执行，如果在主线程在启动定时器之后执行了一个长时间的操作（时间超过定时器设置的时间），就会导致定时器回调函数延时处理。</p><h1 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h1><p>传统 JavaScript 是单线程运行的，HTML5 新推出了一个 Web Worker 接口，可以实现在分线程中执行一个单独的 js 文件。</p><p>Web Workers是一种机制，通过它可以使一个脚本操作在与Web应用程序的主执行线程分离的后台线程中运行。这样做的优点是可以在单独的线程中执行繁琐的处理，让主（通常是UI）线程运行而不被阻塞/减慢。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web Workers API</a></p><p>一个 worker 是使用构造函数创建的一个对象（例如,Worker()）, 运行一个命名的 JavaScript文件 — 这个文件包含了将在 worker 线程中运行的代码，并且 worker 在与当前 window 不同的另一个全局上下文中运行。这个上下文由专用worker的情况下的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope" target="_blank" rel="noopener">DedicatedWorkerGlobalScope</a> 对象表示（标准 workers 由单个脚本使用; 共享 workers 使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorkerGlobalScope" target="_blank" rel="noopener">SharedWorkerGlobalScope</a> ）。</p><p>在 worker 线程中可以运行任意的代码，以下情况除外：不能直接在 worker 线程中操纵 DOM 元素, 或者使用某些 window 对象中默认的方法和属性。 但是 window 对象中很多的方法和属性是可以使用的，包括 WebSockets，以及诸如 IndexedDB 和 FireFox OS 中独有的 Data Store API 这一类数据存储机制。</p><p>主线程和 worker 线程之间通过这样的方式互相传输信息：两端都使用 postMessage() 方法来发送信息, 并且通过 onmessage 这个 event handler 来接收信息。 （传递的信息包含在 Message 这个事件的数据属性内) 。数据的交互是通过传递副本，而不是直接共享数据。</p><p>一个 worker 可以生成另外的新的 worker，这些 worker 的宿主和它们父页面的宿主相同。  此外，worker 可以通过 XMLHttpRequest 来访问网络，只是 XMLHttpRequest 的 responseXML 和 channel 这两个属性将总是 null 。</p><h2 id="Web-Workers-使用实例"><a href="#Web-Workers-使用实例" class="headerlink" title="Web Workers 使用实例"></a>Web Workers 使用实例</h2><p><strong>实现效果</strong></p><p>在输入框中输入一个数字 n，点击按钮，得到斐波那契数列中第 n 个数字的值。</p><p><strong>分析</strong></p><p>当数字 n 的值较大时，计算结果耗用时间比较长，如果计算的过程在主线程执行，则这段时间内页面将无法操作。</p><p>这种情况下，可以将计算的过程放在一个分线程中执行，主线程则可以继续执行其他代码，不会导致页面无法操作。当分线程得到结果之后，再将数据返回给主线程，主线程接收到数据，再进行处理。</p><p><strong>代码</strong></p><p>页面（主线程）代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;number&quot; value=&quot;30&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;btn2&quot;&gt;分线程计算fibonacci值&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        let number = document.getElementById(&apos;number&apos;);</span><br><span class="line">        let btn2 = document.getElementById(&apos;btn2&apos;);</span><br><span class="line"></span><br><span class="line">        btn2.onclick = ev =&gt; &#123;</span><br><span class="line">            let n = number.value * 1;</span><br><span class="line">            let worker = new Worker(&apos;worker.js&apos;);</span><br><span class="line">            console.log(&apos;主线程向子线程发送消息&apos;);</span><br><span class="line">            worker.postMessage(n);</span><br><span class="line">            worker.onmessage = event =&gt; &#123;</span><br><span class="line">                console.log(&apos;主线程接受到子线程发来的消息&apos;);</span><br><span class="line">                alert(event.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>worker.js文件（分线程）代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var onmessage = event =&gt; &#123;</span><br><span class="line">    let n = event.data;</span><br><span class="line">    console.log(&apos;子线程接收到主线程发送的消息&apos;);</span><br><span class="line">    let result = fibonacci(n);</span><br><span class="line">    postMessage(result);</span><br><span class="line">    console.log(&apos;子线程向主线程发送消息&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Web-Workers-不足"><a href="#Web-Workers-不足" class="headerlink" title="Web Workers 不足"></a>Web Workers 不足</h2><ul><li>worker 内代码不能操作 DOM (更新 UI)</li><li>不能跨域加载 JS</li><li>不是每个浏览器都支持这个新特性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事件机制 </tag>
            
            <tag> 回调队列 </tag>
            
            <tag> Web Workers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm命令</title>
      <link href="/npm%E5%91%BD%E4%BB%A4/"/>
      <url>/npm%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>简单介绍一下包管理工具 npm 和 yarn 的一些命令。<br><a id="more"></a></p><h2 id="基于node工程"><a href="#基于node工程" class="headerlink" title="基于node工程"></a>基于node工程</h2><h3 id="包-项目，工程"><a href="#包-项目，工程" class="headerlink" title="包(项目，工程)"></a>包(项目，工程)</h3><ul><li><p>概念</p><p>  1、在Node.js语言中，包和模块并没有本质的不同，包是在模块的基础上更深一步的抽象。<br>  2、包将某个独立的功能封装起来，用于发布、更新、依赖管理和进行版本控制。<br>  3、Node.js根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。</p></li><li><p>包的说明文件(package.json)</p><ul><li>使用package.json能干什么<br>  1、 相当于你本地项目的一个文档说明。<br>  2、允许你指定你项目中所使用的node包的版本。<br>  3、构建你的项目更加容易，便于给其他人共享。</li><li><p>package.json属性详解</p><ul><li><p>本质：json对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;npm_command&quot;, //包名</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;, //版本</span><br><span class="line">    &quot;scripts&quot;: &#123; //配置npm运行命令</span><br><span class="line">    &quot;start&quot;: &quot;node bin/www&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;//运行依赖的包</span><br><span class="line">    &quot;jquery&quot;: &quot;^3.2.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;//开发依赖的包</span><br><span class="line">    &quot;babel&quot;: &quot;^6.23.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;jquery&quot;: &quot;^3.2.1&quot; -----向上的尖括号可以管理二级，三级版本</span><br><span class="line">&quot;jquery&quot;: &quot;~3.2.1&quot; -----波浪线可以管理三级版本。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="npm-包管理工具"><a href="#npm-包管理工具" class="headerlink" title="npm(包管理工具)"></a>npm(包管理工具)</h3><p>1、Node 包管理器 (npm) 是一个由 Node.js 官方提供的第三方包管理工具,<br>2、npm 是一个完全由 JavaScript 实现的命令行工具，通过 Node.js 执行，因此严格来讲它不属于 Node.js 的一部分。<br>3、在最初的版本中，我们需要在安装完 Node.js 以后手动安装npm。<br>    但从Node.js 0.6开始，npm已包含在发行包中了，安装Node.js时会自动安装npm。<br>    现在的版本大都使用6.0以上。。。</p><h2 id="npm命令详解"><a href="#npm命令详解" class="headerlink" title="npm命令详解"></a>npm命令详解</h2><p>使用npm命令来下载依赖模块及对项目包(模块)进行管理<br>常用命令：</p><ul><li>npm init: 生成package.json</li><li>npm install:用来安装package.json里的相关依赖包</li><li>npm install packageName -g(全局安装)</li><li>npm install packageName –save 安装包(局部安装—运行依赖)</li><li>npm install packageName@version –save 安装指定版本的包(局部安装)</li><li>npm install packageName –save-dev(局部安装–开发依赖)</li><li>npm info packageName (显示包的信息)</li><li>npm rm packageName (移除包)</li><li>npm config get prefix (获取全局安装包的所在地址,并且可见对应的cmd命令)</li></ul><p>使用npm导致的问题(更多的是针对5.0以下版本)</p><ul><li>下载慢</li><li>甚至下载不了</li></ul><h2 id="cnpm-淘宝镜像"><a href="#cnpm-淘宝镜像" class="headerlink" title="cnpm(淘宝镜像)"></a>cnpm(淘宝镜像)</h2><ul><li>将npm上的包同步更新到淘宝镜像上，目前是每10分钟同步一次。</li><li>配置：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>  常用命令：使用 cnpm 代替 npm 即可</li><li>使用 cnpm 的问题：<ul><li>会多下载一些文件/文件夹</li><li>严重者会导致 webstorm 瘫痪，就像帕金森综合征</li></ul></li><li>解决上述问题的办法<ul><li>修改 npm 的下载指向地址<br>  npm config set registry “<a href="https://registry.npm.taobao.org&quot;" target="_blank" rel="noopener">https://registry.npm.taobao.org&quot;</a></li></ul></li><li>修改仓库地址为npm地址：<br>  npm config set registry <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a></li></ul><h2 id="yarn-Facebook开发的包管理工具"><a href="#yarn-Facebook开发的包管理工具" class="headerlink" title="yarn Facebook开发的包管理工具"></a>yarn Facebook开发的包管理工具</h2><h3 id="yarn-包管理工具"><a href="#yarn-包管理工具" class="headerlink" title="yarn(包管理工具)"></a>yarn(包管理工具)</h3><ul><li>yarn是Facebook开源的新的包管理器，可以用来代替npm</li><li>安装 npm install yarn -g</li><li>特点：有缓存，没有自己的仓库地址</li><li>常用命令<ul><li>yarn –version</li><li>yarn</li><li>yarn init  //生成package.json   ！！！注意生成的包名不能有中文，大写</li><li>yarn global package (全局安装)</li><li>yarn add package (局部安装)</li><li>yarn add package –dev</li><li>yarn remove package</li><li>yarn list //列出已经安装的包名</li><li>yarn info packageName</li><li>地址：<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">https://yarnpkg.com/zh-Hans/</a></li></ul></li></ul><h3 id="cyarn"><a href="#cyarn" class="headerlink" title="cyarn"></a>cyarn</h3><ul><li>使用淘宝镜像，更快</li><li>配置：npm install cyarn -g –registry “<a href="https://registry.npm.taobao.org&quot;" target="_blank" rel="noopener">https://registry.npm.taobao.org&quot;</a></li><li>常用命令：将 yarn 使用cyarn代替即可</li></ul><h2 id="补充扩展："><a href="#补充扩展：" class="headerlink" title="补充扩展："></a>补充扩展：</h2><p>2017年5月30日发布node 8.0，其中自带的npm也由3.xxx版本升级到5.0</p><p>npm5变化：</p><ul><li>通过npm下载包的时候多了一个 package.lock.json</li><li>package.lock.json可以记录整个 node-modules 中文件夹的树状结构，再次下载的时候不用先去读取包与包之间相关依赖。（就是记录包与包之间的关联 – 依赖关系）</li><li>好处：再次 npm install 下载的时候不用去先读取依赖可以直接下载，速度较快。</li><li>可以利用离线缓存，合理的利用了缓存，提高了下载效率</li><li>在速度上还是和yarn有些差异。</li><li>–save 是一个默认属性，npm install 下载包的时候会在 package.json 里显示依赖</li><li>注意：npm3和npm5并没有完美对接<br>  如果之前的项目是用npm下载的包，当后期用npm下载其他包的时候之前的包的依赖是无法读取到package.lock.json里，导致之前的包无法使用，此时需要npm install重新下载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm命令 </tag>
            
            <tag> yarn命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的重绘与重排</title>
      <link href="/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/"/>
      <url>/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/</url>
      
        <content type="html"><![CDATA[<p>　　浏览器从下载文件到显示页面是一个很复杂的过程。浏览器下载完页面中的所有组件 – HTML标记、JavaScript、CSS、图片 – 之后会解析并生成两个内部数据结构：</p><ul><li>DOM 树<br>  表示页面结构</li><li>渲染树<br>  表示 DOM 节点在页面中如何显示（宽高、位置等）</li></ul><a id="more"></a><p>　　DOM 树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的 DOM 元素在渲染树中没有对应的节点）。渲染树中的节点被称为 “帧（frames）” 或 “盒（boxes）” ,符合 CSS 模型的定义，理解页面元素为一个具有内边距（padding）、外边距（margin）、边框（border）和位置（position）的盒子。一旦 DOM 树和渲染树构建完成，浏览器就开始显示（绘制“paint”）页面元素。</p><p>　　当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。</p><p>　　并不是所有的 DOM 变化都会影响几何属性。例如，改变元素的背景色不会影响宽和高，这种情况下，只会发生一次重绘（不需要重排），因为元素的布局并没有改变。</p><blockquote><p>重排一定会引起浏览器的重绘，而重绘则不一定伴随重排。</p></blockquote><p>　　重绘和重排操作都是代价昂贵的操作，它会导致 WEB 应用程序的 UI 反应迟钝。所以，应当尽可能减少这类过程的发生。</p><h1 id="触发重排的情况"><a href="#触发重排的情况" class="headerlink" title="触发重排的情况"></a>触发重排的情况</h1><p>　　当页面布局的几何属性改变时就需要 “重排”。下述情况会导致重排：</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素位置改变</li><li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）</li><li>内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替</li><li>页面渲染器初始化</li><li>浏览器窗口尺寸改变</li><li>获取会导致渲染队列刷新的属性（详细介绍如下）</li></ul><p>根据改变的范围和程度，渲染树中相应部分也需要重新计算。  </p><blockquote><p>当滚动条出现时，会触发整个页面的重排。</p></blockquote><h2 id="渲染树变化的排队与刷新"><a href="#渲染树变化的排队与刷新" class="headerlink" title="渲染树变化的排队与刷新"></a>渲染树变化的排队与刷新</h2><p>　　由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。<br>　　然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致队列刷新，比如使用以下属性：</p><ul><li>offsetTop , offsetLeft , offsetWidth , offsetHeight</li><li>scrollTop , scrollLeft , scrollWidth , scrollHeight</li><li>clientTop , clientLeft , clientWidth , clientHeight</li><li>getComputedStyle() ( currentStyle in IE )</li></ul><p>当获取以上的属性和方法时，浏览器为了获取最新的布局信息，不得不执行渲染队列中的 “待处理变化” ，并<strong>触发重排</strong>以返回正确的值。</p><h1 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h1><p>　　重绘和重排的代价非常昂贵，因此一个好的提高程序响应速度的策略就是减少此类操作的发生。</p><h2 id="合并多次对样式属性的操作"><a href="#合并多次对样式属性的操作" class="headerlink" title="合并多次对样式属性的操作"></a>合并多次对样式属性的操作</h2><p>　　为了减少重绘重排发生的次数，应该合并多次对 DOM 和样式的修改，然后一次处理掉。</p><p>考虑下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.style.borderLeft = &apos;1px&apos;;</span><br><span class="line">el.style.borderRight = &apos;2px&apos;;</span><br><span class="line">el.style.padding = &apos;5px&apos;;</span><br></pre></td></tr></table></figure></p><p>　　示例中有三个样式属性被改变，每一个都会影响元素的几何结构。最糟糕的情况下，会导致浏览器触发三次重排。大部分现代浏览器为此做了优化，只会触发一次重排，但是在旧的浏览器中或者有一个分离的异步处理过程时（比如使用计时器），仍然效率低下。如果在上面代码执行时，有其他代码请求布局信息，这会导致三次重排。而且，这段代码四次访问 DOM ，可以被优化。</p><p>　　上面的代码执行效率更高的方式是：将多次改变样式属性的操作合并为一次操作，这样只会修改 DOM 一次。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.style.cssText = &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;</span><br></pre></td></tr></table></figure></p><p>　　另一个一次性修改样式的办法是修改 CSS 的 class 名称，而不是修改内联样式。这种方法适用于那些不依赖于运行逻辑和计算的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.className = &apos;active&apos;;</span><br></pre></td></tr></table></figure></p><h2 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h2><p>　　当需要对 DOM 元素进行一系列操作时，可以通过以下步骤来减少重绘和重排的次数：</p><ol><li>使元素脱离文档流</li><li>操作元素</li><li>操作完成后，将元素带回文档中</li></ol><p>这样，只有在第一步和第三步会触发两次重排。</p><p>有三种方式可以实现上面的步骤：</p><ul><li><p>隐藏元素（display: none;），操作元素，重新显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">ul.style.display = &apos;none&apos;;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">var clone = old.cloneNode(true);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>推荐尽可能的使用文档片段（第二个方案），因为它们所产生的 DOM 遍历和重排次数最少。唯一潜在的问题是文档片段未被充分利用，很多人可能并不熟悉这项技术。</p></blockquote><h2 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h2><p>　　浏览器获取元素的 offsetLeft 等属性值时，会导致重排。最好的做法是，将需要获取的布局信息的属性值，赋值给变量，然后再操作变量。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>　　将需要多次重排的元素，position 属性设置为 absolute 或 fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《高性能JavaScript》 第三章–DOM编程</li><li><a href="http://kb.cnblogs.com/page/169820/" target="_blank" rel="noopener">浏览器的重绘与重排</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DOM重绘重排 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义bind函数</title>
      <link href="/%E8%87%AA%E5%AE%9A%E4%B9%89bind%E5%87%BD%E6%95%B0/"/>
      <url>/%E8%87%AA%E5%AE%9A%E4%B9%89bind%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>MDN 对 <code>Function.prototype.bind()</code> 函数的介绍：</p><p>　　bind() 方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。<br><a id="more"></a><br><strong>语法：</strong></p><pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></pre><p><strong>参数：</strong></p><ul><li>thisArg<br>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。</li><li>arg1, arg2, …<br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li></ul><p><strong>返回值：</strong><br>　　返回由指定的 this 值和初始化参数改造的原函数拷贝</p><hr><p>为了更好的理解 bind 函数，我定义了一个 mybind 函数，并通过 mybind 函数实现了 bind 函数的作用。<br>mybind 函数代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.mybind = function() &#123;</span><br><span class="line">    if (arguments.length &lt; 1) &#123;</span><br><span class="line">        throw &apos;Function mybind requires at least one parameter&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    var that = this;</span><br><span class="line">    var $this = arguments[0];</span><br><span class="line">    var args = [];</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        var arg = arguments[i];</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            args.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var newArgs = [];</span><br><span class="line">        for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            var arg = arguments[i];</span><br><span class="line">            newArgs.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        that.apply($this, args.concat(newArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试 mybind 函数的作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    uname: &apos;测试&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fun(a, b) &#123;</span><br><span class="line">    console.log(this.uname, a, b);</span><br><span class="line">&#125;</span><br><span class="line">var fun1 = fun.mybind(obj, 12);</span><br><span class="line">fun1(23);</span><br></pre></td></tr></table></figure></p><p>运行后得到： <code>测试 12 23</code> ， mybind 函数基本实现了 bind 函数的功能。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自定义bind函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LESS 介绍</title>
      <link href="/LESS-%E4%BB%8B%E7%BB%8D/"/>
      <url>/LESS-%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>　　less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br><a id="more"></a><br>　　LESS 做为 CSS 的一种形式的扩展，它并没有阉割 CSS 的功能，而是在现有的 CSS 语法上，添加了很多额外的功能。</p><p>　　less的中文官网：<a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a><br>　　bootstrap中关于less的介绍：<a href="http://www.bootcss.com/p/lesscss/#docs" target="_blank" rel="noopener">http://www.bootcss.com/p/lesscss/#docs</a></p><p><strong>Less编译工具</strong><br>　　koala 官网： <a href="http://www.koala-app.com" target="_blank" rel="noopener">www.koala-app.com</a> </p><h1 id="less中的注释"><a href="#less中的注释" class="headerlink" title="less中的注释"></a>less中的注释</h1><ul><li>以 // 开头的注释，不会被编译到css文件中</li><li>以 /**/ 包裹的注释，会被编译到css文件中  </li></ul><h1 id="less中的变量"><a href="#less中的变量" class="headerlink" title="less中的变量"></a>less中的变量</h1><p>使用 @ 来申明一个变量：<code>@变量名：变量值;</code></p><ol><li><p>作为普通属性值来使用：直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@pink: pink;</span><br><span class="line">.box&#123;</span><br><span class="line">    background: @pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为选择器和属性名：@{ 变量名 } 的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@wrap: #wrap;</span><br><span class="line">@w: width;</span><br><span class="line"></span><br><span class="line">@&#123;wrap&#125;&#123;</span><br><span class="line">    @&#123;w&#125;: 400px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为 URL：@{url}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@imgUrl: &quot;../img/zdy.jpg&quot;;</span><br><span class="line"></span><br><span class="line">@&#123;wrap&#125;&#123;</span><br><span class="line">    background: url(&quot;@&#123;imgUrl&#125;&quot;) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.</p></blockquote><h1 id="less中的嵌套规则"><a href="#less中的嵌套规则" class="headerlink" title="less中的嵌套规则"></a>less中的嵌套规则</h1><p>LESS 可以用嵌套的方式编写层叠样式.</p><h2 id="基本嵌套规则"><a href="#基本嵌套规则" class="headerlink" title="基本嵌套规则"></a>基本嵌套规则</h2><p>如下 CSS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#list span &#123;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 LESS 可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line"></span><br><span class="line">    span&#123;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="amp-的使用"><a href="#amp-的使用" class="headerlink" title="&amp; 的使用"></a>&amp; 的使用</h2><p>如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用，如 :hover 和 :focus.</p><p>如下 CSS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#list a &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">#list a:hover &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 LESS 可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list&#123;</span><br><span class="line">    a&#123;</span><br><span class="line">        float: left; </span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h1><p>　　在 LESS 中我们可以定义一些通用的属性集为一个class，然后在另一个 class 中去调用这些属性。<br>　　混合就是将一系列属性从一个规则集引入到另一个规则集的方式。</p><blockquote><p>任何 CSS <em>class</em>, _id_ 或者 _元素_ 属性集都可以以同样的方式引入.</p></blockquote><h2 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h2><p>定义一个通用属性集，实现子元素垂直水平居中，在需要居中的子元素上调用该属性集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.middle&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不带输出的混合"><a href="#不带输出的混合" class="headerlink" title="不带输出的混合"></a>不带输出的混合</h2><p>使用普通混合方式，在 LESS 中定义的通用属性集会被编译到 CSS 文件中，如果想隐藏通用属性集，不让它暴露到 CSS 中，可以定义不带参数的属性集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.middle() &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h2><p>在 LESS 中，还可以像函数一样定义一个带参数的属性集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.border-radius (@radius) &#123;</span><br><span class="line">    border-radius: @radius;</span><br><span class="line">    -moz-border-radius: @radius;</span><br><span class="line">    -webkit-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line">#header &#123;</span><br><span class="line">    .border-radius(4px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带参数并且有默认值的混合"><a href="#带参数并且有默认值的混合" class="headerlink" title="带参数并且有默认值的混合"></a>带参数并且有默认值的混合</h2><p>参数可以设置默认值，调用时如果不传参数，则使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.border-radius (@radius: 5px) &#123;</span><br><span class="line">    border-radius: @radius;</span><br><span class="line">    -moz-border-radius: @radius;</span><br><span class="line">    -webkit-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line">#header &#123;</span><br><span class="line">    .border-radius;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带多个参数的混合"><a href="#带多个参数的混合" class="headerlink" title="带多个参数的混合"></a>带多个参数的混合</h2><p>参数可以传多个，传入的实参与形参从左往右进行匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.middle (@w:100px, @h:100px, @c:pink) &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: @w;</span><br><span class="line">    height:@h;</span><br><span class="line">    background: @c;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle(50px, 50px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>在上面的示例代码中，传入的参数会从左往右与形参进行匹配，如果希望 @w 使用默认值，只传入 @h、@c，则实参与形参不能按照默认方式匹配，这时可以使用命名参数传参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.middle ( @w: 100px, @h: 100px, @c: pink) &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: @w;</span><br><span class="line">    height:@h;</span><br><span class="line">    background: @c;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner2&#123;</span><br><span class="line">        .middle( @h: 200px; @c: deeppink);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><p>混合的参数不一定是变量，也可以是固定值。</p><p>变量可以匹配任意的传入值，而固定值就仅仅匹配与其相等的传入值。</p><p>只有被匹配的混合才会被使用。</p><p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.triangle( @_, @w:10px)&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(top, @w:10px)&#123;</span><br><span class="line">    border-width: @w;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(bottom, @w:10px)&#123;</span><br><span class="line">    border-width: @w;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这样运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#box1&#123;</span><br><span class="line">    .triangle(top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#box1 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-width: 10px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现如下：</p><ol><li>第一个混合定义被成功匹配，因为它接受任意值</li><li>第二个混合定义被成功匹配，因为它只接受 top 作为首参</li><li>第三个混合定义未被匹配，因为它只接受 bottom 作为首参</li></ol><p><strong>我们也可以匹配多个参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.mixin (@a) &#123;</span><br><span class="line">&#125;</span><br><span class="line">.mixin (@a, @b) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用 .mixin 时，如果只传入一个参数，则会匹配到第一个 .mixin 混合，如果传入两个参数，则匹配第二个。</p><h2 id="arguments变量"><a href="#arguments变量" class="headerlink" title="@arguments变量"></a>@arguments变量</h2><p>@arguments包含了所有传递进来的参数。如果你不想单独处理每一个参数的话就可以像这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.border(@w:20px, @c:black, @style:solid)&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    border: @arguments;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    .border(10px, deeppink, solid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    border: 10px #ff1493 solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="less运算"><a href="#less运算" class="headerlink" title="less运算"></a>less运算</h1><p>在 less 中可以进行加减乘除的运算。<br>任何 _数字_、_颜色_ 或者 _变量_ 都可以参与运算。</p><p>如下 LESS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@base: 5%;</span><br><span class="line">@filler: @base * 2;</span><br><span class="line">@other: @base + @filler;</span><br><span class="line">.box&#123;</span><br><span class="line">    color: #888 / 4;</span><br><span class="line">    background-color: @base - @other + #111;</span><br><span class="line">    height: 100% / 2 + @filler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    color: #222222;</span><br><span class="line">    background-color: #070707;</span><br><span class="line">    height: 60%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位。如果像下面这样单位运算的话:  </p><pre><code>@var: 1px + 5;</code></pre><p>LESS 会输出 <code>6px</code>.</p><p>括号也同样允许使用:  </p><pre><code>@width: (@var + 5) * 2;</code></pre><p>可以在复合属性中进行运算:  </p><pre><code>border: (@width * 2) solid black;</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>　　LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。<br>　　内层声明块作用域中的变量，在父级作用域中无法获取。</p><h2 id="变量延迟加载"><a href="#变量延迟加载" class="headerlink" title="变量延迟加载"></a>变量延迟加载</h2><p>　　同一个作用域中，变量的使用会在变量被全部赋值后执行。<br>　　如下代码中，.inner 内定义了两次 @test 变量，less 编译时，会在 .inner 作用域中先将变量定义的代码全部执行，然后才使用该变量，所以在 .inner 使用 @test 变量，得到的结果为 3。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    @test: 1;</span><br><span class="line">    .inner&#123;</span><br><span class="line">        @test: 2;</span><br><span class="line">        width: @test; // 3</span><br><span class="line">        @test: 3;</span><br><span class="line">    &#125;</span><br><span class="line">    width: @test; // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>有时候，为了更好组织 CSS 或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 可以像下面这样在 #bundle 中定义一些属性集之后可以重复使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#bundle &#123;</span><br><span class="line">    .button() &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">        background-color: grey;</span><br><span class="line">        &amp;:hover &#123; background-color: white;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .tab &#123; ... &#125;</span><br><span class="line">    .citation &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header a &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">    #bundle &gt; .button;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Importing"><a href="#Importing" class="headerlink" title="Importing"></a>Importing</h1><p>可以在main文件中通过下面的形式引入 .less 文件, .less 后缀可带可不带:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.less&quot;;</span><br><span class="line">@import &quot;lib&quot;;</span><br></pre></td></tr></table></figure></p><p>如果想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.css&quot;;</span><br></pre></td></tr></table></figure></p><p>这样LESS就会跳过它不去处理它.</p><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><p>变量可以嵌入到字符串中。<br>上面介绍过的变量作为 URL 使用的方式，就是将变量插入到字符串中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@base-url: &quot;http://assets.fnord.com&quot;;</span><br><span class="line">background-image: url(&quot;@&#123;base-url&#125;/images/bg.png&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="避免编译"><a href="#避免编译" class="headerlink" title="避免编译"></a>避免编译</h1><p>有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。<br>要输出这样的值我们可以将避免编译的值用 <code>&quot;&quot;</code> 包含起来，并在字符串前加上一个 <code>~</code>, 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">    filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> CSS预处理器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LESS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex布局</title>
      <link href="/flex%E5%B8%83%E5%B1%80/"/>
      <url>/flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><a id="more"></a></p><p>CSS3 弹性盒子（Flexible Box 或 Flexbox），是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测的运行行/列。<br>对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。</p><p>弹性盒模型，分老版与新版</p><ul><li>老版本的通常称之为 box</li><li>新版本的通常称之为 flex</li></ul><p>任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 Flex 布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p></blockquote><h2 id="flex-布局基本概念"><a href="#flex-布局基本概念" class="headerlink" title="flex 布局基本概念"></a>flex 布局基本概念</h2><p>flex 布局重要的两组概念</p><h3 id="容器与项目"><a href="#容器与项目" class="headerlink" title="容器与项目"></a>容器与项目</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><h3 id="主轴与侧轴"><a href="#主轴与侧轴" class="headerlink" title="主轴与侧轴"></a>主轴与侧轴</h3><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<br>主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p>主轴由容器的布局方向决定<br>    新版：flex-direction<br>    老版：-webkit-box-orient</p><h1 id="老版"><a href="#老版" class="headerlink" title="老版"></a>老版</h1><p>容器设置为<br>display: webkit-box</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的布局方向"><a href="#容器的布局方向" class="headerlink" title="容器的布局方向"></a>容器的布局方向</h3><p>-webkit-box-orient</p><ul><li>horizontal ：主轴为 X 轴</li><li>vertical ：主轴为 Y 轴</li></ul><h3 id="容器的排列方向"><a href="#容器的排列方向" class="headerlink" title="容器的排列方向"></a>容器的排列方向</h3><p>-webkit-box-direction</p><ul><li>normal ：项目正序排列</li><li>reverse ：项目倒序排列</li></ul><h3 id="富裕空间的管理"><a href="#富裕空间的管理" class="headerlink" title="富裕空间的管理"></a>富裕空间的管理</h3><p>不会给项目区分配空间，只是确定富裕空间的位置。<br>理解：确定容器的布局方向和排列方向后，项目布局的起点。如主轴为 X 轴，排列方向为 normal，主轴富裕空间为 start，则项目在左侧，富裕空间在右侧；主轴富裕空间为 center，则项目在中间，富裕空间在两侧。</p><p><strong>主轴富裕空间</strong></p><p>-webkit-box-pack</p><ul><li>start</li><li>end</li><li>center</li><li>justify</li></ul><p><strong>侧轴富裕空间</strong></p><p>-webkit-box-align</p><ul><li>start</li><li>end</li><li>center</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="弹性空间的管理"><a href="#弹性空间的管理" class="headerlink" title="弹性空间的管理"></a>弹性空间的管理</h3><p>将富裕空间按比例分配到各个项目上</p><p>-webkit-box-flex: 1;</p><h1 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h1><p>容器设置为<br>display: flex;</p><h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>新版中，容器的布局方向和排列方向使用同一个属性。</p><p>flex-direction</p><ul><li>row：主轴为水平方向，起点在左端。</li><li>column：主轴为水平方向，起点在右端。</li><li>row-reverse：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>定义了项目在主轴上的对齐方式。<br>可以看做主轴上富裕空间的管理。</p><ul><li>flex-start：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around(box 没有的)：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>定义项目在交叉轴（侧轴）上如何对齐。</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline(box 没有的)：项目的第一行文字的基线对齐。</li><li>stretch(默认值)：等高布局，如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。</p><p>控制容器为单行/列还是多行/列。并且定义了侧轴的方向，新行/列将沿侧轴方向堆砌。</p><p>继承性：不可继承</p><ul><li>nowrap：默认值，不换行</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>“flex-direction”和“flex-wrap”的简写，控制主轴和侧轴的位置以及方向</p><p>继承性：不可继承</p><p>默认值：row nowrap</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><ul><li>flex-start：与交叉轴的起点对齐。<br>  所有行/列从侧轴起点开始填充。第一行/列的侧轴起点边和容器的侧轴起点边对齐。接下来的每一行/列紧跟前一行/列。</li><li>flex-end：与交叉轴的终点对齐。<br>  所有弹性元素从侧轴末尾开始填充。最后一个弹性元素的侧轴终点和容器的侧轴终点对齐。同时所有后续元素与前一个对齐。</li><li>center：与交叉轴的中点对齐。<br>  所有行/列朝向容器的中心填充。每行/列互相紧挨，相对于容器居中对齐。容器的侧轴起点边和第一行/列的距离相等于容器的侧轴终点边和最后一行/列的距离。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>  所有行/列在容器中平均分布。相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的边对齐。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>  所有行/列在容器中平均分布，相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的距离是相邻两行/列间距的一半。</li><li>stretch（默认值）：轴线占满整个交叉轴。<br>  拉伸所有行/列来填满剩余空间。剩余空间平均的分配给每一行/列。</li></ul><h2 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p><code>order: &lt;integer&gt;;</code></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p><p><code>flex-grow: &lt;number&gt;; /* default 0 */</code></p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><code>flex-shrink: &lt;number&gt;; /* default 1 */</code></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小（width的值）。</p><p><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code></p><p>可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex-grow, flex-shrink 和 flex-basis的简写，默认值为 0 1 auto。后两个属性可选。</p><p><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self属性允许单个项目侧轴有与其他项目不一样的对齐方式，可覆盖align-items属性。<br>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><ul><li>auto<br>  设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch。</li><li>flex-start<br>  flex 元素会对齐到 cross-axis 的首端。</li><li>flex-end<br>  flex 元素会对齐到 cross-axis 的尾端。</li><li>center<br>  flex 元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出。</li><li>baseline<br>  所有的 flex 元素会沿着基线对齐。</li><li>stretch<br>  flex 元素将会基于容器的宽和高，按照自身 margin box 的 cross-size 拉伸。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">阮一峰 flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰 flex 布局教程：实例篇</a><br><a href="http://flexboxfroggy.com/" target="_blank" rel="noopener">青蛙游戏</a></p>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>块级元素水平垂直居中</title>
      <link href="/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
      <url>/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<p>将一个块级元素水平垂直居中的方法<br><a id="more"></a><br>元素 HTML 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>要实现的效果：</p><style>#wrap {    position: relative;    width: 120px;    height: 120px;    background: lightblue;}#inner {    position: absolute;    left: 50%;    top: 50%;    margin-left: -25px;    margin-top: -25px;    width: 50px;    height: 50px;    background: yellow;}</style><div id="wrap"><br>    <div id="inner"></div><br></div><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>子元素的 width + padding + margin + left + right = 包含块宽度。<br>当子元素的 width 确定，padding、left、right 都为 0 ，margin 为 auto 时，包含块的宽度 - width 剩余的值，则为 margin 的值，margin-left 和 margin-right 平分这个值的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h3><p>使用第一种方式，必须知道元素的宽高，当元素宽高不确定时，可以使用平移的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水平垂直居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zepto</title>
      <link href="/Zepto/"/>
      <url>/Zepto/</url>
      
        <content type="html"><![CDATA[<p>　　Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。 如果你会用jquery，那么你也会用zepto。<br>　　Zepto.js (1.1.6)文档下载：<a href="http://www.css88.com/doc/zeptojs-1.1.6_api/" target="_blank" rel="noopener">http://www.css88.com/doc/zeptojs-1.1.6_api/</a><br>　　需要注意的是Zepto的一些可选功能是专门针对移动端浏览器的，因为它的最初目标在移动端提供一个精简的类似jquery的js库。</p><p></p><p style="font-size: 14px;height:20px;margin:0;padding-left:30px;"> Zepto 官网：<a href="http://zeptojs.com/" target="_blank" rel="noopener">http://zeptojs.com/</a><br>Zepto API中文文档：<a href="http://www.css88.com/doc/zeptojs_api/" target="_blank" rel="noopener">http://www.css88.com/doc/zeptojs_api/</a></p><br><a id="more"></a><p></p><h1 id="Zepto特点"><a href="#Zepto特点" class="headerlink" title="Zepto特点"></a>Zepto特点</h1><p>1、轻量级，压缩版本只有8kb左右<br>2、针对移动端的框架<br>3、语法同jquery大部分一样，都是$为核心函数<br>4、响应，执行快。<br>5、目前功能完善的框架体积最小的一个</p><h1 id="Zepto核心函数"><a href="#Zepto核心函数" class="headerlink" title="Zepto核心函数"></a>Zepto核心函数</h1><p>Zepto 核心函数与 jQuery 相同，使用 $ 指向 Zepto 本身。</p><p>与jQuery的核心函数相同，Zepto 的核心函数有四种类型的参数：</p><ul><li>1、function(){}<br>  参数为一个函数，代表页面加载完成后立即执行函数里的代码。</li><li>2、选择器字符串<br>  　　参数为选择器字符串，返回一个 Zepto 集合对象，与 jQuery 对象类似，Zepto 集合对象也是一个类数组对象，包含所有符合指定选择器的 DOM 元素。<br>  　　Zepto 集合对象同样拥有与 jQuery 对象类似的方法。</li><li>3、html标签字符串<br>  参数为 html 标签字符串，可以用来创建 DOM 节点。</li><li>4、DOM节点<br>  参数为 DOM 节点，返回一个包含该 DOM 节点的 Zepto 集合对象。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;div&apos;)  //=&gt; 所有页面中得div元素</span><br><span class="line">$(&apos;#foo&apos;) //=&gt; ID 为 &quot;foo&quot; 的元素</span><br><span class="line"></span><br><span class="line">// 创建元素:</span><br><span class="line">$(&quot;&lt;p&gt;Hello&lt;/p&gt;&quot;) //=&gt; 新的p元素</span><br><span class="line">// 创建带有属性的元素:</span><br><span class="line">$(&quot;&lt;p /&gt;&quot;, &#123; text:&quot;Hello&quot;, id:&quot;greeting&quot;, css:&#123;color:&apos;darkblue&apos;&#125; &#125;)</span><br><span class="line">//=&gt; &lt;p id=greeting style=&quot;color:darkblue&quot;&gt;Hello&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">// 当页面ready的时候，执行回调:</span><br><span class="line">Zepto(function($)&#123;</span><br><span class="line">  alert(&apos;Ready to Zepto!&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="Zepto核心方法"><a href="#Zepto核心方法" class="headerlink" title="Zepto核心方法"></a>Zepto核心方法</h1><p>Zepto 的核心方法与 jQuery 类似，如：</p><p>1、$.ajax() 、 $.get() 、$.post()<br>2、$.each()<br>3、$.trim()<br>4、$.isArray()<br>…..</p><p>Zepto 集合对象同样拥有与 jQuery 对象类似的方法，如：</p><p>1、addClass()<br>2、show()<br>3、find()<br>…..</p><p>可参考 Zepto 官方文档。</p><h1 id="Zepto-与-jQuery-的区别"><a href="#Zepto-与-jQuery-的区别" class="headerlink" title="Zepto 与 jQuery 的区别"></a>Zepto 与 jQuery 的区别</h1><h2 id="attr和prop"><a href="#attr和prop" class="headerlink" title="attr和prop"></a>attr和prop</h2><p>在 jQuery 中，prop() 方法多用在获取标签的固有属性，尤其是布尔值属性（如disabled、checked、selected），attr() 方法多用在获取自定义属性。如果用 attr() 方法获取布尔值属性，且该属性在标签内没有定义，则会得到 undefined，而 prop() 方法会得到 false。</p><p>jQuery代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;haha&lt;/button&gt;</span><br><span class="line">console.log($(&apos;#btn&apos;).prop(&apos;disabled&apos;)); // =&gt;&gt; false</span><br><span class="line">console.log($(&apos;#btn&apos;).attr(&apos;disabled&apos;)); // =&gt;&gt; undefined</span><br></pre></td></tr></table></figure></p><p>在 Zepto 中，<strong>attr() 方法也可以获取标签的布尔值属性</strong>。不过 prop() 方法在读取属性时优先级高于 attr() 方法，布尔值属性的读取还是建议用 prop() 方法。</p><blockquote><p>需要注意的是：在 Zepto 中，removeProp() 的方法，在1.2+版本中才支持。</p></blockquote><p>Zepto代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=&quot;btn&quot;&gt;haha&lt;/button&gt;</span><br><span class="line">console.log($(&apos;#btn&apos;).prop(&apos;disabled&apos;)); // =&gt;&gt; false</span><br><span class="line">console.log($(&apos;#btn&apos;).attr(&apos;disabled&apos;)); // =&gt;&gt; false</span><br></pre></td></tr></table></figure></p><h2 id="使用核心函数创建DOM节点"><a href="#使用核心函数创建DOM节点" class="headerlink" title="使用核心函数创建DOM节点"></a>使用核心函数创建DOM节点</h2><p>Zepto 和 jQuery 都可以通过核心函数创建 DOM 元素，不同的是，Zepto 可以添加一个参数配置对象，配置对象中的属性会直接添加到新创建的标签属性内，实现结构、样式分离，而且容易管理。</p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var newdiv = $(&apos;&lt;div&gt;通过zepto创建的div&lt;/div&gt;&apos;, &#123;</span><br><span class="line">    id: &apos;newdiv&apos;,</span><br><span class="line">    css: &#123;</span><br><span class="line">        height: &apos;30px&apos;,</span><br><span class="line">        lineHeight: &apos;30px&apos;,</span><br><span class="line">        background: &apos;yellow&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;body&apos;).append(newdiv);</span><br></pre></td></tr></table></figure></p><p>以上代码，使用 Zepto，运行后得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;newdiv&quot; style=&quot;height: 30px; line-height: 30px; background: yellow;&quot;&gt;通过zepto创建的div&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如果使用的是 jQuery，则会得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;通过jQuery创建的div&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>然而，在一个例外的情况下，jQuery 传入配置对象也会起作用，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var newdiv = $(&apos;&lt;div&gt;&lt;/div&gt;&apos;, &#123;</span><br><span class="line">    id: &apos;newdiv&apos;,</span><br><span class="line">    css: &#123;</span><br><span class="line">        height: &apos;30px&apos;,</span><br><span class="line">        lineHeight: &apos;30px&apos;,</span><br><span class="line">        background: &apos;yellow&apos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;body&apos;).append(newdiv);</span><br></pre></td></tr></table></figure></p><p>使用jQuery，得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;newdiv&quot; style=&quot;height: 30px; line-height: 30px; background: yellow;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如上，如果传入的HTML标签字符串是一个空标签，则即使使用 jQuery，配置对象也会起作用。这样的话，只要为配置对象添加 text 属性，就可以为标签添加内容。</p><h2 id="offset-方法"><a href="#offset-方法" class="headerlink" title="offset()方法"></a>offset()方法</h2><p>offset() 方法用来获取目标元素相对于视口的偏移量对象。</p><p>在 jQuery 中，得到的偏移量对象包含两个整型属性：top 和 left。</p><p>在 Zepto 中，得到的偏移量对象包含4个属性：top, left, width和height。且获取到的 width 和 height 包含 padding 和 border 的值，相当于 jQuery 中的 outerWidth() 和 outerHeight()。</p><p>不论是 jQuery 还是 Zepto，offset() 都只对可见元素有效，若元素不可见，则得到的属性值都是 0。</p><h2 id="width-和-height"><a href="#width-和-height" class="headerlink" title="width() 和 height()"></a>width() 和 height()</h2><p>获取一个元素的宽高：</p><p><strong>jQuery：</strong></p><ul><li>width()、height()方法：获取 content 内容区的值，没有单位</li><li>.css(‘width’)：获取content内容区的值，有单位px</li><li>innerWidth()、innerHeight()：content + padding的值，没有单位</li><li>outerHeight()、outerWidth()：content + padding + border的值，没有单位</li></ul><p><strong>Zepto：</strong></p><ul><li>width()、height()方法：content + padding + border的值，没有单位，相当于 jQuery 中的 outerWidth() 和 outerHeight()</li><li>.css(‘width’)：获取content内容区的值，有单位px</li><li>zepto 中没有 innerHeight()、innerWidth()、outerHeight() 和 outerWidth() 这四个方法</li></ul><h2 id="获取隐藏元素的宽高"><a href="#获取隐藏元素的宽高" class="headerlink" title="获取隐藏元素的宽高"></a>获取隐藏元素的宽高</h2><p>jQuery 通过 width()、innerWidth()、outerWidth() 这三组方法，都可以获取隐藏元素的宽高。</p><p>Zepto 的 width()、height() 方法无法得到隐藏元素的宽高，隐藏元素调用这两个方法，只能返回 0。</p><p>使用 Zepto 如果想要获取隐藏元素的宽高，可以通过 css() 方法，获取特定的样式值。</p><h2 id="each-方法"><a href="#each-方法" class="headerlink" title="each()方法"></a>each()方法</h2><p><strong>jQuery 的 each() 方法：</strong><br>1、可以遍历数组,以index，item的形式，<br>2、可以遍历对象，以key-value的形式<br>3、不可以遍历字符串。</p><p><strong>zepto 的 each() 方法：</strong><br>1、可以遍历数组,以index，item的形式，<br>2、可以遍历对象，以key-value的形式<br>3、可以遍历字符串。<br>4、遍历json对象，以字符串的形式遍历。</p><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>在 jQuery 中，事件委托使用 delegate() 方法（live() 方法在 jQuery1.7 以上已经废除）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#box&apos;).delegate(&apos;.a&apos;,&apos;click&apos;,function () &#123;</span><br><span class="line">    alert(&apos;delegate&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，delegate() 方法的回调函数中的 this 指向触发事件的元素。</p></blockquote><p>在 Zepto 中，Zepto 官网表示已经要废除 live、delegate 等方法，推荐使用 on 方法代替。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#box&apos;).on(&apos;touchstart&apos;, &apos;.a&apos;, function () &#123;</span><br><span class="line">    alert(&apos;我是a触发的事件委托&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h1 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h1><ul><li>on()<br>  绑定事件处理程序</li><li>off()<br>  方法移除用目标元素on绑定的事件处理程序。</li><li>bind()<br>  为每个匹配元素的特定事件绑定事件处理函数，可同时绑定多个事件，也可以自定义事件。</li><li>one()<br>  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。只执行一次。</li><li>trigger()<br>  触发由bind定义的事件（通常是自定义事件）</li><li>unbind()<br>  bind的反向操作，删除匹配元素所绑定的bind事件。</li><li>delegate<br>  基于一组特定的根元素为所有选择器匹配的元素附加一个处理事件，匹配的元素可能现在或将来才创建。</li><li>undelegate<br>  移除通过delegate 注册的事件</li><li>live<br>  类似delegate，添加一个事件处理器到符合目前选择器的所有元素匹配，匹配的元素可能现在或将来才创建。</li><li>die<br>  删除通过 live 添加的事件。</li></ul><blockquote><p>注意：新版本的zepto中已经舍弃了bind，delegate，live，同样jquery中舍弃了live等。<br>zepto 现在统一使用on，off标准事件来绑定事件。</p></blockquote><h1 id="Touch-events"><a href="#Touch-events" class="headerlink" title="Touch events"></a>Touch events</h1><p>touch 模块添加以下事件，可以直接调用，也可以通过 on 绑定事件：</p><ul><li>tap()：点击事件。利用在document上绑定touch事件来模拟tap事件的，并且tap事件会冒泡到document上</li><li>singleTap()：单击事件</li><li>doubleTap()：双击事件</li><li>longTap()：当一个元素被按住超过 750ms 触发。</li><li>swipe, swipeLeft, swipeRight, swipeUp, swipeDown：当元素被划过（同一个方向大于30px）时触发。(可选择给定的方向)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#box1&apos;).tap(function (e) &#123;</span><br><span class="line">    console.log(&apos;这是box1的tap事件&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="form表单方法"><a href="#form表单方法" class="headerlink" title="form表单方法"></a>form表单方法</h1><h2 id="serialize"><a href="#serialize" class="headerlink" title="serialize()"></a>serialize()</h2><ul><li>在Ajax post请求中将用作提交的表单元素的值编译成 URL-encoded 字符串。—key(name)/value</li><li>不能使用的表单元素：buttons、未选中的radio/checkboxs 将会被跳过。</li></ul><h2 id="serializeArray"><a href="#serializeArray" class="headerlink" title="serializeArray()"></a>serializeArray()</h2><ul><li>将用作提交的表单元素的值编译成拥有name和value对象组成的数组。</li><li>不能使用的表单元素，buttons、未选中的radio/checkboxs 将会被跳过。</li><li>结果不包含file inputs的数据。</li></ul><h2 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h2><ul><li>为 “submit” 事件绑定一个处理函数，或者触发元素上的 “submit” 事件。</li><li>当参数function没有给出时，触发当前表单“submit”事件，并且执行默认的提交表单行为，除非调用了 <code>preventDefault()</code> 阻止默认行为。</li><li>当给定function参数时，在当前元素上它简单得为其在“submit”事件绑定一个处理函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zepto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用命令总结</title>
      <link href="/git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"/>
      <url>/git%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结一下常用的 git 命令，以及在使用 git 过程中，可能用到的几个 Linux 命令。<br><a id="more"></a></p><h1 id="git-命令"><a href="#git-命令" class="headerlink" title="git 命令"></a>git 命令</h1><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><p><code>git config --global user.name &quot;Your Name&quot;</code><br><code>git config --global user.email &quot;email@example.com&quot;</code></p><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><h3 id="初始化git项目"><a href="#初始化git项目" class="headerlink" title="初始化git项目"></a>初始化git项目</h3><p><code>git init</code></p><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><p><code>git status</code></p><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><p><code>git add &lt;filename&gt;</code></p><h3 id="提交到本地版本库"><a href="#提交到本地版本库" class="headerlink" title="提交到本地版本库"></a>提交到本地版本库</h3><p><code>git commit -m &quot;message&quot; &lt;filename&gt;</code></p><h3 id="查看工作区和最近版本区别"><a href="#查看工作区和最近版本区别" class="headerlink" title="查看工作区和最近版本区别"></a>查看工作区和最近版本区别</h3><p><code>git diff</code></p><h2 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h2><h3 id="查看日志-1"><a href="#查看日志-1" class="headerlink" title="查看日志"></a>查看日志</h3><p><code>git log</code></p><h3 id="查看7位版本号日志"><a href="#查看7位版本号日志" class="headerlink" title="查看7位版本号日志"></a>查看7位版本号日志</h3><p><code>git reflog</code></p><h2 id="版本回退和版本穿梭"><a href="#版本回退和版本穿梭" class="headerlink" title="版本回退和版本穿梭"></a>版本回退和版本穿梭</h2><h3 id="回退到上一版本"><a href="#回退到上一版本" class="headerlink" title="回退到上一版本"></a>回退到上一版本</h3><p><code>git reset --hard HEAD^</code></p><h3 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h3><p><code>git reset --hard HEAD[^^^...]</code></p><h3 id="前进到某一版本"><a href="#前进到某一版本" class="headerlink" title="前进到某一版本"></a>前进到某一版本</h3><p><code>git reset --hard HEAD[``</code>…]`</p><h3 id="版本穿梭"><a href="#版本穿梭" class="headerlink" title="版本穿梭"></a>版本穿梭</h3><p><code>git reset --hard [7位版本号]</code></p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><h3 id="撤销工作区修改"><a href="#撤销工作区修改" class="headerlink" title="撤销工作区修改"></a>撤销工作区修改</h3><p><code>git checkout -- &lt;filename&gt;</code></p><h3 id="撤销add"><a href="#撤销add" class="headerlink" title="撤销add"></a>撤销add</h3><p><code>git reset HEAD &lt;filename&gt;</code></p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p><code>git rm &lt;filename&gt;</code></p><blockquote><p>会同时删除工作区、暂存区、本地版本库的文件，但是需要 <strong>commit</strong> ，告诉 git 本次修改。</p></blockquote><h2 id="管理分支"><a href="#管理分支" class="headerlink" title="管理分支"></a>管理分支</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p><code>git branch</code></p><blockquote><p>前面带 *，是当前所在分支</p></blockquote><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p><code>git branch &lt;分支名&gt;</code></p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p><code>git checkout &lt;分支名&gt;</code></p><h3 id="创建分支并切换至该分支"><a href="#创建分支并切换至该分支" class="headerlink" title="创建分支并切换至该分支"></a>创建分支并切换至该分支</h3><p><code>git checkout -b dev</code></p><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p><code>git merge &lt;分支名&gt;</code></p><h3 id="合并冲突"><a href="#合并冲突" class="headerlink" title="合并冲突"></a>合并冲突</h3><p>使用 <code>git merge &lt;&gt;</code> 合并发生冲突时，手动解决冲突后，需要使用 <code>git add</code> 和 <code>git commit</code> ，将解决冲突之后的文件提交到本地版本库。</p><blockquote><p>注意：提交冲突解决后的文件时，不要指定文件名。</p></blockquote><h3 id="终止合并"><a href="#终止合并" class="headerlink" title="终止合并"></a>终止合并</h3><p><code>git merge --abort</code></p><blockquote><p>合并冲突后，不想解决冲突，退回合并前的状态。</p></blockquote><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p><code>git branch -d &lt;分支名&gt;</code><br>分支没有被合并，强制删除：<br><code>git branch -D &lt;分支名&gt;</code></p><h2 id="远程库GitHub"><a href="#远程库GitHub" class="headerlink" title="远程库GitHub"></a>远程库GitHub</h2><h3 id="创建-SSH-KEY"><a href="#创建-SSH-KEY" class="headerlink" title="创建 SSH KEY"></a>创建 SSH KEY</h3><p><code>ssh-keygen -t rsa -C “example@163.com”</code></p><blockquote><p>创建 SSH KEY 完成后，需要将 SSH （在用户文件夹下.ssh文件夹中的github_rsa.pub文件中）添加到 GitHub 账号中。</p></blockquote><p><strong>测试连通性</strong><br><code>ssh -T git@github.com</code></p><h3 id="关联远程库"><a href="#关联远程库" class="headerlink" title="关联远程库"></a>关联远程库</h3><p><code>git remote add origin https://github.com/huajianduzhuo/git.git</code></p><h3 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h3><p><code>git push -u origin master</code></p><blockquote><p>-u 只在项目第一次推送远程库时需要，之后不用写</p></blockquote><p>平常推送远程库<br><code>git push origin master</code></p><h3 id="从远程库拉取最新版本"><a href="#从远程库拉取最新版本" class="headerlink" title="从远程库拉取最新版本"></a>从远程库拉取最新版本</h3><p><code>git pull origin master</code></p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p><code>git clone &lt;https | ssh url&gt;</code></p><h3 id="查看远程库信息"><a href="#查看远程库信息" class="headerlink" title="查看远程库信息"></a>查看远程库信息</h3><p><code>git remote</code><br>查看远程库详细信息<br><code>git remote -v</code></p><h1 id="LINUX-命令"><a href="#LINUX-命令" class="headerlink" title="LINUX 命令"></a>LINUX 命令</h1><h4 id="退出VIM："><a href="#退出VIM：" class="headerlink" title="退出VIM："></a>退出VIM：</h4><p><code>esc + :q!</code></p><h4 id="保存并退出VIM："><a href="#保存并退出VIM：" class="headerlink" title="保存并退出VIM："></a>保存并退出VIM：</h4><p><code>esc + :wq!</code></p><h4 id="进入VIM，编辑文件："><a href="#进入VIM，编辑文件：" class="headerlink" title="进入VIM，编辑文件："></a>进入VIM，编辑文件：</h4><p><code>vim &lt;filename&gt;</code></p><blockquote><p>点击 a，进入可编辑状态</p></blockquote><h4 id="删除一行"><a href="#删除一行" class="headerlink" title="删除一行"></a>删除一行</h4><p><code>d + d</code></p><h4 id="查看文件："><a href="#查看文件：" class="headerlink" title="查看文件："></a>查看文件：</h4><p><code>cat &lt;filename&gt;</code></p><h4 id="显示当前目录路径"><a href="#显示当前目录路径" class="headerlink" title="显示当前目录路径"></a>显示当前目录路径</h4><p><code>pwd</code></p><h4 id="新建文件"><a href="#新建文件" class="headerlink" title="新建文件"></a>新建文件</h4><p><code>touch &lt;filename&gt;</code></p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域请求的几种方式</title>
      <link href="/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>AJAX 不能发送跨域请求（不符合同源策略的请求），但是项目中有时需要异步请求跨域的地址，这时简单的 AJAX 不能满足要求。<br><a id="more"></a></p><blockquote><p>同源策略：URL 的协议、域名、端口全部一致。</p></blockquote><h1 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h1><p>　　JSONP（JSON With Padding）不是 AJAX，它是一种非官方的解决跨域请求问题的方式。<br>　　JSONP 利用 HTML 中 script 标签不受同源策略影响，可以跨域请求资源，同时在资源加载后立即执行的特点，实现跨域请求。</p><h2 id="js原生实现jsonp"><a href="#js原生实现jsonp" class="headerlink" title="js原生实现jsonp"></a>js原生实现jsonp</h2><p>通过动态生成 script 标签，将要请求的地址添加到 script 标签的 src 属性，然后将该 script 标签添加到页面。</p><p><strong>页面代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;button id=&quot;btn01&quot;&gt;JSONP&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">    var btn01 = document.getElementById(&quot;btn01&quot;);</span><br><span class="line"></span><br><span class="line">    btn01.onclick = function() &#123;</span><br><span class="line">        //创建一个script标签</span><br><span class="line">        var script = document.createElement(&quot;script&quot;);</span><br><span class="line">        //设置script标签src属性</span><br><span class="line">        script.src = &quot;http://127.0.0.1:3000/testJSONP?callback=abc&quot;;</span><br><span class="line">        //将标签放到body中</span><br><span class="line">        document.body.appendChild(script);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    function abc(data) &#123;</span><br><span class="line">        alert(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>url 地址后面的参数 callback 是指定一个回调函数，用来处理请求得到的数据。</p><p><strong>后台node代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(&quot;/testJSONP&quot;,function (req , res) &#123;</span><br><span class="line">    console.log(&quot;已经收到请求~~~&quot;);</span><br><span class="line">    var data = &apos;这是服务器返回的内容&apos;;</span><br><span class="line"></span><br><span class="line">    // 得到参数-回调函数名</span><br><span class="line">    var callback = req.query.callback;</span><br><span class="line">    // 返回回调函数的调用，并将返回数据作为实参传递给回调函数</span><br><span class="line">    res.send(callback+&quot;(&apos;&quot;+ data +&quot;&apos;)&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery实现jsonp"><a href="#jQuery实现jsonp" class="headerlink" title="jQuery实现jsonp"></a>jQuery实现jsonp</h2><p>　　jQuery 中的 getJSON 方法可以用来发送 JSONP 请求，该方法的使用和 jQuery 的 get、post 方法的调用方式基本相同。<br>　　需要注意的是，url 地址后需要添加参数 callback，callback 的值是一个 ?，jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。</p><p>代码实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(&quot;https://api.douban.com/v2/movie/in_theaters?callback=?&quot;, function(data) &#123;</span><br><span class="line"></span><br><span class="line">    // 处理豆瓣热门电影接口返回的数据，显示到页面</span><br><span class="line">    var sub = data.subjects;</span><br><span class="line">    for (var i = 0; i &lt; sub.length; i++) &#123;</span><br><span class="line">        //将内容添加到div中</span><br><span class="line">        $(&quot;#box1&quot;).append(</span><br><span class="line">            &quot;&lt;li&gt;&quot; + sub[i].title + &quot;&lt;br /&gt;&quot; +</span><br><span class="line">            &quot;&lt;img src=&apos;&quot; + sub[i].images.large + &quot;&apos; &gt;&quot; +</span><br><span class="line">            &quot;&lt;/li&gt;&quot;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="JSONP的局限性"><a href="#JSONP的局限性" class="headerlink" title="JSONP的局限性"></a>JSONP的局限性</h2><p>JSONP 只能发送 get 请求，而不能发送 post 请求。</p><h1 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h1><p>　　Cross-Origin Resource Sharing，跨域资源共享。CORS 是官方的跨域解决方案，相比 JSONP 更能更加全面，也更加灵活。<br>　　使用 CORS 跨域在客户端基本不需要做任何操作，发送正常的 AJAX 请求即可，只需要修改一下服务器的代码。</p><p>　　当发送的 AJAX 请求是跨域请求时，浏览器会自动在请求头信息中，添加一个 Origin 字段，Origin 字段会告诉服务器请求发送的来源（协议+域名+端口）。服务器根据 Origin 的值决定是否允许该跨域请求，默认情况是不允许的。<br>　　我们可以在服务器中设置一个响应头 Access-Control-Allow-Origin，值为允许发送跨域请求的地址。浏览器判断该响应头中是否包含 Origin 的值，如果包含浏览器则处理响应，不包含浏览器直接驳回，无法得到响应数据。</p><p>node 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.set(&apos;Access-Control-Allow-Origin&apos;, &apos;http://localhost:3000&apos;);</span><br></pre></td></tr></table></figure></p><p>如果接受任何域名的请求，可以将该字段的值设置为 * 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.set(&apos;Access-Control-Allow-Origin&apos;, &apos;*&apos;);</span><br></pre></td></tr></table></figure></p><h2 id="CORS-的局限性"><a href="#CORS-的局限性" class="headerlink" title="CORS 的局限性"></a>CORS 的局限性</h2><p>IE 9 及以下版本IE浏览器，不支持通过 XMLHTTPRequest 来发送跨域请求。</p><h1 id="CORS-和-JSONP-的对比"><a href="#CORS-和-JSONP-的对比" class="headerlink" title="CORS 和 JSONP 的对比"></a>CORS 和 JSONP 的对比</h1><ul><li>CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。</li><li>CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。</li><li>JSONP 可以在不支持 CORS 的老旧浏览器上运作。</li></ul><h1 id="XDR"><a href="#XDR" class="headerlink" title="XDR"></a>XDR</h1><p>在 IE8、IE9 浏览器中，需要使用 XDomainRequest 对象来发送跨域请求。</p><p>ajax 请求代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xdr = new XDomainRequest();</span><br><span class="line">xdr.open(&apos;get&apos;, &apos;http://127.0.0.1:3000/getJsonp&apos;);</span><br><span class="line">xdr.send();</span><br><span class="line">xdr.onload = function () &#123;</span><br><span class="line">    alert(xdr.responseText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JSONP </tag>
            
            <tag> CORS </tag>
            
            <tag> XDR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>margin-top向上传递问题解决方案</title>
      <link href="/margin-top%E5%90%91%E4%B8%8A%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/margin-top%E5%90%91%E4%B8%8A%E4%BC%A0%E9%80%92%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>　　当为子元素设置 margin-top 属性时，如果父元素不做特殊设置，子元素的 margin-top 属性会默认被传递给父元素，使父元素相对于上面的元素向下移动 margin-top 的值，而子元素的 margin-top 属性则没有效果。<br>　　这与预想的子元素相对父元素的顶部离开一段距离的效果是不一样的，这个问题是由 <strong>CSS外边距合并</strong> 产生的。<br><a id="more"></a></p><h2 id="外边距合并"><a href="#外边距合并" class="headerlink" title="外边距合并"></a>外边距合并</h2><p>　　外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。</p><blockquote><p>了解CSS外边距合并，可参考：<a href="http://www.w3school.com.cn/css/css_margin_collapsing.asp" target="_blank" rel="noopener">w3school CSS 外边距合并</a>、<a href="http://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html" target="_blank" rel="noopener">深入理解BFC和Margin Collapse </a></p></blockquote><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul><li>为父元素设置 padding-top ，代替为子元素设置 margin-top<blockquote><p>这种方式具有局限性，一些场景不适用</p></blockquote></li><li>为父元素设置 overflow: hidden （推荐）</li><li>为父元素设置 border</li><li>为父元素或者子元素开启绝对定位<blockquote><p>可能会打乱布局</p></blockquote></li><li>为父元素或者子元素设置浮动<blockquote><p>可能会打乱布局</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> margin-top </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js原生ajax</title>
      <link href="/js%E5%8E%9F%E7%94%9Fajax/"/>
      <url>/js%E5%8E%9F%E7%94%9Fajax/</url>
      
        <content type="html"><![CDATA[<p>AJAX (Asynchronous Javascript And XML)，异步 JavaScript 和 XML，是通过 JavaScript 向服务器异步发送请求的技术。</p><p>原生 JavaScript 使用 AJAX 的方法：<br><a id="more"></a></p><h2 id="创建-XMLHttpRequest-对象"><a href="#创建-XMLHttpRequest-对象" class="headerlink" title="创建 XMLHttpRequest 对象"></a>创建 XMLHttpRequest 对象</h2><p>XMLHttpRequest 是 AJAX 的核心对象，ajax 中的所有操作都是通过该对象来完成的。</p><pre><code>var xhr = new XMLHttpRequest();</code></pre><h2 id="设置请求信息"><a href="#设置请求信息" class="headerlink" title="设置请求信息"></a>设置请求信息</h2><pre><code>xhr.open(method, url [, async]);</code></pre><ul><li>method: 请求类型，get 或 post</li><li>url：请求路径</li><li>async：true（异步）或 false（同步），默认为 true</li></ul><h2 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h2><pre><code>xhr.send(string);</code></pre><ul><li>string: 以 <strong>post</strong> 方式请求时，传递的请求体作为 send 方法的参数</li></ul><h2 id="接收响应（readyState）"><a href="#接收响应（readyState）" class="headerlink" title="接收响应（readyState）"></a>接收响应（readyState）</h2><p>发送异步请求之后，当请求在服务器中处理完成，返回的数据需要在页面中进行处理。</p><p>通过为 xhr 绑定 onreadystatechange 事件，判断请求是否完成，当请求完成并且响应状态码是 200 时，处理返回数据。</p><pre><code>xhr.onreadystatechange = function () {    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){        // 处理返回数据    }};</code></pre><p>上面的代码中，用到了 XMLHttpRequest 对象的三个属性：</p><ul><li><strong>onreadystatechange</strong>：存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。</li><li><strong>readyState</strong>：存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。<ul><li>0: 请求未初始化 </li><li>1: 服务器连接已建立 </li><li>2: 请求已接收 </li><li>3: 请求处理中 </li><li>4: 请求已完成，且响应已就绪 </li></ul></li><li><strong>status</strong>：响应状态码。200 : “OK”； 404 : 未找到页面</li></ul><h2 id="响应信息"><a href="#响应信息" class="headerlink" title="响应信息"></a>响应信息</h2><p>通过 XMLHttpRequest 对象的 responseText 或 responseXML 属性获取服务器返回的响应信息。</p><ul><li>responseText： 获得字符串形式的响应数据。 </li><li>responseXML： 获得 XML 形式的响应数据。 </li></ul><h2 id="get-请求和-post-请求实例"><a href="#get-请求和-post-请求实例" class="headerlink" title="get 请求和 post 请求实例"></a>get 请求和 post 请求实例</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p>get 请求通过 url 向服务器传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;/testAjax?username=admin&amp;password=123456&apos;);</span><br><span class="line">xhr.send();</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">        div.innerHTML += &apos;&lt;p&gt;&apos;+ xhr.responseText +&apos;&lt;/p&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="post"><a href="#post" class="headerlink" title="post"></a>post</h3><p>post 请求通过 send 方法的参数向服务器传递参数。</p><p>post 请求传递的参数在服务器中接收到的是请求体字符串，需要解析字符串之后才能使用。如果想像 HTML 表单那样 post 数据，需要调用 XMLHttpRequest 对象的 setRequestHeader 方法，设置请求头的 Content-type 属性的值，这样服务器就能直接通过参数名得到参数值了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;post&apos;, &apos;/testAjax&apos;);</span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">xhr.send(&apos;username=admin&amp;password=123456&apos;);</span><br><span class="line">xhr.onreadystatechange = function () &#123;</span><br><span class="line">    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">        div.innerHTML += &apos;&lt;p&gt;&apos;+ xhr.responseText +&apos;&lt;/p&gt;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IE-浏览器兼容性处理"><a href="#IE-浏览器兼容性处理" class="headerlink" title="IE 浏览器兼容性处理"></a>IE 浏览器兼容性处理</h2><p>IE 6 及更低版本 IE 浏览器不支持 XMLHttpRequest 对象，所以需要做兼容性处理。</p><ul><li><p>IE6 浏览器 ajax 核心对象：</p><pre><code>var xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</code></pre></li><li><p>更低版本 IE 浏览器 ajax 核心对象：</p><pre><code>var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></pre></li></ul><p>其他步骤与 XMLHttpRequest 方式相同。</p><p>ajax 兼容性处理方法：将获取 ajax 核心对象的代码封装到函数中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function getXHR() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        return new XMLHttpRequest();</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            //兼容IE6的方式</span><br><span class="line">            return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</span><br><span class="line">        &#125;catch (e)&#123;</span><br><span class="line">            //更老版本的ie</span><br><span class="line">            return new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原生ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>连续赋值与成员访问运算符优先级</title>
      <link href="/%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
      <url>/%E8%BF%9E%E7%BB%AD%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%88%90%E5%91%98%E8%AE%BF%E9%97%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>一道比较复杂的 JavaScript 的题，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a = &#123;n: 1&#125;;</span><br><span class="line">var b = a;</span><br><span class="line">a.x = a = &#123;n: 2&#125;;</span><br><span class="line"></span><br><span class="line">console.log(a.x, b.x);</span><br></pre></td></tr></table></figure><p>猜一下结果是什么？<br><a id="more"></a></p><p>分析一下上面的代码：</p><p>var a = {n: 1};<br>var b = a;</p><p>这两行代码很简单，创建了一个对象，假设叫做 OBJ1，OBJ1 中有一个属性 n，值为 1.<br>定义了两个变量 a 和 b，同时指向对象 OBJ1。</p><p>本题的难点在于下一行代码。</p><pre><code>a.x = a = {n: 2};</code></pre><p>这是连续赋值的代码。<br>在 JavaScript 中，JavaScript 解释器会从右到左去执行连续赋值的代码，比如 var a = b = 2; ，JavaScript 解释器会先执行 b = 2，然后执行 var a = b;</p><p>上面的代码，很容易被理解成先执行 a = {n: 2}, 即创建一个新的对象 OBJ2，将 a 重新指向 OBJ2，然后执行 a.x = a，即为 OBJ2 添加一个属性 x，并将属性 x 也指向 OBJ2。<br>这样的话，a.x 将得到对象 OBJ2，b.x 得到 undefined。然而，运行后发现，结果并不是如此。</p><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>运行后发现，本题的结果是：</p><pre><code>undefined Object</code></pre><p>这与刚才的分析结果正好相反。</p><p>这是因为，该语句中，<strong>成员访问运算符拥有最高的优先级</strong>。因此，该语句的执行顺序是：</p><pre><code>a.x = a = {n: 2};</code></pre><ul><li>先执行 a.x ，为对象 OBJ1 添加属性 x，但是不赋值</li><li>然后按照连续赋值的顺序，执行 a = {n: 2}，创建新的对象 OBJ2，OBJ2 拥有属性 n，值为 2，并将变量 a 重新指向 OBJ2。</li><li>最后执行 a.x = a，因为第一步中已经将表达式 a.x 解释过，指向对象 OBJ1 的属性 x，所以此时不再解释 a.x，而是直接将 a 的值赋给对象 OBJ1 的属性 x。</li></ul><p>此时，变量 a 指向对象 OBJ2，OBJ2 含有一个属性 n, 值为 2.<br>变量 b 仍旧指向对象 OBJ1，OBJ1 含有两个属性，属性 n 值为 1, 属性 x 指向对象 OBJ2。</p><p>这样，就可以理解本题为什么得到 undefined object 了。 a.x 会在 OBJ2 中寻找属性 x ，找不到则去原型链中寻找，如果一直找不到则返回 undefined。  b.x 得到 OBJ1 的属性 x 的值，即对象 OBJ2。</p><blockquote><p>注意：本题涉及到了两个知识点：一是连续赋值语句，二是成员访问运算符的优先级。</p></blockquote><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><style>    img{        border: 0;        margin: 0;        padding: 0;    }</style><p>下面是 JavaScript 中运算符的优先级，按照优先级的不同从高到底排列：</p><p><img src="/uploads/yunsuanfu/01.PNG" alt="image"><br><img src="/uploads/yunsuanfu/02.PNG" alt="image"><br><img src="/uploads/yunsuanfu/03.PNG" alt="image"><br><img src="/uploads/yunsuanfu/04.PNG" alt="image"><br><img src="/uploads/yunsuanfu/05.PNG" alt="image"></p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点运算符 </tag>
            
            <tag> 连续赋值 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端内容简介</title>
      <link href="/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/"/>
      <url>/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%86%85%E5%AE%B9%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>编写移动端页面与编写电脑版网页的方式有一些不同，本文将移动端页面的内容进行了总结，主要包括三个视口、物理像素与像素比、移动端事件等内容。</p><p>学习移动端过程中做的两个项目：音悦台 和 懒加载相册<br>GitHub地址：<a href="https://github.com/huajianduzhuo/mobile-project" target="_blank" rel="noopener">https://github.com/huajianduzhuo/mobile-project</a>。</p><a id="more"></a><h1 id="像素"><a href="#像素" class="headerlink" title="像素"></a>像素</h1><h2 id="屏幕相关概念"><a href="#屏幕相关概念" class="headerlink" title="屏幕相关概念"></a>屏幕相关概念</h2><p><strong>屏幕尺寸</strong></p><p>指屏幕的对角线的长度，单位是英寸，1英寸=2.54厘米。</p><blockquote><p>常见的屏幕尺寸有2.4、2.8、3.5、3.7、4.2、5.0、5.5、6.0等。</p></blockquote><p><strong>屏幕分辨率</strong></p><p>指在横纵向上的像素点数，单位是px，1px=1个像素点。<br>一般以 纵向像素 * 横向像素 来表示一个手机的分辨率。如 iphone6 的分辨率是 750*1334。（这里的1像素指的是物理设备的1个像素点）</p><p><strong>屏幕像素密度/像素密度/屏幕密度</strong></p><p>屏幕上每英寸可以显示的像素点的数量，单位是ppi，即“pixels per inch”的缩写。</p><blockquote><p>屏幕像素密度与屏幕尺寸和屏幕分辨率有关</p></blockquote><h2 id="像素-1"><a href="#像素-1" class="headerlink" title="像素"></a>像素</h2><p>移动端中的像素具有几种不同的概念，如物理像素、CSS像素、设备独立像素。</p><h3 id="物理像素-设备像素"><a href="#物理像素-设备像素" class="headerlink" title="物理像素/设备像素"></a>物理像素/设备像素</h3><p>　　手机分辨率（n x m）指的是手机横纵向上的像素点数，一个点（小方格）为一个物理像素，它是屏幕能显示的最小粒度。<br>　　设备像素也被称为物理像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。<br>　　任何设备的物理像素的数量都是固定的。</p><h3 id="CSS像素"><a href="#CSS像素" class="headerlink" title="CSS像素"></a>CSS像素</h3><p>　　CSS像素是一个抽象的单位，主要使用在浏览器上，用来精确的度量（确定）Web页面上的内容。它是为web开发者创造的，在css或者javascript中使用的一个抽象的层。<br>　　一般情况下，CSS像素被称为与设备无关的像素（device-independent像素），简称为“DIPs”。<br>　　在一个标准的显示密度下(普通屏)，一个CSS像素对应着一个设备像素。</p><blockquote><p>作为开发者，我们使用的每一个css和javascript定义的像素本质上代表的都是css像素，我们在开发过程中，并不在意一个css像素到底跨越了多少个设备像素。我们将这个依赖于屏幕特性和用户缩放程度的复杂计算交给了浏览器。</p></blockquote><h3 id="css像素与物理像素的关系"><a href="#css像素与物理像素的关系" class="headerlink" title="css像素与物理像素的关系"></a>css像素与物理像素的关系</h3><p>　　定义一个 width 为 200px 的元素，它占据了200个 css像素，但200个 css像素占据多少个物理像素取决于屏幕的特性（是否是高密度,即像素比）和用户的缩放行为。<br>　　在 iPhone6 的视网膜屏幕上，视网膜的像素密度是普通屏幕的两倍，这个元素就跨越了400个物理像素。如果用户放大，它将跨越更多的物理像素。</p><h3 id="设备独立像素"><a href="#设备独立像素" class="headerlink" title="设备独立像素"></a>设备独立像素</h3><p>　　设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。</p><h3 id="位图像素"><a href="#位图像素" class="headerlink" title="位图像素"></a>位图像素</h3><p>　　一个位图的像素是栅格图像(如：png, jpg, gif等)最小的数据单元。1个位图像素对应于1个物理像素，图片才能得到完美清晰的展示。</p><h2 id="像素比"><a href="#像素比" class="headerlink" title="像素比"></a>像素比</h2><p>设备物理像素和设备独立像素的比例。</p><pre><code>window.devicePixelRatio = 物理像素 / 设备独立像素</code></pre><h1 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h1><h2 id="布局视口"><a href="#布局视口" class="headerlink" title="布局视口"></a>布局视口</h2><p>布局视口（layout viewport）是指用于 CSS 布局的一块区域。</p><blockquote><p>在 PC 端，横向布局默认是根据初始包含块决定，如设置一个块级元素的宽度为 20%，则该元素的宽度为初始包含块的宽度的 20%。在移动端，由布局视口代替初始包含块的作用。</p></blockquote><p>　　布局视口的概念，在极大程度上帮助了桌面网站到移动设备上的转移。大部分手机浏览器的默认布局视口大小为 980px，默认情况下，布局视口占满手机浏览器屏幕，除非页面中有块级元素的宽度大于这个值，则该元素的宽度会占满屏幕，而布局视口的宽度则会小于屏幕的宽度（此处所说的宽度均指css像素宽度，物理像素由手机品牌决定，不会改变）。</p><p>　　可以通过 document.documentElement.clientWidth 来获取布局视口的大小。</p><h2 id="视觉视口"><a href="#视觉视口" class="headerlink" title="视觉视口"></a>视觉视口</h2><p>　　视觉视口（visual viewport）与设备屏幕一样宽，并且它的 css 像素的数量会随用户的缩放而改变。<br>　　visual viewport的宽度可以通过 window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。</p><blockquote><p>布局视口限制了页面css布局,视觉视口会决定用户能看到的区域。</p></blockquote><h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><p>　　大多数移动设备浏览器的布局视口的默认宽度为 980px，且默认情况下，这 980px 像素的大小会占满整个屏幕，这样会导致 CSS 像素和物理像素的大小差异过大，将PC端页面转移到移动端后，页面元素显示过小，需要用户手动缩放来调节，而这是我们不想看到的。<br>　　为了实现用户进入页面时，不需要缩放屏幕，就可以正常浏览页面，我们需要为移动设备专门开发网站。<br>　　由于布局视口的默认宽度主要是为了能够容纳PC端的网页设置的，对于专门为移动设备开发的网页，这个宽度并不是一个理想的宽度，所以一些浏览器厂商引入了理想视口。<br>　　<strong>理想视口是指页面的布局视口宽度与设备独立像素的值相等。</strong></p><p>实现理想视口的代码：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&gt;</code></pre><h1 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h1><p>　　缩放是指放大或缩小页面的行为。本质上讲，缩放是放大或缩小 1css 像素的大小的过程，当 css 像素与物理像素的大小比例改变时，用户看到的元素大小也会改变，但是元素css布局大小的值没变。<br>　　用户进行缩放操作时，布局视口的宽度不会改变，但是由于 css 像素的大小发生改变，会导致视觉视口所包含的 css 像素个数改变，所以缩放会改变视觉视口的尺寸。</p><h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;&quot; /&gt;</code></pre><p>移动端页面需要添加 name 属性为 viewport 的标签，该标签 content 属性内容如下</p><h2 id="content属性"><a href="#content属性" class="headerlink" title="content属性"></a>content属性</h2><p>content 属性的值可以包含如下内容：</p><ul><li>width [pixel_value | device-width] width<br>  – 直接去设置具体数值大部分的安卓手机是不支持的 但是IOS支持</li><li>initial-scale 初始缩放比例</li><li>user-scalable 是否允许缩放 （no||yes）,默认允许</li><li>minimum-scale 允许缩放的最小比例</li><li>maximum-scale 允许缩放的最大比例 </li><li>target-densitydpi<br>  – dpi_value 70–400 //每英寸像素点的个数<br>  – device-dpi 设备默认像素密度2<br>  – high-dpi 高像素密度<br>  – medium-dpi 中等像素密度<br>  – low-dpi 低像素密度<br>  – webkit内核不再支持了</li><li>height</li></ul><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,height=device-height,user-scalable=no,</span><br><span class="line">initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,target-densitydpi=device-dpi&quot; /&gt;</span><br></pre></td></tr></table></figure></p><h3 id="width"><a href="#width" class="headerlink" title="width"></a>width</h3><p>width 用来设置布局视口的大小。上面介绍过的理想视口，设置 width=device-width，会使布局视口的大小变成理想视口的大小（即独立设备像素代表的值）。</p><p>旋转（横竖屏切换）：<br>当用户旋转设备时，布局视口的宽度通常会发生改变。因为横竖屏时的理想视口尺寸不一样。但ios的safari很例外，基于性能的考虑它的布局视口不会做出改变。</p><h3 id="initial-scale"><a href="#initial-scale" class="headerlink" title="initial-scale"></a>initial-scale</h3><p>设置缩放，缩放根据理想视口的大小为基础来计算。设置 inital-scale=1 其实等同于只设置 width=device-width。</p><p>通过 initial-scale 设置的缩放，与用户的缩放行为不同。用户的缩放行为不会改变布局视口的大小，只改变视觉视口的大小。而通过 initial-scale 设置的缩放，会使布局视口的大小跟随着视觉视口一起改变。</p><h3 id="minimum-scale和maximum-scale"><a href="#minimum-scale和maximum-scale" class="headerlink" title="minimum-scale和maximum-scale"></a>minimum-scale和maximum-scale</h3><ul><li>minimum-scale 允许缩放的最小比例</li><li>maximum-scale 允许缩放的最大比例  </li></ul><p>不设置这两个值时，页面默认缩放比例范围为20%-500%，设置最大和最小比例后，页面可缩放比例能够扩大到10%-1000%。</p><p>安卓的 webkit 内核不支持这两个属性，默认缩放范围为25%-400%。<br>ie内核同样不支持。</p><h2 id="完美视口"><a href="#完美视口" class="headerlink" title="完美视口"></a>完美视口</h2><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,user-scalable=no&quot; /&gt;</code></pre><p>　　当 meta 标签中只设置 width=device-width 和 initial-scale=1.0 中的一个时，如果页面中存在过大的元素，有些浏览器会扩展布局视口的宽度来容纳这个元素。但是如果这两个属性都设置了，大部分浏览器则不会改变布局视口的大小。</p><blockquote><p>布局视口在 width 和 initial-scale 产生分歧时，会选择两个中布局视口较大的那一个。</p></blockquote><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="基础事件"><a href="#基础事件" class="headerlink" title="基础事件"></a>基础事件</h2><ul><li><strong>touchstart</strong><br>  手指触摸。相当于PC端页面的 mousedown 事件</li><li><strong>touchmove</strong><br>  手指移动。相当于PC端页面的 mousemove 事件</li><li><strong>touchend</strong><br>  手指移动。相当于PC端页面的 mouseup 事件</li></ul><h2 id="事件目标元素"><a href="#事件目标元素" class="headerlink" title="事件目标元素"></a>事件目标元素</h2><p>　　在PC端页面中，事件处理函数的第一个参数 event 就是事件对象，可以直接通过 event 对象获取事件的一些信息。在移动端页面中，同样可以使用 event 对象，但是由于在移动端，可能不止有一个手指事件，所以仅仅通过  event 对象，无法获取所有的事件信息。<br>　　event 对象提供了三个数组类型的属性，用于存储移动端的事件对象。</p><ul><li><strong>changedTouches</strong><br>  目标元素上触发了目标事件的手指事件对象列表</li><li><strong>targetTouches</strong><br>  目标元素上的所有手指事件对象列表</li><li><strong>touches</strong><br>  手机屏幕上的手指事件对象列表</li></ul><h1 id="多指事件"><a href="#多指事件" class="headerlink" title="多指事件"></a>多指事件</h1><h2 id="多指事件-1"><a href="#多指事件-1" class="headerlink" title="多指事件"></a>多指事件</h2><ul><li>gesturestart<br>  手指触碰当前元素，屏幕上有两个或者两个以上的手指<br>  注意：我们说的多指，指定是两个手指</li><li>gesturechange<br>  手指触碰当前元素，屏幕上有两个或者两个以上的手指位置在发生移动</li><li>gestureend<br>  在 gesturestart 后, 屏幕上只剩下两根以下（不包括两根）的手指</li></ul><blockquote><p>以上三个事件只有iPhone 6 以上才能用。</p></blockquote><h2 id="旋转（rotation）"><a href="#旋转（rotation）" class="headerlink" title="旋转（rotation）"></a>旋转（rotation）</h2><p>可以通过 event.rotation 属性获取多指事件时，目标元素上的手指旋转角度。一般只考虑0-90°。</p><h2 id="缩放（scale）"><a href="#缩放（scale）" class="headerlink" title="缩放（scale）"></a>缩放（scale）</h2><p>可以通过 event.scale 属性获取多指事件时，目标元素上的手指缩放比例。</p><h2 id="原声-JS-模拟多指事件"><a href="#原声-JS-模拟多指事件" class="headerlink" title="原声 JS 模拟多指事件"></a>原声 JS 模拟多指事件</h2><h3 id="模拟-gesturestart"><a href="#模拟-gesturestart" class="headerlink" title="模拟 gesturestart"></a>模拟 gesturestart</h3><p>手指触碰当前元素，<strong>屏幕上</strong>有两个或两个以上手指</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">box.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    var touch = event.touches;</span><br><span class="line">    <span class="keyword">if</span>(touch.length &gt;= 2)&#123;</span><br><span class="line">        // 相应多指事件</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将上面代码封装成函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> gesture(box, callback)&#123;</span><br><span class="line"></span><br><span class="line">    // 判断 gesturestart 的标识</span><br><span class="line">    var flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    box.addEventListener(<span class="string">'touchstart'</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">        var touch = event.touches;</span><br><span class="line">        <span class="keyword">if</span>(touch.length &gt;= 2)&#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">            // 相应多指事件</span><br><span class="line">            <span class="keyword">if</span>(callback &amp;&amp; callback[<span class="string">'start'</span>])&#123;</span><br><span class="line">                callback[<span class="string">'start'</span>]();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><h3 id="模拟-gesturechange"><a href="#模拟-gesturechange" class="headerlink" title="模拟 gesturechange"></a>模拟 gesturechange</h3><p>手指触碰当前元素，<strong>屏幕上</strong>有两个或两个以上手指位置在发生移动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">box.addEventListener(<span class="string">'touchmove'</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    var touch = event.touches;</span><br><span class="line">    <span class="keyword">if</span>(touch.length &gt;= 2)&#123;</span><br><span class="line">        // 相应多指事件</span><br><span class="line">        <span class="keyword">if</span>(callback &amp;&amp; callback[<span class="string">'change'</span>])&#123;</span><br><span class="line">            callback[<span class="string">'change'</span>]();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="模拟-gestureend"><a href="#模拟-gestureend" class="headerlink" title="模拟 gestureend"></a>模拟 gestureend</h3><p>在 gesturestart 后，屏幕上只剩下两根以下（不包括两根）的手指</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    box.addEventListener(<span class="string">'touchend'</span>, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">        var touch = event.touches;</span><br><span class="line">        <span class="keyword">if</span>(touch.length &lt; 2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                // 相应多指事件</span><br><span class="line">                <span class="keyword">if</span>(callback &amp;&amp; callback[<span class="string">'end'</span>])&#123;</span><br><span class="line">                    callback[<span class="string">'end'</span>]();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            // 重置标识</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125; // 对应 gesture 函数开始</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 移动端事件 </tag>
            
            <tag> 视口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS3自动旋转魔方</title>
      <link href="/CSS3%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E9%AD%94%E6%96%B9/"/>
      <url>/CSS3%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E9%AD%94%E6%96%B9/</url>
      
        <content type="html"><![CDATA[<p>分享一个使用 CSS 3 制作的自动旋转魔方。<br>GitHub地址：<a href="https://github.com/huajianduzhuo/CSS-3" target="_blank" rel="noopener">https://github.com/huajianduzhuo/CSS-3</a></p><a id="more"></a><iframe src="/uploads/magicSquare/magicSquare.html" style="width: 500px; height: 350px; border: 0;overflow: hidden;"></iframe><h2 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h2><p>盒子使用一个 div ，并为盒子开启 3D 效果。</p><pre><code>&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 210px;</span><br><span class="line">    height: 210px;</span><br><span class="line">    margin: 150px auto;</span><br><span class="line"></span><br><span class="line">    transform-style: preserve-3d; // 开启 3D</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六个面"><a href="#六个面" class="headerlink" title="六个面"></a>六个面</h2><p>魔方的六个面分别使用六个 div，为六个 div 设置在 3d 空间上的偏移：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"box"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"bottom"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"back"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"right"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"left"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">// 为六个面设置统一的宽高</span><br><span class="line">.box &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 210px;</span><br><span class="line">    height: 210px</span><br><span class="line">&#125;</span><br><span class="line">// 前面位置不变</span><br><span class="line">.box .front&#123;</span><br><span class="line">    background: red;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">&#125;</span><br><span class="line">// 左面向左平移一个宽度距离，并沿右侧向内旋转 90度</span><br><span class="line">.box .left&#123;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: -210px;</span><br><span class="line">    background: blue;</span><br><span class="line">    transform-origin: right center;</span><br><span class="line">    transform: rotateY(-90deg);</span><br><span class="line">&#125;</span><br><span class="line">// 右面向右平移一个宽度距离，并沿左侧向内旋转 90度</span><br><span class="line">.box .right&#123;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 210px;</span><br><span class="line">    background: yellow;</span><br><span class="line">    transform-origin: left center;</span><br><span class="line">    transform: rotateY(90deg);</span><br><span class="line">&#125;</span><br><span class="line">// 后面沿 Z轴向后平移一个宽度距离</span><br><span class="line">.box .back&#123;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    background: green;</span><br><span class="line">    transform: translateZ(-210px) rotateY(180deg);</span><br><span class="line">&#125;</span><br><span class="line">// 上面向上平移一个宽度距离，并沿下侧向内旋转 90度</span><br><span class="line">.box .top&#123;</span><br><span class="line">    top: -210px;</span><br><span class="line">    left: 0;</span><br><span class="line">    background: sandybrown;</span><br><span class="line">    transform-origin: center bottom;</span><br><span class="line">    transform: rotateX(90deg);</span><br><span class="line">&#125;</span><br><span class="line">// 底面向下平移一个宽度距离，并沿上侧向内旋转 90度</span><br><span class="line">.box .bottom&#123;</span><br><span class="line">    top: 210px;</span><br><span class="line">    left: 0;</span><br><span class="line">    background: pink;</span><br><span class="line">    transform-origin: center top;</span><br><span class="line">    transform: rotateX(-90deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="魔方效果"><a href="#魔方效果" class="headerlink" title="魔方效果"></a>魔方效果</h2><p>为每个面添加 9 个子 div，设置成魔方的样式。</p><p>以一个面为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"front"</span>&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box &gt; div &gt; div&#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    width: 70px;</span><br><span class="line">    height: 70px;</span><br><span class="line">    border: 1px solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动旋转动画"><a href="#自动旋转动画" class="headerlink" title="自动旋转动画"></a>自动旋转动画</h2><p>经过上面的步骤，3D 的魔方效果已经实现。下面为盒子添加动画，使魔方可以自动旋转。</p><blockquote><p>注意：魔方旋转时应以盒子的中心为中心点，盒子中心点在 z轴上有偏移量。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">    animation-name: spin;</span><br><span class="line">    animation-duration: 10s;</span><br><span class="line">    animation-timing-function: linear;</span><br><span class="line">    animation-iteration-count: infinite;</span><br><span class="line">    animation-delay: 1s;</span><br><span class="line"></span><br><span class="line">    transform-style: preserve-3d;</span><br><span class="line">    transform-origin: center center -105px;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes spin &#123;</span><br><span class="line">    from&#123;</span><br><span class="line">        transform: rotateY(0deg) rotateX(0deg);</span><br><span class="line">    &#125;</span><br><span class="line">    to&#123;</span><br><span class="line">        transform: rotateY(360deg) rotateX(720deg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
            <tag> 3D </tag>
            
            <tag> 魔方 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端三种适配介绍</title>
      <link href="/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%89%E7%A7%8D%E9%80%82%E9%85%8D%E4%BB%8B%E7%BB%8D/"/>
      <url>/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%89%E7%A7%8D%E9%80%82%E9%85%8D%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>　　编写移动端页面时，为了容纳为桌面浏览器设计的页面，默认的布局视口大小远远大于屏幕宽度（默认布局视口大小一般为980px），此时屏幕会缩放，导致字体很小，不适合用户浏览。为了得到更好的使用效果，我们会使用理想视口，使布局视口的大小等于设备独立像素的值，这样用户进入页面时，则无需缩放。</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;/&gt;</code></pre><p>　　但是，由于每种手机分辨率以及像素比不同，设置理想视口后，会导致同一页面在不同手机上的布局视口大小不同，此时，若直接使用 px 为单位进行页面布局，在不同手机打开页面容易发生布局混乱。<br>　　针对这一问题，我们可以使用移动端适配来解决。<br><a id="more"></a></p><h1 id="rem适配"><a href="#rem适配" class="headerlink" title="rem适配"></a>rem适配</h1><p>使用 rem 为单位进行布局时，1rem 等同于 html 节点中 font-size 的大小，默认为 16px。</p><blockquote><p>如下代码中，为 box 设置宽度为 10rem，则 box 的宽度会被计算为 160px。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#box&#123;</span></span><br><span class="line">    width: 10rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rem适配的原理"><a href="#rem适配的原理" class="headerlink" title="rem适配的原理"></a>rem适配的原理</h2><p>　　将 html 元素的 font-size 值设置为与设备独立像素（device-width）相关的值，如将 font-size 的大小设置为 device-width，则 1rem 的大小即为 device-width 的值，布局时使用 rem 为单位进行布局。<br>　　如将一个 div 的宽度设置为 0.5rem，则无论使用何种手机打开，该 div 的宽度都将是该手机设备独立像素的值的一半。而不会发生布局混乱的问题。</p><blockquote><p>通常情况下，将 1rem 的值设置为 device-width / 16 或 device-width / 10。</p></blockquote><h2 id="rem适配示例代码"><a href="#rem适配示例代码" class="headerlink" title="rem适配示例代码"></a>rem适配示例代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    // 设置理想视口后，布局视口的宽度即为设备独立像素的值</span><br><span class="line">    var width = document.documentElement.clientWidth;</span><br><span class="line">    var styleH = document.createElement(<span class="string">'style'</span>);</span><br><span class="line">    // 将 1rem 设置为 设备独立像素的值的 1/16</span><br><span class="line">    styleH.innerHTML = <span class="string">'html&#123;font-size: '</span>+ width/16 +<span class="string">'px !important;&#125;'</span>;</span><br><span class="line">    document.head.appendChild(styleH);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="viewport适配"><a href="#viewport适配" class="headerlink" title="viewport适配"></a>viewport适配</h1><h2 id="viewport适配原理"><a href="#viewport适配原理" class="headerlink" title="viewport适配原理"></a>viewport适配原理</h2><p>　　通过动态的改变屏幕的缩放比例（meta 标签中的 initial-scale 的值），使所有手机的布局视口的大小固定，此时布局时，只要使用 CSS 的像素值，不同手机将展示出相同的效果。<br>　　缩放比例大小为设备独立像素的值与目标布局大小之比。</p><h2 id="viewport适配示例代码"><a href="#viewport适配示例代码" class="headerlink" title="viewport适配示例代码"></a>viewport适配示例代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var width = document.documentElement.clientWidth;</span><br><span class="line">    var targetwidth = 320; // 目标布局视口大小</span><br><span class="line">    var scale = width / targetwidth;</span><br><span class="line">    var meta = document.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line">    meta.setAttribute(<span class="string">'content'</span>,<span class="string">'initial-scale='</span> + scale);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h1 id="1物理像素适配"><a href="#1物理像素适配" class="headerlink" title="1物理像素适配"></a>1物理像素适配</h1><p>　　使用 1 物理像素适配的目的，是为了在设置边框时，能够设置边框的大小为 1 物理像素的大小。但是，由于现在手机屏幕的像素比普遍大于 1，1CSS 像素的大小通常大于 1物理像素的大小，导致我们使用CSS单位时，无法设置边框宽度为 1物理像素。</p><blockquote><p>注意：边框宽度无法设置为小数值。</p></blockquote><p>　　为了解决这个问题，可以使用 1物理像素适配。</p><h2 id="1物理像素适配的原理"><a href="#1物理像素适配的原理" class="headerlink" title="1物理像素适配的原理"></a>1物理像素适配的原理</h2><p>　　1 物理像素适配结合了 rem 适配和 viewport 适配的概念。通过动态的改变屏幕的缩放比例，使得 1CSS 像素的大小，等于 1物理像素的大小，此时布局视口的大小等于屏幕分辨率，然后设置 html 标签的 font-size 的值为屏幕分辨率的值，即使用 rem 适配。这样，可以让所有的布局元素使用 rem 为单位进行布局，边框使用 px 为单位。</p><blockquote><p>initial-scale 的值等于 1/dpr(屏幕像素比)，则 1CSS像素 等于 1物理像素。</p></blockquote><h2 id="1物理像素适配的示例代码"><a href="#1物理像素适配的示例代码" class="headerlink" title="1物理像素适配的示例代码"></a>1物理像素适配的示例代码</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var scale = 1 / window.devicePixelRatio;</span><br><span class="line">var meta = document.querySelector(<span class="string">'meta[name="viewport"]'</span>);</span><br><span class="line">meta.setAttribute(<span class="string">'content'</span>,<span class="string">'initial-scale='</span> + scale);</span><br><span class="line"></span><br><span class="line">var width = document.documentElement.clientWidth / 16;</span><br><span class="line">var styleW = document.createElement(<span class="string">'style'</span>);</span><br><span class="line">styleW.innerHTML = <span class="string">'html&#123;font-size: '</span>+ width +<span class="string">'px;&#125;'</span>;</span><br><span class="line">document.head.appendChild(styleW);</span><br></pre></td></tr></table></figure><h1 id="rem适配和viewport适配对比"><a href="#rem适配和viewport适配对比" class="headerlink" title="rem适配和viewport适配对比"></a>rem适配和viewport适配对比</h1><p><strong>rem适配</strong></p><ul><li>优点<ol><li>可以使用理想标签</li><li>可以实现等比缩放</li></ol></li><li>缺点<br>  使用 rem 单位需要进行换算</li></ul><p><strong>viewport适配</strong></p><ul><li>优点<br>  避免复杂的计算，可以直接使用 UI 的标准像素值</li><li>缺点<ol><li>不能使用理想视口</li><li>由于进行了缩放，图片失真情况严重</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 移动端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rem适配 </tag>
            
            <tag> viewport适配 </tag>
            
            <tag> 1px适配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用jquery做贪吃蛇</title>
      <link href="/%E4%BD%BF%E7%94%A8jquery%E5%81%9A%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/%E4%BD%BF%E7%94%A8jquery%E5%81%9A%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<p>下面是我用 HTML4 + CSS2 + jquery 完成的“贪吃蛇”小游戏。<br>项目 github 地址：<a href="https://github.com/huajianduzhuo/TanChiShe" target="_blank" rel="noopener">https://github.com/huajianduzhuo/TanChiShe</a></p><a id="more"></a><p>方向：上下左右 或 wasd<br>暂停/继续：空格键</p><iframe style="width:700px; height:600px; border: 0; " src="http://mengyujing.com/TanChiShe/index.html"></iframe>]]></content>
      
      
      <categories>
          
          <category> 小游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> 贪吃蛇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用javascript做五子棋</title>
      <link href="/%E4%BD%BF%E7%94%A8javascript%E5%81%9A%E4%BA%94%E5%AD%90%E6%A3%8B/"/>
      <url>/%E4%BD%BF%E7%94%A8javascript%E5%81%9A%E4%BA%94%E5%AD%90%E6%A3%8B/</url>
      
        <content type="html"><![CDATA[<p>下面是我用 HTML4 + CSS2 + javascript 完成的“五子棋”小游戏。<br>项目 github 地址：<a href="https://github.com/huajianduzhuo/wuZiQi" target="_blank" rel="noopener">https://github.com/huajianduzhuo/wuZiQi</a></p><a id="more"></a><iframe style="width:700px; height:600px; border: 0; " src="/uploads/wuZiQi/wuZiQi.html"></iframe>]]></content>
      
      
      <categories>
          
          <category> 小游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 五子棋 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用CSS3画青蛙</title>
      <link href="/%E4%BD%BF%E7%94%A8CSS3%E7%94%BB%E9%9D%92%E8%9B%99/"/>
      <url>/%E4%BD%BF%E7%94%A8CSS3%E7%94%BB%E9%9D%92%E8%9B%99/</url>
      
        <content type="html"><![CDATA[<p>CSS3 提供了很多强大的新特性，我们可以使用 CSS3 做出很多漂亮的图形或动画，下面介绍我使用 CSS3 画青蛙的方法。先上最终效果：<br><a id="more"></a></p><iframe style=" width: 210px; height: 260px; padding-top:40px; border: 0; float:left;" src="/uploads/frog/frog.html"></iframe><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>该青蛙完全使用 div + CSS3 构造，下面是青蛙大体的 HTML 结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 青蛙整体结构 start --&gt;</span><br><span class="line">    &lt;div class=<span class="string">"frog"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"eye"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"face"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"body"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"leg"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;!-- 青蛙整体结构 end --&gt;</span><br></pre></td></tr></table></figure><p><strong>整体部分CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.frog&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 170px;</span><br><span class="line">    height: 200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h1><p><strong>眼睛部分HTML结构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"eye"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"left_eye"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"eye_ball"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"eye_ball_white"</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"eye_ball_black"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"right_eye"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"eye_ball"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"eye_ball_white"</span>&gt;&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"eye_ball_black"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>眼睛部分CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">.eye&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    z-index: 200;</span><br><span class="line">    width: 89px;</span><br><span class="line">    height: 47px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">.left_eye, .right_eye&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 40px;</span><br><span class="line">    height: 47px;</span><br><span class="line">    border: 3px solid;</span><br><span class="line">    background: <span class="comment">#ffffff;</span></span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line">.left_eye&#123;</span><br><span class="line">    border-radius: 27px 27px 28px 28px;</span><br><span class="line">&#125;</span><br><span class="line">.right_eye&#123;</span><br><span class="line">    margin-left: -3px;</span><br><span class="line">    border-radius: 27px 25px 25px 28px;</span><br><span class="line">&#125;</span><br><span class="line">.eye_ball&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: -3px;</span><br><span class="line">    left: 6px;</span><br><span class="line">    width: 24px;</span><br><span class="line">    height: 33px;</span><br><span class="line">    border: 2px solid;</span><br><span class="line">    background: <span class="comment">#f9440a;</span></span><br><span class="line">    border-radius: 18px 20px 25px 20px;</span><br><span class="line">&#125;</span><br><span class="line">.eye_ball_black&#123;</span><br><span class="line">    width: 7px;</span><br><span class="line">    height: 15px;</span><br><span class="line">    background: <span class="comment">#2f0305;</span></span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    margin: 8px auto;</span><br><span class="line">&#125;</span><br><span class="line">.eye_ball_white&#123;</span><br><span class="line">    <span class="built_in">float</span>: left;</span><br><span class="line">    margin-top: 12px;</span><br><span class="line">    margin-left: -1px;</span><br><span class="line">    width: 10px;</span><br><span class="line">    height: 6px;</span><br><span class="line">    background: <span class="comment">#fff;</span></span><br><span class="line">    border: 1px solid;</span><br><span class="line">    border-radius: 8px 7px 8px 5px;</span><br><span class="line">    transform: skew(0, -15deg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="脸部"><a href="#脸部" class="headerlink" title="脸部"></a>脸部</h1><p><strong>脸部HTML结构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"face"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"nose_left"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"nose_right"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"mouse"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"mouse_top"</span>&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"mouse_bottom"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"mouse_left_black"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"mouse_left_pink"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"mouse_right_black"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"mouse_right_pink"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>脸部CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">.face&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: -15px;</span><br><span class="line">    z-index: 100;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 60px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    border: 3px solid;</span><br><span class="line">    background: <span class="comment">#09b31a;</span></span><br><span class="line">&#125;</span><br><span class="line">.nose_left, .nose_right&#123;</span><br><span class="line">    width: 2px;</span><br><span class="line">    height: 3px;</span><br><span class="line">    background: <span class="comment">#000;</span></span><br><span class="line">&#125;</span><br><span class="line">.nose_left&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 24px;</span><br><span class="line">    left: 47px;</span><br><span class="line">&#125;</span><br><span class="line">.nose_right&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 23px;</span><br><span class="line">    left: 54px;</span><br><span class="line">&#125;</span><br><span class="line">.mouse&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 58px;</span><br><span class="line">    height: 35px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    margin-top: 28px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.mouse_top&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 19px;</span><br><span class="line">    left: -14px;</span><br><span class="line">    z-index: 200;</span><br><span class="line">    height: 80px;</span><br><span class="line">    width: 80px;</span><br><span class="line">    border-bottom: 2px solid;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: <span class="comment">#09b31a;</span></span><br><span class="line">&#125;</span><br><span class="line">.mouse_bottom&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0px;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    height: 54px;</span><br><span class="line">    width: 54px;</span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    background: <span class="comment">#f70e08;</span></span><br><span class="line">&#125;</span><br><span class="line">.mouse_left_black&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 19px;</span><br><span class="line">    top:30px;</span><br><span class="line">    width: 4px;</span><br><span class="line">    height: 9px;</span><br><span class="line">    background: <span class="comment">#000;</span></span><br><span class="line">    transform: skew(-30deg);</span><br><span class="line">    z-index: 300;</span><br><span class="line">    border-radius: 5px 15px 10px 12px;</span><br><span class="line">&#125;</span><br><span class="line">.mouse_left_pink&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 8px;</span><br><span class="line">    top:27px;</span><br><span class="line">    width: 15px;</span><br><span class="line">    height: 11px;</span><br><span class="line">    background: radial-gradient(<span class="comment">#fd91b6 40%, white 100%);</span></span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    transform: rotate(-20deg);</span><br><span class="line">    z-index: 350;</span><br><span class="line">&#125;</span><br><span class="line">.mouse_right_black&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 21px;</span><br><span class="line">    top: 27px;</span><br><span class="line">    width: 2px;</span><br><span class="line">    height: 6px;</span><br><span class="line">    background: <span class="comment">#000;</span></span><br><span class="line">    transform: skew(40deg);</span><br><span class="line">    z-index: 300;</span><br><span class="line">    border-radius: 10px 12px 5px 15px;</span><br><span class="line">&#125;</span><br><span class="line">.mouse_right_pink&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 7px;</span><br><span class="line">    top: 21px;</span><br><span class="line">    width: 15px;</span><br><span class="line">    height: 10px;</span><br><span class="line">    background: radial-gradient(<span class="comment">#fd91b6 40%, white 100%);</span></span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    transform: rotate(-20deg);</span><br><span class="line">    z-index: 350;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="身体"><a href="#身体" class="headerlink" title="身体"></a>身体</h1><p><strong>身体HTML结构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"body"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_left1"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_left2"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_right1"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_right2"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_center_top"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"body_center"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>身体CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">.body&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: -24px;</span><br><span class="line">    z-index: 80;</span><br><span class="line">    width: 60px;</span><br><span class="line">    height: 55px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-bottom: 0px;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.body .body_center_top&#123;</span><br><span class="line">    width: 25px;</span><br><span class="line">    height: 16px;</span><br><span class="line">    margin: 12px auto;</span><br><span class="line">    margin-bottom: 0;</span><br><span class="line">    border: 2px solid;</span><br><span class="line">    background: <span class="comment">#ffffff;</span></span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.body .body_center&#123;</span><br><span class="line">    width: 25px;</span><br><span class="line">    height: 56px;</span><br><span class="line">    margin: -8px auto;</span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-top: 0;</span><br><span class="line">    background: <span class="comment">#ffffff;</span></span><br><span class="line">&#125;</span><br><span class="line">.body_left1, .body_left2 &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: -9px;</span><br><span class="line">    width: 19px;</span><br><span class="line">    height: 9px;</span><br><span class="line">    border-radius: 40%;</span><br><span class="line">    background: <span class="comment">#00a26d;</span></span><br><span class="line">    border: 1px solid <span class="comment">#0a9b33;</span></span><br><span class="line">    transform: rotate(-20deg);</span><br><span class="line">&#125;</span><br><span class="line">.body_left1&#123;</span><br><span class="line">    top: 20px;</span><br><span class="line">&#125;</span><br><span class="line">.body_left2&#123;</span><br><span class="line">    top: 36px;</span><br><span class="line">&#125;</span><br><span class="line">.body_right1, .body_right2 &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: -9px;</span><br><span class="line">    width: 19px;</span><br><span class="line">    height: 8px;</span><br><span class="line">    border-radius: 10px 4px 4px 6px;</span><br><span class="line">    background: <span class="comment">#00a26d;</span></span><br><span class="line">    border: 1px solid <span class="comment">#0a9b33;</span></span><br><span class="line">    transform: rotate(-10deg);</span><br><span class="line">&#125;</span><br><span class="line">.body_right1&#123;</span><br><span class="line">    top: 15px;</span><br><span class="line">&#125;</span><br><span class="line">.body_right2&#123;</span><br><span class="line">    top: 30px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="前脚"><a href="#前脚" class="headerlink" title="前脚"></a>前脚</h1><p><strong>前脚HTML结构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"front_foot"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_padding1"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_padding2"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_left1"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_left2"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_left3"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_right1"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_right2"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"front_foot_right3"</span>&gt;</span><br><span class="line">        &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"front_foot_cover"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>前脚CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">.front_foot&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: -24px;</span><br><span class="line">    z-index: 80;</span><br><span class="line">    width: 64px;</span><br><span class="line">    height: 18px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">.front_foot &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 5px;</span><br><span class="line">    height: 15px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border-left: 2px solid;</span><br><span class="line">    border-right: 2px solid;</span><br><span class="line">&#125;</span><br><span class="line">.front_foot &gt; div &gt; div:first-child&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border: 2px solid;</span><br><span class="line">    width: 10px;</span><br><span class="line">    height: 5px;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    bottom: -4px;</span><br><span class="line">    left: -5px;</span><br><span class="line">&#125;</span><br><span class="line">.front_foot &gt; div .front_foot_cover&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 5px;</span><br><span class="line">    height: 16px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.front_foot_left1&#123;</span><br><span class="line">    transform-origin: 2px 0;</span><br><span class="line">    transform: rotate(50deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot_left2&#123;</span><br><span class="line">    top: 4px;</span><br><span class="line">    left: 5px;</span><br><span class="line">    transform-origin: 2px 0;</span><br><span class="line">    transform: rotate(10deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot_left3&#123;</span><br><span class="line">    top: -1px;</span><br><span class="line">    left: 10px;</span><br><span class="line">    transform-origin: right 0;</span><br><span class="line">    transform: rotate(-50deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot_right1&#123;</span><br><span class="line">    top: -1px;</span><br><span class="line">    right: 10px;</span><br><span class="line">    transform-origin: left 0;</span><br><span class="line">    transform: rotate(45deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot_right2&#123;</span><br><span class="line">    top: 5px;</span><br><span class="line">    right:5px;</span><br><span class="line">    transform-origin: left 0;</span><br><span class="line">    transform: rotate(-15deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot_right3&#123;</span><br><span class="line">    right: 1px;</span><br><span class="line">    top: -1px;</span><br><span class="line">    transform-origin: right 0;</span><br><span class="line">    transform: rotate(-60deg);</span><br><span class="line">&#125;</span><br><span class="line">.front_foot .front_foot_padding1, .front_foot .front_foot_padding2&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    width: 20px;</span><br><span class="line">    height: 5px;</span><br><span class="line">    border: 0;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.front_foot .front_foot_padding2&#123;</span><br><span class="line">    right: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后腿"><a href="#后腿" class="headerlink" title="后腿"></a>后腿</h1><p><strong>后腿HTML结构</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=<span class="string">"leg"</span>&gt;</span><br><span class="line">    &lt;div class=<span class="string">"big_leg_left"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"big_leg_left_inner1"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"big_leg_left_inner2"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"big_leg_right"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"big_leg_right_inner1"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"big_leg_right_inner2"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"small_leg_left"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_left1"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_left2"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_left3"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div class=<span class="string">"small_leg_right"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_right1"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_right2"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div class=<span class="string">"back_foot_right3"</span>&gt;</span><br><span class="line">            &lt;div&gt;&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>后腿CSS样式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line">.leg&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    top: -75px;</span><br><span class="line">    z-index: 60;</span><br><span class="line">    width: 185px;</span><br><span class="line">    height: 85px;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left, .big_leg_right&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    width: 48px;</span><br><span class="line">    height: 48px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left&#123;</span><br><span class="line">    left: 18px;</span><br><span class="line">    transform: skew(20deg);</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_right&#123;</span><br><span class="line">    right: 31px;</span><br><span class="line">    transform: skew(-20deg);</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left .big_leg_left_inner1, .big_leg_left .big_leg_left_inner2, .big_leg_right .big_leg_right_inner1, .big_leg_right .big_leg_right_inner2&#123;</span><br><span class="line">    width: 26px;</span><br><span class="line">    height: 13px;</span><br><span class="line">    border-radius: 13px 13px 0 0;</span><br><span class="line">    background: <span class="comment">#00a26d;</span></span><br><span class="line">    border: 1px solid <span class="comment">#0a9b33;</span></span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left .big_leg_left_inner1&#123;</span><br><span class="line">    transform: rotate(10deg);</span><br><span class="line">    margin-left: -3px;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left .big_leg_left_inner1 &gt; div&#123;</span><br><span class="line">    width: 26px;</span><br><span class="line">    height: 13px;</span><br><span class="line">    border-radius: 13px 13px 0 0;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">    margin-left: 2px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left .big_leg_left_inner2&#123;</span><br><span class="line">    transform: rotate(-20deg);</span><br><span class="line">    margin-top: 7px;</span><br><span class="line">    margin-left: -12px;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_left .big_leg_left_inner2 &gt; div&#123;</span><br><span class="line">    width: 26px;</span><br><span class="line">    height: 13px;</span><br><span class="line">    border-radius: 13px 13px 0 0;</span><br><span class="line">    margin-top: 12px;</span><br><span class="line">    margin-left: 2px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.big_leg_right .big_leg_right_inner1&#123;</span><br><span class="line">    transform: rotate(-50deg);</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: 10px;</span><br><span class="line">    top: -4px;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_right .big_leg_right_inner1 &gt; div&#123;</span><br><span class="line">    width: 40px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    border-radius: 20px 20px 0 0;</span><br><span class="line">    margin-top: 12px;</span><br><span class="line">    margin-left: -11px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.big_leg_right .big_leg_right_inner2&#123;</span><br><span class="line">    transform: rotate(-20deg);</span><br><span class="line">    position: absolute;</span><br><span class="line">    right: -10px;</span><br><span class="line">    top: 10px;</span><br><span class="line">&#125;</span><br><span class="line">.big_leg_right .big_leg_right_inner2 &gt; div&#123;</span><br><span class="line">    width: 40px;</span><br><span class="line">    height: 20px;</span><br><span class="line">    border-radius: 20px 20px 0 0;</span><br><span class="line">    margin-top: 12px;</span><br><span class="line">    margin-left: -11px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left, .small_leg_right&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 48px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border-left: 2px solid;</span><br><span class="line">    border-right: 2px solid;</span><br><span class="line">    width: 12px;</span><br><span class="line">    height: 18px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left&#123;</span><br><span class="line">    left: 34px;</span><br><span class="line">    transform: skew(-47deg);</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right&#123;</span><br><span class="line">    right: 47px;</span><br><span class="line">    transform: skew(47deg);</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: -7px;</span><br><span class="line">    width: 3px;</span><br><span class="line">    height: 8px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border-left: 2px solid;</span><br><span class="line">    border-right: 2px solid;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left &gt; div &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: -6px;</span><br><span class="line">    left: -6px;</span><br><span class="line">    width: 10px;</span><br><span class="line">    height: 5px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-top: 0;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left .back_foot_left1&#123;</span><br><span class="line">    left: -3px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left .back_foot_left2&#123;</span><br><span class="line">    left: 2px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_left .back_foot_left3&#123;</span><br><span class="line">    left: 7px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: -7px;</span><br><span class="line">    width: 3px;</span><br><span class="line">    height: 8px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border-left: 2px solid;</span><br><span class="line">    border-right: 2px solid;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right &gt; div &gt; div&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: -5px;</span><br><span class="line">    right: -7px;</span><br><span class="line">    width: 10px;</span><br><span class="line">    height: 5px;</span><br><span class="line">    background: <span class="comment">#20c826;</span></span><br><span class="line">    border: 2px solid;</span><br><span class="line">    border-top: 0;</span><br><span class="line">    border-radius: 50%;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right .back_foot_right1&#123;</span><br><span class="line">    right: -2px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right .back_foot_right2&#123;</span><br><span class="line">    right: 2px;</span><br><span class="line">&#125;</span><br><span class="line">.small_leg_right .back_foot_right3&#123;</span><br><span class="line">    right: 7px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>等高布局</title>
      <link href="/%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80/"/>
      <url>/%E7%AD%89%E9%AB%98%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>多列在一行时，不指定高度，高度默认为内容高度，要使多列高度一致，需要为每列添加以下样式，并且为父元素设置 <strong>overflow:hidden</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">padding-bottom: 10000px;</span><br><span class="line">margin-bottom: -10000px;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 等高布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>圣杯布局和双飞翼布局</title>
      <link href="/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/"/>
      <url>/%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E5%92%8C%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<p>圣杯布局和双飞翼布局都属于三列布局，实现两边宽度固定，中间宽度自适应的效果。</p><a id="more"></a><p>布局实现效果：</p><ul><li>具有header和footer，中间为内容区content</li><li>内容区为三列布局：left、middle、right</li><li>三列布局中，先加载middle内容</li></ul><!--more--><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;圣杯布局&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            /* body最小宽度 = left * 2 + right */</span><br><span class="line">            min-width: 600px;</span><br><span class="line">        &#125;</span><br><span class="line">        #header,#footer&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background: grey;</span><br><span class="line">        &#125;</span><br><span class="line">        #content&#123;</span><br><span class="line">            /* 因为三列布局中，三列都设置浮动，所以开启BFC，解决高度塌陷 */</span><br><span class="line">            overflow: hidden; </span><br><span class="line">            /* 圣杯布局与双飞翼布局区别 </span><br><span class="line">               圣杯布局使用 padding 使left和right显示在middle两侧，且不遮挡middle */</span><br><span class="line">            padding: 0 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        #middle&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        #left,#right&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        #left&#123;</span><br><span class="line">            /* 使left位于middle左侧 */</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            /* 使left不遮挡middle */</span><br><span class="line">            position: relative;</span><br><span class="line">            left: -200px;</span><br><span class="line">        &#125;</span><br><span class="line">        #right&#123;</span><br><span class="line">            /* 使right位于middle右侧 */</span><br><span class="line">            margin-left: -200px;</span><br><span class="line">            /* 使right不遮挡middle */</span><br><span class="line">            position: relative;</span><br><span class="line">            left: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;header&quot;&gt;</span><br><span class="line">        header</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;middle&quot;&gt;</span><br><span class="line">            middle</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;left&quot;&gt;</span><br><span class="line">            left</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;div id=&quot;right&quot;&gt;</span><br><span class="line">            right</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">        footer</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;双飞翼布局&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        * &#123;</span><br><span class="line">            margin: 0;</span><br><span class="line">            padding: 0;</span><br><span class="line">        &#125;</span><br><span class="line">        body&#123;</span><br><span class="line">            min-width: 600px;</span><br><span class="line">        &#125;</span><br><span class="line">        #header,#footer&#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 50px;</span><br><span class="line">            background: grey;</span><br><span class="line">        &#125;</span><br><span class="line">        #content&#123;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line">        #content_inner&#123;</span><br><span class="line">            /* 圣杯布局和双飞翼布局区别</span><br><span class="line">               双飞翼布局在content内添加一个大div，为它设置margin */</span><br><span class="line">            margin: 0 200px;</span><br><span class="line">        &#125;</span><br><span class="line">        #middle&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: green;</span><br><span class="line">        &#125;</span><br><span class="line">        #left,#right&#123;</span><br><span class="line">            float: left;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        #left&#123;</span><br><span class="line">            margin-left: -100%;</span><br><span class="line">            position: relative;</span><br><span class="line">            left: -200px;</span><br><span class="line">        &#125;</span><br><span class="line">        #right&#123;</span><br><span class="line">            margin-left: -200px;</span><br><span class="line">            position: relative;</span><br><span class="line">            left: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=&quot;header&quot;&gt;</span><br><span class="line">        header</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;content&quot;&gt;</span><br><span class="line">        &lt;div id=&quot;content_inner&quot;&gt;</span><br><span class="line">            &lt;div id=&quot;middle&quot;&gt;</span><br><span class="line">                middle</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;left&quot;&gt;</span><br><span class="line">                left</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div id=&quot;right&quot;&gt;</span><br><span class="line">                right</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;div id=&quot;footer&quot;&gt;</span><br><span class="line">        footer</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="圣杯布局和双飞翼布局比较"><a href="#圣杯布局和双飞翼布局比较" class="headerlink" title="圣杯布局和双飞翼布局比较"></a>圣杯布局和双飞翼布局比较</h2><ol><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相似之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处，在于如何处理中间主列的位置：<ul><li>圣杯布局是利用父容器的左、右<strong>内边距</strong>+定位</li><li>双飞翼布局是把主列嵌套在div后利用主列的左、右<strong>外边距</strong>+定位</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 圣杯布局 </tag>
            
            <tag> 双飞翼布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS定位</title>
      <link href="/CSS%E5%AE%9A%E4%BD%8D/"/>
      <url>/CSS%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍CSS中的定位以及初始包含块的概念。</p><a id="more"></a><h2 id="定位（position）"><a href="#定位（position）" class="headerlink" title="定位（position）"></a>定位（position）</h2><p>CSS定位 position 属性有四个值，分别是</p><ul><li>static：默认值，不开启定位</li><li><strong>relative：相对定位</strong><ul><li>定位偏移量相对于元素自身在文档流中的位置，相对定位不脱离文档流。</li></ul></li><li><strong>absolute：绝对定位</strong><ul><li>有开启了定位的祖先元素，则定位偏移量相对于定位祖先元素</li><li>没有定位祖先元素，定位偏移量相对于初始包含块。（并不是html或body元素，初始包含块可以理解为页面顶部可视区域，如果页面有滚动区域，滚动区域不属于初始包含块）</li></ul></li><li><strong>fixed：固定定位</strong><ul><li>定位偏移量相对于浏览器可视窗口</li></ul></li></ul><h2 id="包含块"><a href="#包含块" class="headerlink" title="包含块"></a>包含块</h2><p>对于浮动元素，其包含块定义为最近的块级祖先元素。对于定位，情况则没有这么简单。</p><p>“根元素”的包含块（也称为初始包含块）由用户代理建立。在 HTML 中，根元素就是 html 元素，不过有些浏览器会使用 body 作为根元素。在大多数浏览器中，初始包含块是一个视窗大小的矩形。</p><p>对于一个非根元素，如果其position值是relative或static，包含块则由最近的块级框、表单元格或行内块祖先框的内容边界构成。</p><p>对于一个非根元素，如果其position值是absolute，包含块设置为最近的position值不是static的祖先元素（可以是任何类型）。这个过程如下：</p><ul><li>如果这个祖先是块级元素，包含块则设置为该元素的内边距边界，也就是由边框界定的区域。</li><li>如果这个祖先是行内元素，包含块则设置为该祖先元素的内容边距。</li><li>如果没有祖先，元素的包含块定义为初始包含块。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 定位 </tag>
            
            <tag> absolute </tag>
            
            <tag> 初始包含块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown语法</title>
      <link href="/MarkDown%E8%AF%AD%E6%B3%95/"/>
      <url>/MarkDown%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>简单介绍 Markdown 语法的几种标签格式<br><a id="more"></a></p><h2 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h2><p><strong>四个星号</strong></p><pre><code>**文本内容**</code></pre><h2 id="斜体字"><a href="#斜体字" class="headerlink" title="斜体字"></a>斜体字</h2><p><em>两个星号</em></p><pre><code>*文本内容*</code></pre><h2 id="strikethrough文本穿透线"><a href="#strikethrough文本穿透线" class="headerlink" title="strikethrough文本穿透线"></a>strikethrough文本穿透线</h2><p><del>四个波浪线</del></p><pre><code>~~文本内容~~</code></pre><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>h1 - h6 标题，h1为#，h6为######，由此类推</p><pre><code># 一级标题###### 六级标题</code></pre><h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><hr><p>三个横线</p><pre><code>---</code></pre><h2 id="引用（quote）"><a href="#引用（quote）" class="headerlink" title="引用（quote）"></a>引用（quote）</h2><blockquote><p>一个尖括号  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用内容</span><br></pre></td></tr></table></figure><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>一个横线 或 一个星号</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 内容</span><br><span class="line">* 内容</span><br></pre></td></tr></table></figure><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>数字加点</li><li>数字值无需按顺序，会默认按数字排序</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 数字加点</span><br><span class="line">8. 数字值无需按顺序</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><a href="http://mengyujing.com/MarkDown语法/">链接</a></p><pre><code>[链接文本](地址)</code></pre><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><pre><code>![image](图片地址)</code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码上下分别用三个波浪线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">代码</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~~</span><br><span class="line">代码</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure></p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>各列中间用一个竖线 |<br>标题（th）和普通数据（td）中间用横线分隔<br>需要为每列设置宽度，直接编写CSS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">列1标题 | 列2标题 | ···</span><br><span class="line">------ | ------- | ··· // 如果设置每列对齐方式，可以在横线左右加冒号，:---表示左对齐，---:表示右对齐，:---:表示居中对齐</span><br><span class="line">行1 列1 | 列2    | ···</span><br><span class="line">行2 列1 | 列2    | ···</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的Math类型</title>
      <link href="/javascript%E4%B8%AD%E7%9A%84Math%E7%B1%BB%E5%9E%8B/"/>
      <url>/javascript%E4%B8%AD%E7%9A%84Math%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 为保存数学公式和信息提供了⼀个公共位置，即 Math 对象。与直接编写的计算功能相⽐， Math对象提供的计算功能执⾏起来要快得多。<br>Math 对象是 JavaScript 中的⼀个全局对象，它并没有构造函数，⽽是直接使⽤ Math 对象名称即可。</p><pre><code>Math.random();</code></pre><a id="more"></a><style>    table th:first-child{        width: 150px;    }</style><h2 id="Math对象的属性"><a href="#Math对象的属性" class="headerlink" title="Math对象的属性"></a>Math对象的属性</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">E</td><td style="text-align:left">返回算术常量 e，即⾃然对数的底数（约等于2.718）。</td></tr><tr><td style="text-align:center">LN2</td><td style="text-align:left">返回 2 的⾃然对数（约等于0.693）。</td></tr><tr><td style="text-align:center">LN10</td><td style="text-align:left">返回 10 的⾃然对数（约等于2.302）。</td></tr><tr><td style="text-align:center">LOG2E</td><td style="text-align:left">返回以 2 为底的 e 的对数（约等于 1.414）。</td></tr><tr><td style="text-align:center">LOG10E</td><td style="text-align:left">返回以 10 为底的 e 的对数（约等于0.434）。</td></tr><tr><td style="text-align:center">PI</td><td style="text-align:left">返回圆周率（约等于3.14159）。</td></tr><tr><td style="text-align:center">SQRT1_2</td><td style="text-align:left">返回2 的平⽅根的倒数（约等于 0.707）。</td></tr><tr><td style="text-align:center">SQRT2</td><td style="text-align:left">返回 2 的平⽅根（约等于 1.414）。</td></tr></tbody></table><h2 id="Math对象的方法"><a href="#Math对象的方法" class="headerlink" title="Math对象的方法"></a>Math对象的方法</h2><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">abs(x)</td><td style="text-align:left">返回数的绝对值。</td></tr><tr><td style="text-align:center">ceil(x)</td><td style="text-align:left">对数进⾏上舍⼊。</td></tr><tr><td style="text-align:center">exp(x)</td><td style="text-align:left">返回 e 的指数。</td></tr><tr><td style="text-align:center">log(x)</td><td style="text-align:left">返回数的⾃然对数（底为e）。</td></tr><tr><td style="text-align:center">floor(x)</td><td style="text-align:left">对数进⾏下舍⼊。</td></tr><tr><td style="text-align:center">max(x, y)</td><td style="text-align:left">返回 x 和 y 中的最⾼值。</td></tr><tr><td style="text-align:center">min(x, y)</td><td style="text-align:left">返回 x 和 y 中的最低值。</td></tr><tr><td style="text-align:center">pow(x, y)</td><td style="text-align:left">返回 x 的 y 次幂。</td></tr><tr><td style="text-align:center">round(x)</td><td style="text-align:left">把数四舍五⼊为最接近的整数。</td></tr></tbody></table><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">acos(x)</td><td style="text-align:left">返回数的反余弦值。</td></tr><tr><td style="text-align:center">asin(x)</td><td style="text-align:left">返回数的反正弦值。</td></tr><tr><td style="text-align:center">atan(x)</td><td style="text-align:left">以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值。</td></tr><tr><td style="text-align:center">atan2(x)</td><td style="text-align:left">返回从 x 轴到点 (x,y) 的⻆度（介于 -PI/2 与 PI/2 弧度之间）。</td></tr><tr><td style="text-align:center">cos(x)</td><td style="text-align:left">返回数的余弦。</td></tr><tr><td style="text-align:center">sin(x)</td><td style="text-align:left">返回数的正弦。</td></tr><tr><td style="text-align:center">tan(x)</td><td style="text-align:left">返回⻆的正切。</td></tr></tbody></table><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>random()：返回 0~1 之间的随机数。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript实现拖拽</title>
      <link href="/javascript%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD/"/>
      <url>/javascript%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD/</url>
      
        <content type="html"><![CDATA[<p>下面使用javascript代码简单实现拖拽div的效果，并通过setCapture()方法兼容IE 8及之前的IE版本浏览器。<br><a id="more"></a></p><p>创建一个div</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"d1"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>为div添加样式，设置定位</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#d1 &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    background-color: lightskyblue;</span><br><span class="line">    z-index: 100;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现拖拽的JavaScript代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">var d1 = document.getElementById(<span class="string">'d1'</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(elem, event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(event, callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span>+event, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    TODO mousedown</span><br><span class="line">    TODO    * 开启开关</span><br><span class="line">    TODO    * 得到offsetX 和 offsetY</span><br><span class="line">*/</span><br><span class="line">var flag = <span class="literal">false</span>;</span><br><span class="line">var offsetX;</span><br><span class="line">var offsetY;</span><br><span class="line">/*</span><br><span class="line">    TODO IE 8 浏览器里面，实现拖拽，需要调用元素的 setCapture() 方法，否则报错</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">bind</span>(d1, <span class="string">'mousedown'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    var e = e || window.event;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">    offsetX = e.offsetX;</span><br><span class="line">    offsetY = e.offsetY;</span><br><span class="line">    <span class="keyword">if</span>(d1.setCapture)&#123;</span><br><span class="line">        d1.setCapture();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">bind</span>(d1, <span class="string">'mousemove'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    var e = e || window.event;</span><br><span class="line">    <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">        d1.style.top = e.pageY - offsetY + <span class="string">'px'</span>;</span><br><span class="line">        d1.style.left = e.pageX - offsetX + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">/*</span><br><span class="line">    TODO IE 8 浏览器，鼠标点击时调用了 setCapture()</span><br><span class="line">    TODO    鼠标松开时，需要调用元素的 releaseCapture() 方法</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">bind</span>(d1, <span class="string">'mouseup'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    flag = <span class="literal">false</span>; // 关闭开关</span><br><span class="line">    <span class="keyword">if</span>(d1.releaseCapture)&#123;</span><br><span class="line">        d1.releaseCapture();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拖拽效果 </tag>
            
            <tag> setCapture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的this的用法</title>
      <link href="/javascript%E4%B8%AD%E7%9A%84this%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>/javascript%E4%B8%AD%E7%9A%84this%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>javascript中的this，在不同情况下得到的值不同。<br><a id="more"></a></p><h3 id="在全局作用域中"><a href="#在全局作用域中" class="headerlink" title="在全局作用域中"></a>在全局作用域中</h3><p>指向 window 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(this); // Window</span><br></pre></td></tr></table></figure><h3 id="在构造函数中"><a href="#在构造函数中" class="headerlink" title="在构造函数中"></a>在构造函数中</h3><p>指向通过构造函数创建的对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">A</span></span>() &#123;</span><br><span class="line">    this.name = <span class="string">'myj'</span>;</span><br><span class="line">&#125;</span><br><span class="line">var a = new A();</span><br><span class="line">console.log(a.name); // myj</span><br></pre></td></tr></table></figure><h3 id="在普通函数中"><a href="#在普通函数中" class="headerlink" title="在普通函数中"></a>在普通函数中</h3><p>指向 window 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">b</span></span>() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">b(); // Window</span><br></pre></td></tr></table></figure><h3 id="在局部函数-回调函数中"><a href="#在局部函数-回调函数中" class="headerlink" title="在局部函数/回调函数中"></a>在局部函数/回调函数中</h3><p>指向 window 对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">d</span></span>() &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">e</span></span>() &#123;</span><br><span class="line">        console.log(this);// Window</span><br><span class="line">    &#125;</span><br><span class="line">    e();</span><br><span class="line">&#125;</span><br><span class="line">d();</span><br></pre></td></tr></table></figure><h3 id="在对象的方法中"><a href="#在对象的方法中" class="headerlink" title="在对象的方法中"></a>在对象的方法中</h3><p>指向当前对象</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">var obj = &#123;</span><br><span class="line">    sayMe : fn</span><br><span class="line">&#125;</span><br><span class="line">obj.sayMe(); // Object &#123; sayMe: fn() &#125; -- 即obj对象</span><br></pre></td></tr></table></figure><h3 id="在事件的处理函数中"><a href="#在事件的处理函数中" class="headerlink" title="在事件的处理函数中"></a>在事件的处理函数中</h3><p>指向触发当前事件的标签</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var  btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(this); // &lt;button id=<span class="string">"btn"</span>&gt;button&lt;/button&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用call和apply调用的函数，第一个参数就是this"><a href="#使用call和apply调用的函数，第一个参数就是this" class="headerlink" title="使用call和apply调用的函数，第一个参数就是this"></a>使用call和apply调用的函数，第一个参数就是this</h3>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript事件</title>
      <link href="/javascript%E4%BA%8B%E4%BB%B6/"/>
      <url>/javascript%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p>为 HTML 页面指定标签绑定指定事件，可以通过以下三种方式实现:</p><a id="more"></a><ul><li>HTML 标签的事件属性(onclick=fn()): 这种方式 HTML 代码和 JavaScript 逻辑不能很好地分离，所以不建议使用。</li><li>DOM 标准的事件(element.onclick=function(){}): 这种方式只能为指定的一个标签绑定一个事件，并且只能具有一个事件处理函数。</li><li>事件监听器: 这种方式是目前最受欢迎的一种方式。但 IE 8 及之前的版本不支持！</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO element.onclick 事件绑定</span><br><span class="line">    TODO 多次绑定，最后一次有效，会覆盖前面的</span><br><span class="line">*/</span><br><span class="line">btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'这是事件绑定1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'这是事件绑定2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h2><h3 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener()方法"></a>addEventListener()方法</h3><p>DOM 提供了事件监听器，可以同时绑定多个事件，并且具有多个事件处理函数。具体监听器语法如下:</p><pre><code>element.addEventListener(eventName, functionName, boolean)</code></pre><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">eventName</td><td style="text-align:left">为元素指定具体的事件名称（例如单击事件是 click 等）</td></tr><tr><td style="text-align:center">functionName</td><td style="text-align:left">绑定事件的处理函数</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:left">设置事件是捕获阶段还是冒泡阶段。为 false 时为冒泡阶段，一般都是这个值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO element.addEventListener() 事件监听</span><br><span class="line">    TODO 点击按钮，结果：</span><br><span class="line">    TODO * 这是事件绑定2</span><br><span class="line">    TODO * 这是事件监听1</span><br><span class="line">    TODO * 这是事件监听2</span><br><span class="line">    TODO 多次监听，都有效，且最后一次通过绑定方式的也有效，不覆盖</span><br><span class="line">*/</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'这是事件监听1'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">a</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'这是事件监听2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeEventListener-方法"><a href="#removeEventListener-方法" class="headerlink" title="removeEventListener()方法"></a>removeEventListener()方法</h3><p>移除事件监听器</p><pre><code>removeEventListener(eventName, functionName, boolean)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO element.removeEventListener() 解除某个事件绑定</span><br><span class="line">    TODO 结果：</span><br><span class="line">    TODO * 这是事件绑定2</span><br><span class="line">    TODO * 这是事件监听1</span><br><span class="line">    TODO 为 btn 绑定的 a 函数被解除</span><br><span class="line">*/</span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>,a);</span><br></pre></td></tr></table></figure><h3 id="attachEvent-方法"><a href="#attachEvent-方法" class="headerlink" title="attachEvent()方法"></a>attachEvent()方法</h3><p>IE 8 及之前的版本浏览器并不支持 addEventListener() 方法，而提供了如下方法实现</p><pre><code>element.attachEvent(eventName, functionName)</code></pre><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>eventName</td><td>为元素指定具体的事件名称（例如单件事件是 onclick 等）</td></tr><tr><td>functionName</td><td>绑定事件的处理函数</td></tr></tbody></table><blockquote><p>值得注意的是: attachEvent() 方法的 eventName 参数与 addEventListener() 方法的 eventName 参数不同</p></blockquote><h2 id="监听器的兼容方案"><a href="#监听器的兼容方案" class="headerlink" title="监听器的兼容方案"></a>监听器的兼容方案</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(elem, event, callback)&#123;</span><br><span class="line">    // 判断是否存在 addEventListener</span><br><span class="line">    <span class="keyword">if</span> (elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(event, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span> + event, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 addEventListener() 方法中的 this 和在 attachEvent() 方法中的 this 指代不同。<br>通过 addEventListener() 方法为 HTML 页面的标签绑定事件时，this 关键字指代绑定该事件的标签元素。<br>通过 attachEvent() 方法为 HTML 页面的标签绑定事件时，this 关键字指代绑定 window 对象。</p></blockquote><h1 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h1><p>HTML 页面的标签绑定事件的处理函数中，提供了一个事件对象（event）。这个事件对象会返回关于该事件的信息，以及该事件绑定在哪个元素中。<br>事件对象是以事件的处理函数中的参数形式出现，并不需要我们自己创建，直接使用即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(eventName, <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    // event 就是事件对象</span><br><span class="line">&#125;, boolean)</span><br></pre></td></tr></table></figure><h2 id="兼容的事件对象"><a href="#兼容的事件对象" class="headerlink" title="兼容的事件对象"></a>兼容的事件对象</h2><p>使用 DOM 标准的事件绑定时，Event 事件对象在 IE 8 及之前的版本浏览器情况有所不同。</p><ul><li><p>IE 9 及之后的版本和其他浏览器: 通过事件的处理函数的形参直接得到 Event 对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    console.log(event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>IE 8 及之前的版本浏览器: Event 事件对象被提供在 window 对象中。event对象为全局作用域对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    console.log(window.event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>想要实现 Event 事件对象的兼容，我们可以在事件的处理函数中添加以下代码:</p><pre><code>event = event || window.event;</code></pre><p>测试时发现，不在事件的处理函数中添加形参event，函数中也可以使用，这种方式是不严格的，在Firefox浏览器中会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(elem, event, callback)&#123;</span><br><span class="line">    <span class="keyword">if</span> (elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(event, callback, <span class="literal">false</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span> + event, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    TODO 回调函数形参不添加 event，直接使用</span><br><span class="line">    TODO * Chrome浏览器：MouseEvent 对象</span><br><span class="line">    TODO * Firefox浏览器：ReferenceError: event is not defined</span><br><span class="line">    TODO * IE 11：[object PointerEvent]</span><br><span class="line">    TODO * IE 8：[object Object]</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">bind</span>(btn, <span class="string">'click'</span>, <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(event);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件的目标元素"><a href="#事件的目标元素" class="headerlink" title="事件的目标元素"></a>事件的目标元素</h2><p>Event 事件对象提供了 target 属性用于获取触发事件的目标元素（标签）。</p><p>IE 8 及之前的版本浏览器不支持 target 属性，而是提供了 srcElement 属性进行替换。</p><p>解决方案：</p><pre><code>var target = event.target || event.srcElement;</code></pre><blockquote><p>this与event.target的区别</p><ul><li>event.target - 获取触发当前事件的元素</li><li>this - 获取绑定当前事件的元素</li></ul></blockquote><h2 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h2><p>HTML 页面的一些标签具有默认行为。所谓默认行为，就是不用编写 JavaScript 代码就可以实现的动态效果。例如如下标签:</p><ul><li>a 标签: 用户点击 a 标签，会发生页面跳转行为。</li><li>form 标签: 用户点击表单的提交按钮，表单会发生提交行为。</li></ul><p>阻止默认行为，就是不让 HTML 页面这些标签的默认行为发生。想要阻止默认行为可以通过 Event 事件对象提供的属性实现:</p><ul><li>IE 8 及之前版本的浏览器: returnValue 属性 – event.returnValue=false。也可以直接通过return false阻止。</li><li>IE 9 及之后版本和其他浏览器: preventDefault() 方法</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(elem, eventName, functionName) &#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(eventName, functionName);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span>+eventName, functionName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line">    TODO event.preventDefault() 方法</span><br><span class="line">    TODO * 其他浏览器 -- IE 8 不适用</span><br><span class="line">    TODO event.returnValue 属性</span><br><span class="line">    TODO * IE 8 浏览器</span><br><span class="line">    TODO * event.returnValue = <span class="literal">false</span>;</span><br><span class="line">*/</span><br><span class="line"><span class="built_in">bind</span>(a, <span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(e.preventDefault)&#123;</span><br><span class="line">        e.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        e.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="获取鼠标坐标"><a href="#获取鼠标坐标" class="headerlink" title="获取鼠标坐标"></a>获取鼠标坐标</h2><p>当 HTML 页面中标签绑定的事件被触发时，我们还可以通过 Event 事件对象获取鼠标当前的坐标值。</p><ul><li>x和y - 结果等同于clientX和clientY</li><li>pageX和pageY - 鼠标相对于当前整个页面的坐标值。如果页面过大（存在滚动条），部分页面可能存在可视区域之外。</li><li>clientX和clientY - 鼠标相对于当前窗口可视区域的坐标值</li><li>screenX和screenY - 鼠标相对于当前屏幕的坐标值，从屏幕（不是浏览器）的左上角开始计算。</li><li>offsetX和offsetY - 鼠标相对于指定元素的坐标值（发生事件的地点在事件源元素的坐标系统中的 x 坐标和 y 坐标。）如果是div绑定的事件，则是鼠标相对于该div左上角的位移。</li></ul><h1 id="事件周期"><a href="#事件周期" class="headerlink" title="事件周期"></a>事件周期</h1><p>根据 W3C 标准事件的发生流程可以分为捕获阶段、触发阶段以及冒泡阶段。</p><ul><li>捕获阶段: 事件根据 DOM 树结构从最上层节点向下传播，直到绑定该事件节点为止。</li><li>触发阶段: 事件发生，执行对应的处理函数的逻辑代码。</li><li>冒泡阶段: 事件根据 DOM 树结构从绑定事件节点向上传播。</li></ul><blockquote><p>如果 addEventListener() 方法的第三个参数值为 true，表示捕获阶段<br>如果 addEventListener() 方法的第三个参数值为 false（默认值），表示冒泡阶段</p></blockquote><blockquote><p>值得注意的是: IE 8 及之前版本的浏览器不支持捕获阶段。</p></blockquote><blockquote><p>捕获阶段和冒泡阶段，相当于实现了父子关系的元素的事件的继承。触发子元素的事件函数时，父元素的事件函数也会触发。</p></blockquote><p>定义父子关系的 div：#d1、#d2，为d1和d2分别绑定事件：</p><ul><li>因为冒泡阶段的存在，当点击d2时，会先执行d2的事件函数，再执行d1的事件函数。</li><li>如果使用elem.addEventListener()绑定事件时，第三个参数设置为true，表示捕获阶段，则点击d2时，会先执行d1的事件函数，再执行d2的事件函数。</li></ul><h2 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h2><p>如果在上述示例中的冒泡阶段，我们可以看到事件会从最底层节点向上传播。如果只想触发当前节点的事件，而不继续向上冒泡，我们可以通过 Event 事件对象提供的属性来完成:</p><ul><li>IE 8 及之前版本的浏览器: cancelBubble 属性设置为true</li><li>IE 9 及之后版本和其他浏览器: stopPropagation() 方法</li></ul><blockquote><p><em>注意</em> 以下代码中，将addEventListener第三个参数设置为true，stopPropagation()方法在浏览器中可以阻止事件捕获，这是浏览器的原因，在标准规范中，stopPropagation方法只用来阻止事件冒泡。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div id=<span class="string">"d1"</span>&gt;</span><br><span class="line">    &lt;div id=<span class="string">"d2"</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">"d3"</span>&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// JS</span><br><span class="line">var d1 = document.getElementById(<span class="string">'d1'</span>);</span><br><span class="line">var d2 = document.getElementById(<span class="string">'d2'</span>);</span><br><span class="line">var d3 = document.getElementById(<span class="string">'d3'</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="built_in">bind</span>(elem, event, callback) &#123;</span><br><span class="line">    <span class="keyword">if</span>(elem.addEventListener)&#123;</span><br><span class="line">        elem.addEventListener(event, callback);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        elem.attachEvent(<span class="string">'on'</span>+event, callback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span>(d1, <span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    alert(d1.id);</span><br><span class="line">    // TODO 阻止冒泡</span><br><span class="line">    <span class="keyword">if</span>(e.stopPropagation)&#123;</span><br><span class="line">        /*</span><br><span class="line">            TODO 其他浏览器</span><br><span class="line">            TODO * 如果 addEventListener 方法第三个参数设置为<span class="literal">true</span>，则阻止捕获</span><br><span class="line">            TODO * 不管点击哪一个div，都只会触发祖先元素的事件函数</span><br><span class="line">            TODO    * 阻止捕获只是浏览器中的效果，标准中只是阻止冒泡</span><br><span class="line">            TODO * 如果 addEventListener 方法第三个参数设置为<span class="literal">false</span>，则阻止冒泡</span><br><span class="line">            TODO * 点击哪一个div，触发祖该div的事件函数</span><br><span class="line">            */</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        /*</span><br><span class="line">            TODO IE 8 浏览器</span><br><span class="line">            TODO * IE 8浏览器不支持事件捕获，只有事件冒泡，会阻止事件冒泡</span><br><span class="line">            TODO * 点击哪一个div，触发祖该div的事件函数</span><br><span class="line">            */</span><br><span class="line">        e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">bind</span>(d2, <span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    alert(d2.id);</span><br><span class="line">    <span class="keyword">if</span>(e.stopPropagation)&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">bind</span>(d3, <span class="string">'click'</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    e = e || window.event;</span><br><span class="line">    alert(d3.id);</span><br><span class="line">    <span class="keyword">if</span>(e.stopPropagation)&#123;</span><br><span class="line">        e.stopPropagation();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>原本将事件绑定给指定元素，实际上委托给另一个元素，完成事件的绑定和触发。</p><p>实现步骤</p><ul><li>将事件绑定给共同的祖先节点</li><li>判断触发事件的元素必须原本的元素</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">"btn"</span> class=<span class="string">"btn btn-primary"</span>&gt;添加&lt;/button&gt;</span><br><span class="line">&lt;ul id=<span class="string">"parent"</span> class=<span class="string">"list-group"</span>&gt;</span><br><span class="line">    &lt;li class=<span class="string">"list-group-item"</span>&gt;&lt;a href=<span class="string">"#"</span>&gt;链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">"list-group-item"</span>&gt;&lt;a href=<span class="string">"#"</span>&gt;链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li class=<span class="string">"list-group-item"</span>&gt;&lt;a href=<span class="string">"#"</span>&gt;链接&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">var ul = document.getElementById(<span class="string">'parent'</span>);</span><br><span class="line">/*</span><br><span class="line">    TODO 为 ul 中的所有 a 标签绑定事件</span><br><span class="line">    TODO    * 如果直接循环为a标签添加的话，新增的li中的a标签则没有绑定</span><br><span class="line">    TODO 使用事件委托</span><br><span class="line">    TODO    * 为 ul 绑定事件，则点击 ul、li、a 标签时，都可以触发</span><br><span class="line">    TODO    * 判断 target 为 a 标签时，执行真正的函数代码</span><br><span class="line">*/</span><br><span class="line">ul.onclick = <span class="keyword">function</span> (event) &#123;</span><br><span class="line">    var event = event || window.event;</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    <span class="keyword">if</span>(target.nodeName === <span class="string">'A'</span>)&#123;</span><br><span class="line">        alert(<span class="string">'aaa'</span>);</span><br><span class="line">        event.preventDefault(); // 阻止 a 标签的默认行为</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// TODO 点击添加一行，因为为ul绑定了事件，所以新增的一行里，a标签可以响应</span><br><span class="line">var btn = document.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var li = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">    li.className = <span class="string">'list-group-item'</span>;</span><br><span class="line">    li.innerHTML = <span class="string">'&lt;a href="#"&gt;链接&lt;/a&gt;'</span>;</span><br><span class="line">    ul.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滚轮事件"><a href="#滚轮事件" class="headerlink" title="滚轮事件"></a>滚轮事件</h1><ul><li>onscroll事件 - 1. 滚轮事件，2. 滚动条事件</li><li>onmousewheel事件 - 滚轮事件</li></ul><blockquote><p>onmousewheel事件为新增事件，只有Chrome浏览器支持</p></blockquote><h1 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h1><ul><li>onkeydown - 表示键盘被按下</li><li>onkeyup - 表示键盘被释放</li><li>onkeypress - 表示键盘被按一下</li></ul><blockquote><p>获取对应按键</p><ul><li>event.keyCode 属性（建议使用）</li><li>event.which 属性</li><li>event.key 属性</li></ul></blockquote><p><b>注意：以上三个属性IE 8 及以下版本都不支持</b></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var data = document.getElementById(<span class="string">'data'</span>);</span><br><span class="line">var show = document.getElementById(<span class="string">'show'</span>);</span><br><span class="line">data.onkeyup = <span class="keyword">function</span> (e) &#123;</span><br><span class="line">    show.innerHTML = e.keyCode + <span class="string">'  '</span> + e.which + <span class="string">'    '</span> + e.key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，按下按键，依次显示keyCode、which、key三个属性：</p><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">keyCode</th><th style="text-align:center">which</th><th style="text-align:center">key</th></tr></thead><tbody><tr><td style="text-align:center">a</td><td style="text-align:center">65</td><td style="text-align:center">65</td><td style="text-align:center">a</td></tr><tr><td style="text-align:center">z</td><td style="text-align:center">90</td><td style="text-align:center">90</td><td style="text-align:center">z</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">48</td><td style="text-align:center">48</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">57</td><td style="text-align:center">57</td><td style="text-align:center">9</td></tr><tr><td style="text-align:center">pageup</td><td style="text-align:center">38</td><td style="text-align:center">38</td><td style="text-align:center">其他浏览器：ArrowUp <br> IE9-11: Up</td></tr></tbody></table><h1 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h1><h2 id="event的button属性"><a href="#event的button属性" class="headerlink" title="event的button属性"></a>event的button属性</h2><p>可以通过 event.button 得到鼠标点击的是左键或右键（IE 8 浏览器不适用）</p><ul><li>0：左键</li><li>1：中间的滚轮键</li><li>2：右键</li></ul><h2 id="阻止点击右键默认菜单"><a href="#阻止点击右键默认菜单" class="headerlink" title="阻止点击右键默认菜单"></a>阻止点击右键默认菜单</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// TODO 专门用于禁用浏览器默认右键菜单</span><br><span class="line">body.oncontextmenu = <span class="keyword">function</span>(event)&#123;</span><br><span class="line">    event = event || window.event;</span><br><span class="line">    <span class="keyword">if</span>(event.preventDefault)&#123;</span><br><span class="line">        event.preventDefault();</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        window.event.returnValue = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要为body设置高度</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> event对象 </tag>
            
            <tag> 事件监听 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>innerHTML、document.write()和DOM操作的优缺点</title>
      <link href="/innerHTML%E3%80%81document-write-%E5%92%8CDOM%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/innerHTML%E3%80%81document-write-%E5%92%8CDOM%E6%93%8D%E4%BD%9C%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>innerHTML 属性、 document.write() 方法和 DOM 操作的优缺点各是什么？<br><a id="more"></a></p><h3 id="innerHTML属性"><a href="#innerHTML属性" class="headerlink" title="innerHTML属性"></a>innerHTML属性</h3><p>优点：</p><ul><li>和 DOM 操作方法相比，可以使用更少的代码添加大量的新标签。</li><li>向页面中添加大量新元素时，速度比 DOM 操作更快。</li><li>当需要移除元素中的所有内容时，它更简单（直接设置一个空字符串即可）。</li></ul><p>缺点：</p><ul><li>不应该用它来添加来自于用户输入的内容，因为存在安全隐患。</li><li>在添加一个很大的 DOM 片段时，这个方法很难独立区分出每一个元素。</li><li>事件处理程序可能不像预期那样生效。</li></ul><h3 id="document-write-方法"><a href="#document-write-方法" class="headerlink" title="document.write() 方法"></a>document.write() 方法</h3><p>优点: </p><ul><li>可以快速、简单地让初学者理解如何向页面添加内容。</li></ul><p>缺点：</p><ul><li>只在页面初始化加载时有效。在事件函数调用时使用，会把页面其他内容清空。</li><li>在严格验证的 XHTML 中可能会遇到问题。</li></ul><h3 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h3><p>优点：</p><ul><li>如果 DOM 片段中拥有大量的兄弟节点，处理其中一个元素节点时使用这种方法更合适。</li><li>不会影响事件处理程序。</li><li>可以轻易地使用脚本来逐步添加元素。</li></ul><p>缺点：</p><ul><li>如果需要对页面内容进行大量修改，它的速度比 innerHTML 属性更慢。</li><li>与使用 innerHTML 属性相比，它需要更多的代码来实现同样的功能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> innerHTML </tag>
            
            <tag> document.write() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组去重</title>
      <link href="/JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
      <url>/JavaScript%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/</url>
      
        <content type="html"><![CDATA[<p>下面介绍几种自己总结的数组去重的方法<br><a id="more"></a></p><h3 id="嵌套循环去重"><a href="#嵌套循环去重" class="headerlink" title="嵌套循环去重"></a>嵌套循环去重</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'er'</span>,<span class="string">'b'</span>,<span class="string">'er'</span>,<span class="literal">true</span>,1,<span class="string">'g'</span>,<span class="literal">true</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(var j=i+1;j&lt;arr.length;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] === arr[j])&#123;</span><br><span class="line">            arr.splice(j,1);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h3 id="通过数组的indexOf-方法"><a href="#通过数组的indexOf-方法" class="headerlink" title="通过数组的indexOf()方法"></a>通过数组的indexOf()方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'er'</span>,<span class="string">'b'</span>,<span class="string">'er'</span>,<span class="literal">true</span>,1,<span class="string">'g'</span>,<span class="literal">true</span>,<span class="literal">true</span>];</span><br><span class="line">var newarr = [];</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(newarr.indexOf(arr[i]) == -1)&#123;</span><br><span class="line">        newarr.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newarr);</span><br></pre></td></tr></table></figure><h3 id="通过数组的indexOf-lastIndexOf-方法"><a href="#通过数组的indexOf-lastIndexOf-方法" class="headerlink" title="通过数组的indexOf() + lastIndexOf() 方法"></a>通过数组的indexOf() + lastIndexOf() 方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'er'</span>,<span class="string">'b'</span>,<span class="string">'er'</span>,<span class="literal">true</span>,1,<span class="string">'g'</span>,<span class="literal">true</span>,<span class="literal">true</span>];</span><br><span class="line"><span class="keyword">for</span> (var i=arr.length-1; i&gt;=0; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.indexOf(arr[i]) != arr.lastIndexOf(arr[i]))&#123;</span><br><span class="line">        arr.splice(i, 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure><h3 id="通过对象方法"><a href="#通过对象方法" class="headerlink" title="通过对象方法"></a>通过对象方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> TODO 对象方法</span><br><span class="line"> TODO    * 新建一个对象，遍历数组，将数组值同时作为 key 和 value 赋给对象</span><br><span class="line"> TODO    * 新建数组，存储对象的属性值</span><br><span class="line"> TODO    * 问题：去重后的数组顺序改变</span><br><span class="line"> */</span><br><span class="line">var arr = [<span class="string">'a'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'er'</span>,<span class="string">'b'</span>,<span class="string">'er'</span>,<span class="literal">true</span>,1,<span class="string">'g'</span>,<span class="literal">true</span>,<span class="literal">true</span>];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">    obj[arr[i]] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line">var newarr = [];</span><br><span class="line"><span class="keyword">for</span>(var attr <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    newarr.push(obj[attr]);</span><br><span class="line">&#125;</span><br><span class="line">console.log(newarr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 数组去重 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数组排序</title>
      <link href="/JavaScript%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/"/>
      <url>/JavaScript%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>Javascript中数组使用sort()方法进行排序。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>arrayObject.sort(sortby)</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>sortby：可选。规定排序顺序。必须是函数。<a id="more"></a></li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>对数组的引用。请注意，数组在原数组上进行排序，不生成副本。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。</p><p>如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：</p><ul><li>若a应该出现在b之前，则返回一个小于0的值</li><li>若a应该出现在b之后，则返回一个大于0的值</li><li>若a等于b，则返回0</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var arr = [23,4,12,3,67,5,8,60];</span><br><span class="line">/*</span><br><span class="line">    TODO 不传参数，默认排序</span><br><span class="line">    TODO    按字符顺序排序</span><br><span class="line"> */</span><br><span class="line">console.log(arr.sort()); // [ 12, 23, 3, 4, 5, 60, 67, 8 ]</span><br><span class="line">/*</span><br><span class="line">    TODO 由小到大 排序</span><br><span class="line"> */</span><br><span class="line">arr.sort(<span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">    <span class="built_in">return</span> a-b;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); // [ 3, 4, 5, 8, 12, 23, 60, 67 ]</span><br><span class="line">/*</span><br><span class="line">    TODO 由大到小 排序</span><br><span class="line"> */</span><br><span class="line">arr.sort(<span class="keyword">function</span> (a, b) &#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; b)&#123;</span><br><span class="line">        <span class="built_in">return</span> -1;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">        <span class="built_in">return</span> 1;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">return</span> 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr); // [ 67, 60, 23, 12, 8, 5, 4, 3 ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组排序 </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之BOM简单介绍</title>
      <link href="/javascript%E4%B9%8BBOM%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/javascript%E4%B9%8BBOM%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><p>BOM的全称为 Browser Object Model ，被译为 浏览器对象模型。BOM提供了独立于HTML页面内容，而与浏览器相关的一系列对象。主要被用于管理浏览器窗口及与浏览器窗口之间通信等功能。</p><p>BOM是由浏览器所提供的一系列对象，例如 window 对象等。DOM中的document对象实际上是window对象的属性。</p><p>Window对象是BOM 结构中的最顶层的对象，其他对象都是以Window对象的属性形式出现。<br><a id="more"></a></p><blockquote><p>BOM是JavaScript中唯一一个没有标准的内容。</p></blockquote><blockquote><p>javascript中的语法标准是 ECMA ，DOM 的标准是 W3C 制定的。</p></blockquote><h1 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h1><p>Window 对象表示当前浏览器窗口，是BOM 中最顶层的对象。Window对象的属性和方法应用于当前整个浏览器窗口。</p><h2 id="全局Window对象"><a href="#全局Window对象" class="headerlink" title="全局Window对象"></a>全局Window对象</h2><p>由于Window对象是浏览器窗口中最顶层的对象，也就是说，定义在全局域中的变量和函数，实际上都可以是Window对象的属性和方法。</p><p>调用window对象的属性和方法时，可以省略”window.”。</p><p>定义全局变量和函数时，实际上是为window对象添加属性和方法。</p><pre><code>var a = &apos;a&apos;;</code></pre><ul><li>直接调用全局变量名称 - console.log(a)</li><li>通过window对象的属性形式调用 - window.a</li><li>通过this关键字调用 - this.a</li></ul><blockquote><p>值得说明的是: 这一点与 JavaScript 作用域有很大关系。</p></blockquote><h2 id="Window对象与-self-属性"><a href="#Window对象与-self-属性" class="headerlink" title="Window对象与 self 属性"></a>Window对象与 self 属性</h2><p>Window 对象的 self 属性返回当前浏览器窗口的只读引用。换句话讲，self 属性返回的是 Window 对象的引用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO self 属性 - 就是 window 对象</span><br><span class="line">    TODO * 直接操作 window 对象 - 属性或方法是可被修改的</span><br><span class="line">    TODO * self 属性 - 相等于只读的 window 对象</span><br><span class="line">    TODO   * 在实际开发中，使用 window = window.self， 更安全</span><br><span class="line">*/</span><br><span class="line">console.log(window == window.self); // <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="滚动窗口操作"><a href="#滚动窗口操作" class="headerlink" title="滚动窗口操作"></a>滚动窗口操作</h2><p>Window 对象提供了以下两个滚动浏览器窗口的方法:</p><ul><li><p>scrollBy(x, y): 根据指定像素值来滚动浏览器窗口。将页面从当前位置移动指定的距离。<br>x：向右移动的距离。如果为负值，则向左移动。<br>y：向下移动的距离。如果为负值，则向上移动。</p></li><li><p>scrollTo(x, y): 将浏览器窗口滚动到指定坐标值。将页面移动到指定的坐标值(x, y)。</p></li></ul><h1 id="navigator对象"><a href="#navigator对象" class="headerlink" title="navigator对象"></a>navigator对象</h1><p>Navigator 对象表示当前浏览器，该对象包含了浏览器的信息。</p><blockquote><p>值得注意的是: Navigator 对象没有相应标准，不过各个浏览器都支持。</p></blockquote><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>Navigator 对象提供一系列常用属性，获取当前浏览器的信息。具体内容如下:</p><table><thead><tr><th style="text-align:center">属性名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">appCodeName</td><td style="text-align:center">浏览器的代码名</td></tr><tr><td style="text-align:center">appName</td><td style="text-align:center">浏览器的名称</td></tr><tr><td style="text-align:center">appVersion</td><td style="text-align:center">浏览器的平台和版本信息</td></tr><tr><td style="text-align:center">platform</td><td style="text-align:center">运行浏览器的操作系统平台</td></tr></tbody></table><p>使用不同浏览器，结果如下：</p><table><thead><tr><th style="text-align:center">属性名称</th><th>Chrome</th><th>firefox</th><th>IE11</th><th>IE8</th></tr></thead><tbody><tr><td style="text-align:center">appCodeName</td><td>Mozilla</td><td>Mozilla</td><td>Mozilla</td><td>Mozilla</td></tr><tr><td style="text-align:center">appName</td><td>Netscape</td><td>Netscape</td><td>Netscape</td><td>Microsoft Internet Explorer</td></tr><tr><td style="text-align:center">appVersion</td><td>5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36</td><td>5.0 (Windows)</td><td>5.0 (Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729; rv:11.0) like Gecko</td><td>4.0 (compatible; MSIE 8.0; Windows NT 10.0; WOW64; Trident/7.0; .NET4.0C; .NET4.0E; .NET CLR 2.0.50727; .NET CLR 3.0.30729; .NET CLR 3.5.30729)</td></tr><tr><td style="text-align:center">platform</td><td>Win32</td><td>Win32</td><td>Win32</td><td>Win32</td></tr></tbody></table><h2 id="userAgent属性"><a href="#userAgent属性" class="headerlink" title="userAgent属性"></a>userAgent属性</h2><p>Navigator 对象提供很多属性，可以来识别当前浏览器及操作系统信息。但绝大多数属性在目前浏览器中已经不再起作用了。而 Navigator 对象的 userAgent 属性依旧可以实现识别浏览器的功能。</p><p>userAgent 属性返回由客户机发送服务器的 user-agent 头部的值。userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。</p><style>    table th:first-of-type{        width: 100px;    }</style><table><thead><tr><th>浏览器产品</th><th>userAgent属性值</th></tr></thead><tbody><tr><td>Firefox</td><td>Mozilla/5.0 (Windows NT 6.1; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0</td></tr><tr><td>Chrome</td><td>Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/52.0.2743.82 Safari/537.36</td></tr><tr><td>IE 8</td><td>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE 9</td><td>Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE 10</td><td>Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)</td></tr><tr><td>IE 11</td><td>Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko</td></tr><tr><td>Safari</td><td>Mozilla/5.0 (Macintosh; Intel Mac OS X 10124) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.1 Safari/603.1.30</td></tr></tbody></table><blockquote><p>值得注意的是: IE 11 版本的 userAgent 属性信息已经不再包含有关 IE 浏览器的信息，所以我们不能通过 userAgent 属性判断 IE 11 浏览器了。</p></blockquote><p>作用：</p><ul><li><p>用于判断用户当前的浏览器产品</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var ua = navigator.userAgent;</span><br><span class="line"><span class="keyword">if</span>(/firefox/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Firefox 浏览器'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(/chrome/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Chrome 浏览器'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(/safari/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Safari 浏览器'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(/msie/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 IE 11 之前版本的浏览器'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"ActiveXObject"</span> <span class="keyword">in</span> window)&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 IE 11 浏览器'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用于判断用户当前的操作系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (/windows/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Windows 操作系统'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (/mac/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Mac 操作系统'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (/android/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 Android 操作系统'</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (/iphone/i.test(ua))&#123;</span><br><span class="line">    console.log(<span class="string">'当前使用的是 iPhone 操作系统'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h1><p>History 对象包含用户在浏览器中访问过的 URL（网址）。</p><h2 id="length属性"><a href="#length属性" class="headerlink" title="length属性"></a>length属性</h2><p>History 对象的 length 属性可以获取用户在浏览器中访问网址的数量。</p><blockquote><p>length 属性声明了浏览器历史列表中的元素数量。</p></blockquote><h2 id="前进与后退"><a href="#前进与后退" class="headerlink" title="前进与后退"></a>前进与后退</h2><p>History 对象还提供了以下方法实现浏览器前进和后退功能。具体方法如下:</p><ul><li>forward(): 实现跳转下一个页面，作用和浏览器的前进按钮一样。</li><li>back(): 实现转跳到上一个页面，作用和浏览器的回退按钮一样。</li><li>go(): 实现跳转到指定的页面。如果为负数表示后退，如果为正数表示前进。</li></ul><h1 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h1><p>Location 对象包含了浏览器的地址栏中的信息。该对象主要用于获取和设置地址。</p><h2 id="获取和设置地址"><a href="#获取和设置地址" class="headerlink" title="获取和设置地址"></a>获取和设置地址</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前浏览器窗口的地址栏信息</span><br><span class="line">console.log(<span class="string">'Location对象为: '</span> + window.location); // 得到location对象</span><br><span class="line">// 设置当前浏览器窗口的地址栏信息</span><br><span class="line">window.location = <span class="string">'http://www.baidu.com'</span>;</span><br></pre></td></tr></table></figure><p>上述功能我们同样可以通过 Location 对象的 href 属性完成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 获取当前浏览器窗口的地址栏信息</span><br><span class="line">console.log(<span class="string">'Location对象的href属性为: '</span> + location.href);</span><br><span class="line">// 设置当前浏览器窗口的地址栏信息</span><br><span class="line">location.href = <span class="string">'http://www.baidu.com'</span>;</span><br></pre></td></tr></table></figure><h2 id="location对象的属性"><a href="#location对象的属性" class="headerlink" title="location对象的属性"></a>location对象的属性</h2><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center">hash</td><td style="text-align:left">设置或返回从井号 (#) 开始的 URL（锚）。</td></tr><tr><td style="text-align:center">host</td><td style="text-align:left">设置或返回主机名和当前 URL 的端口号。</td></tr><tr><td style="text-align:center">hostname</td><td style="text-align:left">设置或返回当前 URL 的主机名。</td></tr><tr><td style="text-align:center">href</td><td style="text-align:left">设置或返回完整的 URL。</td></tr><tr><td style="text-align:center">pathname</td><td style="text-align:left">设置或返回当前 URL 的路径部分。</td></tr><tr><td style="text-align:center">port</td><td style="text-align:left">设置或返回当前 URL 的端口号。</td></tr><tr><td style="text-align:center">protocol</td><td style="text-align:left">设置或返回当前 URL 的协议。</td></tr><tr><td style="text-align:center">search</td><td style="text-align:left">设置或返回从问号 (?) 开始的 URL（查询部分）。</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(location.href);// http://localhost:63342/DAY21_prac/CODE/06_Location%E5%AF%B9%E8%B1%A1.html?_ijt=m43hr038iube02pjfo42jk0lpt</span><br><span class="line">console.log(location.host); // localhost:63342</span><br><span class="line">console.log(location.hostname); // localhost</span><br><span class="line">console.log(location.port); // 63342</span><br><span class="line">console.log(location.pathname); // /DAY21_prac/CODE/06_Location%E5%AF%B9%E8%B1%A1.html</span><br><span class="line">console.log(location.protocol); // http:</span><br></pre></td></tr></table></figure><h2 id="location对象的方法"><a href="#location对象的方法" class="headerlink" title="location对象的方法"></a>location对象的方法</h2><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">assign()</td><td style="text-align:center">载入一个新的文档，作用和直接修改 location 相同</td></tr><tr><td style="text-align:center">reload()</td><td style="text-align:center">重新载入当前文档，作用和刷新按钮一样。参数为 true 时，则会强制清空缓存刷新页面</td></tr><tr><td style="text-align:center">replace()</td><td style="text-align:center">用新的文档替换当前文档（不会生成历史记录，不能使用回退按钮回退）</td></tr></tbody></table><h1 id="screen对象"><a href="#screen对象" class="headerlink" title="screen对象"></a>screen对象</h1><p>Screen 对象包含有关客户端显示屏幕的信息。</p><p>screen对象的属性</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">availHeight</td><td style="text-align:center">返回显示屏幕的高度 (除 Windows 任务栏之外)。</td></tr><tr><td style="text-align:center">availWidth</td><td style="text-align:center">返回显示屏幕的宽度 (除 Windows 任务栏之外)。</td></tr><tr><td style="text-align:center">bufferDepth</td><td style="text-align:center">设置或返回调色板的比特深度。</td></tr><tr><td style="text-align:center">colorDepth</td><td style="text-align:center">返回目标设备或缓冲器上的调色板的比特深度。</td></tr><tr><td style="text-align:center">deviceXDPI</td><td style="text-align:center">返回显示屏幕的每英寸水平点数。</td></tr><tr><td style="text-align:center">deviceYDPI</td><td style="text-align:center">返回显示屏幕的每英寸垂直点数。</td></tr><tr><td style="text-align:center">fontSmoothingEnabled</td><td style="text-align:center">返回用户是否在显示控制面板中启用了字体平滑。</td></tr><tr><td style="text-align:center">height</td><td style="text-align:center">返回显示屏幕的高度。</td></tr><tr><td style="text-align:center">logicalXDPI</td><td style="text-align:center">返回显示屏幕每英寸的水平方向的常规点数。</td></tr><tr><td style="text-align:center">logicalYDPI</td><td style="text-align:center">返回显示屏幕每英寸的垂直方向的常规点数。</td></tr><tr><td style="text-align:center">pixelDepth</td><td style="text-align:center">返回显示屏幕的颜色分辨率（比特每像素）。</td></tr><tr><td style="text-align:center">updateInterval</td><td style="text-align:center">设置或返回屏幕的刷新率。</td></tr><tr><td style="text-align:center">width</td><td style="text-align:center">返回显示器屏幕的宽度。</td></tr></tbody></table><h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><h2 id="setInterval-和clearInterval"><a href="#setInterval-和clearInterval" class="headerlink" title="setInterval()和clearInterval()"></a>setInterval()和clearInterval()</h2><p>setInterval(code, millisec, lang)<br>含义：按照设置的时间，周期性执行指定逻辑代码<br>参数：</p><ul><li>code : 要调用的函数或要执行的代码</li><li>millisec : 定时器的周期时间，以毫秒为单位</li><li>lang : 可选，javascript</li></ul><p>返回值：设置当前定时器的标识(唯一，不可重复)</p><p>clearInterval(id_of_setinterval)<br>含义：取消定时器<br>参数：</p><ul><li>id_of_setinterval ：指定清除的定时器标识</li></ul><h2 id="setTimeout-和clearTimeout"><a href="#setTimeout-和clearTimeout" class="headerlink" title="setTimeout()和clearTimeout()"></a>setTimeout()和clearTimeout()</h2><p>setTimeout(code, millisec)<br>含义：按照设置的时间，向后延迟执行指定逻辑代码<br>参数：</p><ul><li>code - 设置延迟执行的指定逻辑代码</li><li>millisec - 设置定时器的时间，单位为毫秒</li></ul><p>返回值：设置当前定时器的标识(唯一，不可重复)</p><p>clearTimeout(id_of_settimeout)<br>含义：取消定时器<br>参数：</p><ul><li>id_of_settimeout ：指定清除的定时器标识</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> BOM </tag>
            
            <tag> window对象 </tag>
            
            <tag> navigator </tag>
            
            <tag> history </tag>
            
            <tag> location </tag>
            
            <tag> screen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript之DOM简单介绍</title>
      <link href="/javascript%E4%B9%8BDOM%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/javascript%E4%B9%8BDOM%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h1><p>DOM 的全称为 Document Object Model，译为文档对象模型。DOM 规定了浏览器应该如何创建 HTML 页面，以及 JavaScript 如何访问和修改浏览器窗口中的 Web 页面的内容。<br><a id="more"></a></p><h2 id="W3C-对-DOM-的定义"><a href="#W3C-对-DOM-的定义" class="headerlink" title="W3C 对 DOM 的定义"></a>W3C 对 DOM 的定义</h2><blockquote><p>The Document Object Model is a platform- and language-neutral interface that will allow programs and scripts to dynamically access and update the content, structure and style of documents. The document can be further processed and the results of that processing can be incorporated back into the presented page. </p></blockquote><p>DOM 是一个独立于任何语言和平台的接口，允许任何语言或脚本动态地访问和更新 HTML 文档的内容、结构和样式。该 HTML 页面可以进一步处理，并且该处理的结果可以被合并到所呈现的 HTML 页面中。</p><h2 id="为什么要使用-DOM"><a href="#为什么要使用-DOM" class="headerlink" title="为什么要使用 DOM"></a>为什么要使用 DOM</h2><blockquote><p>“Dynamic HTML” is a term used by some vendors to describe the combination of HTML, style sheets and scripts that allows documents to be animated. The W3C has received several submissions from members companies on the way in which the object model of HTML documents should be exposed to scripts. These submissions do not propose any new HTML tags or style sheet technology.</p></blockquote><p>DHTML（动态的 HTML）是一些厂商为了宣传所使用的术语，用来描述 HTML、CSS 和 JavaScript 的组合，允许 HTML 文档实现动态化。W3C 已经收到一些成员公司提交的关于 HTML 文档的对象模型应该暴露在 JavaScript 中的方法。这些建议中没有建议任何新的 HTML 标签或样式技术。W3C 正在努力确保动态交互和脚本语言的解决方案是一致的。</p><h2 id="详解什么是-DOM"><a href="#详解什么是-DOM" class="headerlink" title="详解什么是 DOM"></a>详解什么是 DOM</h2><p>DOM 的含义：</p><ul><li>D 表示Document，即将一个 HTML 页面表示为一个文档</li><li>O 表示Object，即将一个 HTML 页面中的每一个部分都转换成一个对象<blockquote><p>DOM 实际上是以面向对象方式来描述一个HTML页面。其中Document对象主要处理HTML页面内容。</p></blockquote></li><li>M 表示 Model，即通过模型来表示对象之间的关系，方便获取对象<blockquote><p>DOM 将一个 HTML 页面表示为一个树形结构的模型。</p></blockquote></li></ul><h2 id="DOM-的发展历程"><a href="#DOM-的发展历程" class="headerlink" title="DOM 的发展历程"></a>DOM 的发展历程</h2><p>DOM 的级别包含非 W3C 标准的 0 级和 W3C 标准的 3 级:</p><ul><li>DOM level 0: 定义了 Document 对象的一些属性和方法。<blockquote><p>值得注意的是: DOM level 0 并不是 W3C 的标准。</p></blockquote></li><li>DOM level 1: 是 W3C 在 1998 年 10 月提出的第一个正式的 W3C DOM 标准。<br>·  DOM Core: 提供了 DOM 模型、内存管理、命名约定等方便访问和操作 HTML 页面的内容。<br>·  DOM HTML: 提供了一些与 HTML 页面相关的对象以及 HTML 标签的属性和方法等。<blockquote><p>值得注意的是: DOM level 1 中忽略了事件模型。</p></blockquote></li><li><p>DOM level 2: 是基于 DOM level 1 并且扩展了 DOM level 1，还添加了视图、事件以及 CSS 样式的内容。<br>·  DOM View: 描述 HTML 文档的各种视图的接口。<br>·  DOM Events: 描述了事件流、事件监听注册、事件接口以及文档事件接口等内容。<br>·  DOM Style: 描述了 CSS 样式的接口。<br>·  DOM Traversal and Range: 描述遍历和操作 HTML 文档的接口。</p></li><li><p>DOM level 3: 引入了统一的文档读取和保存的方法，以及文档验证的内容等。<br>·  DOM Load and Save: 描述了文档的读取和保存的接口。<br>·  DOM Validation: 描述了文档验证的接口。</p><blockquote><p>值得注意的是: DOM level 3 引入的主要是对 XML 文档的支持，对于 HTML 文档的用处并不大。</p></blockquote></li></ul><h2 id="DOM-的组成部分"><a href="#DOM-的组成部分" class="headerlink" title="DOM 的组成部分"></a>DOM 的组成部分</h2><ul><li>DOM Core: 指定类属类型，将带有标记的文档看成树状结构并据此对文档进行相关操作。</li><li>DOM HTML: 提供用于操作 HTML 文档以及类似于 JavaScript 对象模型语法的功能部件，在核心 DOM 的基础上支持对所有 HTML 元素对象进行操作。</li><li>DOM CSS: 提供脚本编程实现 CSS 的接口。</li><li>DOM XML</li></ul><h1 id="DOM-节点树"><a href="#DOM-节点树" class="headerlink" title="DOM 节点树"></a>DOM 节点树</h1><h2 id="DOM-树结构"><a href="#DOM-树结构" class="headerlink" title="DOM 树结构"></a>DOM 树结构</h2><p>DOM 将 HTML 页面表示为一个树形结构，方便访问和操作 HTML 页面中的内容。</p><p><img src="/uploads/DOM/dom_node_tree.png" alt="image"></p><p>当浏览器加载 HTML 页面时，会创建这个 HTML 页面的模型。这个模型就叫做 DOM 树结构，会被保存到浏览器的内存中。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>节点（node）是个网络术语，表示网络中的连接点。一个网络是由一些节点构成的集合。</p><p>在 DOM 树结构中主要由以下 4 种节点组成:</p><ul><li>文档节点: 表示整个 HTML 页面（相当于 document 对象）。当需要访问任何标签、属性或文本时，都可以通过文档节点进行导航。</li><li>元素节点: 表示 HTML 页面中的标签（即 HTML 页面的结构）。当访问 DOM 树时，需要从查找元素节点（标签）开始。</li><li>文本节点: 表示 HTML 页面中的标签所包含的文本内容。</li><li>属性节点: 表示 HTML 页面中的开始标签包含的属性。</li></ul><blockquote><p>值得注意的是: 在 DOM 树结构中，属性节点比较特殊，它并不是所在元素节点的子节点。</p></blockquote><h2 id="判断节点类型"><a href="#判断节点类型" class="headerlink" title="判断节点类型"></a>判断节点类型</h2><p>通过 DOM 节点树获取 HTML 页面的节点时，可以通过如下 3 个属性进行判断节点类型</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">nodeName</th><th style="text-align:center">nodeType</th><th style="text-align:center">nodeValue</th></tr></thead><tbody><tr><td style="text-align:center">文档节点</td><td style="text-align:center">#document</td><td style="text-align:center">9</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">元素节点</td><td style="text-align:center">标签名</td><td style="text-align:center">1</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">属性节点</td><td style="text-align:center">属性名</td><td style="text-align:center">2</td><td style="text-align:center">属性值</td></tr><tr><td style="text-align:center">文本节点</td><td style="text-align:center">#text</td><td style="text-align:center">3</td><td style="text-align:center">文本内容</td></tr></tbody></table><h2 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h2><p> 构成节点树结构的同时，节点与节点之间也存在着如下 3 种关系:</p><ul><li>祖先节点与后代节点的关系</li><li>父节点与子节点的关系</li><li>兄弟节点的关系</li></ul><h1 id="DOM-标准-API"><a href="#DOM-标准-API" class="headerlink" title="DOM 标准 API"></a>DOM 标准 API</h1><p>W3C 提供的 DOM 标准通过一系列对象实现，其中主要以以下三种对象为主：</p><ul><li>Document 对象</li><li>Element 对象</li><li>Node 对象为主</li></ul><h1 id="Document-对象"><a href="#Document-对象" class="headerlink" title="Document 对象"></a>Document 对象</h1><p>Document 对象表示浏览器加载的 HTML 页面，并作为查找 HTML 页面内容的入口。它提供了全局函数，例如如何从 HTML 页面中查找指定标签或者在 HTML 页面中如何创建标签等。</p><p>页面中的所有标签，在 DOM 中具有对应的对象，所有的标签对象，同一继承于document对象，可以使用document对象的方法。</p><h2 id="DOM-查询"><a href="#DOM-查询" class="headerlink" title="DOM 查询"></a>DOM 查询</h2><p>获取 HTML 标签就是查找 HTML 页面中的元素节点，也可以称为 DOM 查询。基本有 5 种方式可以使用。</p><h3 id="getElementById-方法"><a href="#getElementById-方法" class="headerlink" title="getElementById()方法"></a>getElementById()方法</h3><p>通过id属性值获取对应标签<br>由于 id 属性值唯一，只能获取指定唯一标签</p><h3 id="getElementsByName-方法"><a href="#getElementsByName-方法" class="headerlink" title="getElementsByName()方法"></a>getElementsByName()方法</h3><p>通过name属性值获取对应标签<br>返回一个类数组对象 - NodeList 对象<br>含义 - 存储结构上类似于数组的存储方式，最终是一个对象(当作数组使用)<br>注意 - 即使获取到的只有一个标签，返回的依旧是类数组结构 </p><h3 id="getElementsByTagName-方法"><a href="#getElementsByTagName-方法" class="headerlink" title="getElementsByTagName()方法"></a>getElementsByTagName()方法</h3><p>通过标签名获取对应标签<br>类似于 getElementsByName() 方法</p><h3 id="getElementsByClassName-方法"><a href="#getElementsByClassName-方法" class="headerlink" title="getElementsByClassName()方法"></a>getElementsByClassName()方法</h3><p>通过class属性值获取对应标签<br>类似于 getElementsByName() 方法</p><blockquote><p>值得注意的是: getElementsByClassName() 方法在 IE 浏览器中，只能是 IE 9 版本之后才支持。（换句话讲，getElementsByClassName() 方法存在浏览器兼容问题。）</p></blockquote><h3 id="通过-CSS-选择器方式获取"><a href="#通过-CSS-选择器方式获取" class="headerlink" title="通过 CSS 选择器方式获取"></a>通过 CSS 选择器方式获取</h3><p>在 HTML5 新特性中提供了两个可以通过 CSS 选择器方式来获取 HTML 页面标签的方法:</p><ul><li>querySelector(selector): 返回第一个选择器匹配的 HTML 页面元素。</li><li>querySelectorAll(selector): 返回全部选择器匹配的 HTML 页面元素。</li></ul><blockquote><p>值得注意的是: 这两个方法只能是 IE 8 版本之后才执行。</p></blockquote><h2 id="DOM-查询分为两类"><a href="#DOM-查询分为两类" class="headerlink" title="DOM 查询分为两类"></a>DOM 查询分为两类</h2><blockquote><p>传统方式: getElementById、getElementsByName、getElementsByTagName 和 getElementsByClassName</p><ul><li>优点: 性能好、查询速度快</li><li>缺点: 使用麻烦</li></ul></blockquote><blockquote><p>HTML5新增: querySelector 和 querySelectorAll</p><ul><li>优点: 使用简便</li><li>缺点: 性能差、查询速度慢</li></ul></blockquote><h2 id="创建元素节点"><a href="#创建元素节点" class="headerlink" title="创建元素节点"></a>创建元素节点</h2><p>通过 Document 对象创建一个新的元素节点（标签），具体语法格式如下:</p><pre><code>document.createElement(标签名)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// TODO 创建元素节点 li</span><br><span class="line">var li = document.createElement(<span class="string">'li'</span>);</span><br><span class="line">var ul = document.getElementById(<span class="string">'container'</span>);</span><br><span class="line">// TODO 将创建的元素节点 li 添加到 ul 中</span><br><span class="line">ul.appendChild(li);</span><br></pre></td></tr></table></figure><h2 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h2><p>通过 Document 对象创建一个新的文本节点（文本内容），具体语法格式如下:</p><pre><code>document.createTextNode(文本内容)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO 创建文本节点</span><br><span class="line">    TODO 添加到 li 中</span><br><span class="line">*/</span><br><span class="line">var textNode = document.createTextNode(<span class="string">'这是一个 id 为 six 的选项'</span>);</span><br><span class="line">li.appendChild(textNode);</span><br></pre></td></tr></table></figure><h2 id="创建属性节点"><a href="#创建属性节点" class="headerlink" title="创建属性节点"></a>创建属性节点</h2><p>通过 Document 对象创建一个新的属性节点，具体语法格式如下:</p><pre><code>document.createAttribute(属性名称)</code></pre><blockquote><p>值得注意的是: 属性节点并不是子节点。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO 创建属性节点 class</span><br><span class="line">    TODO 为属性节点赋值</span><br><span class="line">    TODO 添加到 li 中</span><br><span class="line">*/</span><br><span class="line">var attrNode = document.createAttribute(<span class="string">'class'</span>);</span><br><span class="line">attrNode.nodeValue = <span class="string">'list-group-item'</span>;</span><br><span class="line">li.setAttributeNode(attrNode);</span><br></pre></td></tr></table></figure><h2 id="document对象的特殊属性"><a href="#document对象的特殊属性" class="headerlink" title="document对象的特殊属性"></a>document对象的特殊属性</h2><ul><li>head属性 - 获取到页面中的 head 标签</li><li>body属性 - 获取到页面中的 body 标签</li><li>documentElement属性 - 获取到页面中的 html 标签</li></ul><h1 id="Node-对象"><a href="#Node-对象" class="headerlink" title="Node 对象"></a>Node 对象</h1><h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><h3 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h3><p>通过 HTML 页面的指定标签查找其父节点，我们可以通过如下属性实现:</p><pre><code>node.parentNode</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var childDiv1 = document.getElementById(<span class="string">'childDiv1'</span>);</span><br><span class="line">var parent = childDiv1.parentNode;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是：<br>· parentNode: 表示获取指定节点的父节点。一个元素节点的父节点可能是一个元素(Element )节点，也可能是一个文档(Document )节点。<br>· parentElement: 表示获取当前节点的父元素节点。如果该元素没有父节点，或者父节点不是一个元素节点，则返回 null。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var btn2 = document.getElementById(<span class="string">'btn2'</span>);</span><br><span class="line">btn2.onclick = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    var htmlNode = document.documentElement;</span><br><span class="line">    console.log(<span class="string">'&lt;html&gt;标签的parentNode: '</span>+htmlNode.parentNode);</span><br><span class="line">    console.log(<span class="string">'&lt;html&gt;标签的parentElement: '</span>+htmlNode.parentElement);</span><br><span class="line">&#125;</span><br><span class="line">/* 结果</span><br><span class="line">    原因在于 &lt;html&gt; 标签的父节点是文档节点。</span><br><span class="line">    文档节点并不是一个元素节点，所以 parentElement 返回 null。</span><br><span class="line"> */</span><br><span class="line">&lt;html&gt;标签的parentNode: [object HTMLElement]</span><br><span class="line">&lt;html&gt;标签的parentElement: null</span><br></pre></td></tr></table></figure><h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><p>通过 HTML 页面的指定标签查找其子节点，我们可以通过如下属性实现:</p><ul><li>firstChild: 获取指定标签的第一个子节点。</li><li>lastChild: 获取指定标签的最后一个子节点。</li><li>childNodes: 获取指定标签的所有子节点。</li></ul><blockquote><p>注意：因为下面所介绍的空白节点的存在，父节点调用firstChild、lastChild、childNodes等属性，一般会先得到空白节点。<br>这个问题的解决，一般通过 getElementsByTagName() 方法实现。</p></blockquote><h3 id="空白节点"><a href="#空白节点" class="headerlink" title="空白节点"></a>空白节点</h3><p>有些浏览器在遍历 DOM 时，会在元素节点之间添加一个文本节点，不管这个文本节点的内容是否为空（即空白节点）。<br>不会自动添加空白节点的浏览器只有 IE 8 版本以及之前的版本。换句话讲，IE 9 及之后的版本、Chrome、Firefox 和 Safari 等浏览器都会自动添加空白节点。</p><h3 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h3><p>通过 HTML 页面的指定标签查找兄弟节点，我们可以通过如下属性实现:</p><ul><li>previousSibling: 获取指定节点的前一个兄弟节点。</li><li>nextSibling: 获取指定节点的后一个兄弟节点。</li></ul><blockquote><p>注意，previousSibling 和 nextSibling 两个属性一般也会先得到空白节点。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 获取 id 为 two 的 &lt;li&gt; 标签的前一个兄弟节点，并且改变背景颜色</span><br><span class="line">var btn6 = document.getElementById(<span class="string">'btn6'</span>);</span><br><span class="line">btn6.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var two = document.getElementById(<span class="string">'two'</span>);</span><br><span class="line">    var pre = two.previousSibling.previousSibling;</span><br><span class="line">    pre.style.backgroundColor = <span class="string">'yellow'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h2><p>向 HTML 页面标签插入新的标签或者其他标签，我们可以通过如下方法实现:</p><h3 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h3><p>将一个节点添加到指定父节点的子节点列表末尾。</p><pre><code>parent.appendChild(child)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var btn1 = document.getElementById(<span class="string">'btn1'</span>);</span><br><span class="line">btn1.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var first = document.getElementById(<span class="string">'first'</span>); // ul容器</span><br><span class="line">    first.appendChild(li);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h3><p>在当前节点的某个子节点之前再插入一个子节点。</p><pre><code>parent.insertBefore(newChild,currentChild)</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var btn2 = document.getElementById(<span class="string">'btn2'</span>);</span><br><span class="line">btn2.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var second = document.getElementById(<span class="string">'second'</span>); // ul容器</span><br><span class="line">    var two2 = document.getElementById(<span class="string">'two2'</span>); // 第二个li</span><br><span class="line">    second.insertBefore(li, two2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果将新创建的标签插入到HTML页面中指定的标签中 - 新增标签<br>如果将HTML页面中已存在的标签插入到指定标签中 - 移动标签。该节点不再占有原来位置，相当于将该节点的位置移动了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO 移动节点</span><br><span class="line">    TODO * 即将一个已存在的节点，插入到其他位置，会将该节点的位置移动</span><br><span class="line">*/</span><br><span class="line">var btn3 = document.getElementById(<span class="string">'btn3'</span>);</span><br><span class="line">btn3.onclick = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    var move = document.getElementById(<span class="string">'move'</span>); // 一个已存在节点，位于ul first</span><br><span class="line">    var second = document.getElementById(<span class="string">'second'</span>); // ul second</span><br><span class="line">    var three2 = document.getElementById(<span class="string">'three2'</span>); // ul second 中的一个 li</span><br><span class="line">    second.insertBefore(move, three2); // 节点“move”由first ul移动到了second ul</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>从 HTML 页面中删除指定元素节点（标签），我们可以通过以下方法实现:</p><pre><code>parentNode.removeChild(childNode)</code></pre><h2 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h2><p>将 HTML 页面中指定元素节点（标签）被替换，我们可以通过以下方法实现:</p><pre><code>parentNode.replaceChild(newChild,oldChild)</code></pre><blockquote><p>注意：</p><ul><li>使用新创建的标签替换已存在的标签 - 替换</li><li>使用已存在的标签1替换已存在的标签2 - 标签1移动到标签2的位置，标签2被删除</li></ul></blockquote><h2 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h2><p>将 HTML 页面中指定元素节点（标签）进行复制，我们可以通过以下方法实现:</p><pre><code>node.cloneNode(boolean)</code></pre><blockquote><p>需要说明的是: cloneNode() 方法的参数表示是否采用深度克隆。如果为true，则该节点的所有后代节点也都会被克隆；如果为false，则只克隆该节点本身。</p></blockquote><h1 id="Element-对象"><a href="#Element-对象" class="headerlink" title="Element 对象"></a>Element 对象</h1><p>DOM 访问或操作 HTML 页面内容主要是依靠 DOM 节点树这个模型。但在 DOM 中的三个主要对象，除了 Document 和 Node 之外，还有一个就是 Element 对象。<br>Element 对象描述了所有相同种类的元素所普遍具有的方法和属性，也是访问和操作 HTML 页面内容的主要途径之一。<br>Element 对象和 Node 对象类似，同样提供了一个 DOM 元素树这个模型。如下图所示:<br><img src="/uploads/DOM/DOM节点树与元素树的区别.png" alt="image"></p><blockquote><p>值得注意的是: 节点与元素的区别是什么？<br>1、 通过节点访问或操作 HTML 页面内容: </p><ul><li>元素节点: 表示 HTML 页面中的标签。</li><li>属性节点: 表示 HTML 页面中标签的属性。</li><li>文本节点: 表示 HTML 页面中标签的文本内容。</li></ul><p>2、 通过元素访问或操作 HTML 页面内容:</p><ul><li>元素: 表示 HTML 页面中的标签。</li></ul><p>也就是说，使用节点方式时，标签、属性和文本是平行关系；而使用元素方式时，只有标签，属性和文本成为了标签的一部分。</p></blockquote><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>由于 Element 对象是继承于 Document 对象的，所以 Document 对象的属性和方法，Element 对象都可以直接使用。<br>我们已经掌握如何通过 Document 对象获取 HTML 页面标签:</p><ul><li>getElementById() 方法: 通过标签的 id 属性值获取指定标签。</li><li>getElementsByName() 方法: 通过标签的 name 属性值获取指定标签。</li><li>getElementsByTagName() 方法: 通过标签名获取指定标签。</li><li>getElementsByClassName() 方法: 通过标签的 class 属性值获取指定标签。</li><li>querySelector() 方法: 通过 CSS 选择器方式获取匹配的第一个标签。</li><li>querySelector() 方法: 通过 CSS 选择器方式获取匹配的所有标签。</li></ul><p>以上获取 HTML 页面标签的方法，在 Element 对象中同样可以使用。</p><blockquote><p>值得注意的是: 获取的 HTML 页面中的标签，既是 Node 对象，也是 Element 对象。</p></blockquote><h2 id="遍历元素"><a href="#遍历元素" class="headerlink" title="遍历元素"></a>遍历元素</h2><h3 id="获取父元素"><a href="#获取父元素" class="headerlink" title="获取父元素"></a>获取父元素</h3><p>通过 HTML 页面的指定标签查找其父元素，我们可以通过如下属性实现:</p><blockquote><p>element.parentElement</p></blockquote><h3 id="获取子元素"><a href="#获取子元素" class="headerlink" title="获取子元素"></a>获取子元素</h3><p>通过 HTML 页面的指定标签查找其子元素，我们可以通过如下属性实现:</p><blockquote><p>firstElementChild: 获取指定标签的第一个子元素。<br>lastElementChild: 获取指定标签的最后一个子元素。<br>children: 获取指定标签的所有子元素。</p></blockquote><h3 id="获取兄弟元素"><a href="#获取兄弟元素" class="headerlink" title="获取兄弟元素"></a>获取兄弟元素</h3><p>通过 HTML 页面的指定标签查找兄弟元素，我们可以通过如下属性实现:</p><blockquote><p>previousElementSibling: 获取指定节点的前一个兄弟节点。<br>nextElementSibling: 获取指定节点的后一个兄弟节点。</p></blockquote><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>并没有类似于遍历节点中的空白节点问题</li><li>并不是所有浏览器都支持元素的遍历属性</li></ul><h2 id="操作属性"><a href="#操作属性" class="headerlink" title="操作属性"></a>操作属性</h2><p>Element 对象提供的属性操作的方法，是实际开发中应用最多的。（因为 Element 对象操作属性要比 Node 对象简便。）</p><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><blockquote><p>element.getAttribute(属性名)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// &lt;li id=<span class="string">"one"</span> title=<span class="string">"this is li element"</span> class=<span class="string">"list-group-item"</span>&gt;这是一个 id 为 one 的选项&lt;/li&gt;</span><br><span class="line">var one = document.getElementById(<span class="string">'one'</span>);</span><br><span class="line">var attr = one.getAttribute(<span class="string">'class'</span>);</span><br><span class="line">console.log(attr); // list-group-item</span><br></pre></td></tr></table></figure><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><blockquote><p>element.setAttribute(属性名, 属性值)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one.setAttribute(<span class="string">'class'</span>, <span class="string">'list-group-item active'</span>);</span><br><span class="line">var attr = one.getAttribute(<span class="string">'class'</span>);</span><br><span class="line">console.log(attr); // list-group-item active</span><br></pre></td></tr></table></figure><h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><blockquote><p>element.removeAttribute(属性名)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">one.removeAttribute(<span class="string">'class'</span>);</span><br><span class="line">var attr = one.getAttribute(<span class="string">'class'</span>);</span><br><span class="line">console.log(attr); // null</span><br></pre></td></tr></table></figure><h3 id="判断是否含有属性"><a href="#判断是否含有属性" class="headerlink" title="判断是否含有属性"></a>判断是否含有属性</h3><blockquote><p>element.hasAttribute(属性名)</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(one.hasAttribute(<span class="string">'class'</span>));</span><br></pre></td></tr></table></figure><p>Node 对象具有hasAttributes()方法，判断是否具有属性。</p><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="获取和更新文本"><a href="#获取和更新文本" class="headerlink" title="获取和更新文本"></a>获取和更新文本</h2><h3 id="通过-nodeValue-属性获取或更新文本"><a href="#通过-nodeValue-属性获取或更新文本" class="headerlink" title="通过 nodeValue 属性获取或更新文本"></a>通过 nodeValue 属性获取或更新文本</h3><p>通过学习 DOM 查询我们知道，获取或更新文本就是对文本节点的操作。文本节点的 nodeValue 属性可以得到文本内容，也可以设置文本内容。</p><pre><code>textNode.nodeValue</code></pre><h3 id="通过-innerText-或-textContent-属性获取或更新文本"><a href="#通过-innerText-或-textContent-属性获取或更新文本" class="headerlink" title="通过 innerText 或 textContent 属性获取或更新文本"></a>通过 innerText 或 textContent 属性获取或更新文本</h3><p>innerText 或 textContent 属性都可以用于获取或更新文本。</p><blockquote><p>textContent 在 IE8 及以下版本不支持，得到 undefined<br>IE8 及以下版本，使用 innerText<br>innerText 不能获取被 CSS 样式隐藏的文本内容</p><p>值得注意的是: 并不建议使用 innerText 属性，因为它并不属性任何标准，而且性能不好。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;li id=<span class="string">"one"</span> class=<span class="string">"list-group-item"</span>&gt;这是一个 id 为 one 的选项&lt;/li&gt;</span><br><span class="line">&lt;li id=<span class="string">"two"</span> name=<span class="string">"list"</span> class=<span class="string">"list-group-item"</span>&gt;这是一个 &lt;i&gt;id&lt;/i&gt; 为 two 的选项&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// CSS</span><br><span class="line">i &#123;</span><br><span class="line">    display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JS</span><br><span class="line">console.log(one.innerText); // 这是一个 id 为 one 的选项</span><br><span class="line">console.log(two.innerText); // 这是一个 为 two 的选项</span><br><span class="line">console.log(one.textContent); // 这是一个 id 为 one 的选项</span><br><span class="line">console.log(two.textContent); // 这是一个 id 为 two 的选项</span><br></pre></td></tr></table></figure><blockquote><p>上面的代码中，第二个 li 中的 id 被i标签包围，而i标签在CSS中设置了隐藏，因此，two.innerText得不到i标签中的内容。</p></blockquote><h3 id="innerText-或-textContent-属性兼容性解决"><a href="#innerText-或-textContent-属性兼容性解决" class="headerlink" title="innerText 或 textContent 属性兼容性解决"></a>innerText 或 textContent 属性兼容性解决</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(one.textContent)&#123;</span><br><span class="line">    console.log(one.textContent);</span><br><span class="line">    console.log(two.textContent);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    console.log(one.innerText);</span><br><span class="line">    console.log(two.innerText);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取或更新-HTML"><a href="#获取或更新-HTML" class="headerlink" title="获取或更新 HTML"></a>获取或更新 HTML</h2><p>我们可以通过 innerHTML 属性来获取或更新 HTML 页面的指定标签所包含的 HTML 代码内容。</p><h1 id="CSS操作"><a href="#CSS操作" class="headerlink" title="CSS操作"></a>CSS操作</h1><h2 id="操作内联样式"><a href="#操作内联样式" class="headerlink" title="操作内联样式"></a>操作内联样式</h2><p>HTML 页面标签的内联样式主要是通过 style 属性进行设置，所以 DOM 操作标签的内联样式也是通过 style 属性来完成的。</p><h3 id="style属性"><a href="#style属性" class="headerlink" title="style属性"></a>style属性</h3><pre><code>element.style.attrName = attrValue</code></pre><blockquote><p>如果设置 CSS 样式时，使用了 !important 预定义的 CSS 样式优先级最高，会导致改变内联样式失效。<br>在修改例如 background-color 这样的 CSS 属性时，不能使用 element.style.background-color 这种方式，浏览器会解析成 JavaScript 的表达式。最终会报错。<br>所有例如 background-color 这样的 CSS 属性在使用时，必须要改为 驼峰式 命名方式（例如 backgroundColor）。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// HTML</span><br><span class="line">&lt;div id=<span class="string">"div1"</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// CSS</span><br><span class="line"><span class="comment">#div1 &#123;</span></span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background-color: lightskyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// JS</span><br><span class="line">/*</span><br><span class="line">    TODO 通过标签的 style 属性</span><br><span class="line">    TODO * 得到 CSSStyleDeclaration 对象</span><br><span class="line">    TODO   * 该对象中包含所有 CSS 的样式属性</span><br><span class="line">    TODO * 注意 - 没有获取到当前标签在 &lt;style&gt; 标签中设置的样式内容</span><br><span class="line">    TODO   * 只能获取和设置 style 属性自己的样式内容 -- 即行内样式</span><br><span class="line">*/</span><br><span class="line">console.log(div.style); // CSS2Properties： width、height、background-color都为空</span><br><span class="line"></span><br><span class="line">div.style = <span class="string">'width:200px;height:200px;background-color:yellow;'</span>;</span><br><span class="line">console.log(div.style); // CSS2Properties： width、height、background-color为上面设置的</span><br></pre></td></tr></table></figure><h3 id="getAttribute-和setAttribute"><a href="#getAttribute-和setAttribute" class="headerlink" title="getAttribute()和setAttribute()"></a>getAttribute()和setAttribute()</h3><ul><li>设置内联样式: setAttribute(‘style’, CSS 样式内容)</li><li>获取内联样式: getAttribute(‘style’)</li></ul><blockquote><p>值得注意的是: 通过 getAttribute() 方法获取的内联样式，并不能准确到具体的样式属性值。而是返回所有 CSS 样式内容。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO getAttribute() 方法，得到style属性自身的样式 -- 行内样式</span><br><span class="line">    TODO * 没有设置行内样式，得到 null</span><br><span class="line">*/</span><br><span class="line">console.log(div.getAttribute(<span class="string">'style'</span>)); // null</span><br><span class="line">div.style = <span class="string">'width:200px;height:200px;background-color:yellow;'</span>;</span><br><span class="line">console.log(div.getAttribute(<span class="string">'style'</span>)); // width: 200px; height: 200px; background-color: yellow;</span><br></pre></td></tr></table></figure><h2 id="获取当前样式"><a href="#获取当前样式" class="headerlink" title="获取当前样式"></a>获取当前样式</h2><h3 id="window-getComputedStyle-element-null"><a href="#window-getComputedStyle-element-null" class="headerlink" title="window.getComputedStyle(element, null)"></a>window.getComputedStyle(element, null)</h3><p>通过 element.style 属性，我们只能获取内联样式内容，并不能获取 CSS 样式内容。</p><p>我们可以通过如下方法获取 HTML 页面标签的当前样式内容（内联样式及外联样式）:</p><pre><code>window.getComputedStyle(element, null)</code></pre><blockquote><p>该方法会返回一个包含当前所有的 CSS 样式的对象，我们可以通过 object.attrName 的方式得到指定的样式值。</p></blockquote><h3 id="element-currentStyle"><a href="#element-currentStyle" class="headerlink" title="element.currentStyle"></a>element.currentStyle</h3><p>IE 8 及之前版本的浏览器并不支持 getComputedStyle() 方法。如果，在 IE 8 及之前版本的浏览器，我们需要使用以下属性实现:</p><pre><code>element.currentStyle</code></pre><h3 id="全浏览器兼容解决方案"><a href="#全浏览器兼容解决方案" class="headerlink" title="全浏览器兼容解决方案"></a>全浏览器兼容解决方案</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getStyle(elem, attrName)&#123;</span><br><span class="line">    // 判断 window.getComputedStyle() 方法是否存在</span><br><span class="line">    <span class="keyword">if</span> (window.getComputedStyle)&#123;</span><br><span class="line">        <span class="built_in">return</span> getComputedStyle(elem, null);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">return</span> elem.currentStyle[attrName];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="clientWidth和clientHeight"><a href="#clientWidth和clientHeight" class="headerlink" title="clientWidth和clientHeight"></a>clientWidth和clientHeight</h2><ul><li>可见宽度: clientWidth</li><li>可见高度: clientHeight</li></ul><pre><code>clientWidth = width + padding-left + padding-right</code></pre><h2 id="offsetWidth和offsetHeight"><a href="#offsetWidth和offsetHeight" class="headerlink" title="offsetWidth和offsetHeight"></a>offsetWidth和offsetHeight</h2><ul><li>实际宽度: offsetWidth</li><li>实际高度: offsetHeight</li></ul><pre><code>offsetWidth = width + padding-left + padding-right + border-width</code></pre><h2 id="定位父元素"><a href="#定位父元素" class="headerlink" title="定位父元素"></a>定位父元素</h2><pre><code>element.offsetParent</code></pre><h2 id="offsetLeft和offsetTop"><a href="#offsetLeft和offsetTop" class="headerlink" title="offsetLeft和offsetTop"></a>offsetLeft和offsetTop</h2><ul><li>相对于其定位父元素的水平偏移量：offsetLeft</li><li>相对于其定位父元素的垂直偏移量：offsetTop</li></ul><h2 id="scrollWidth和scrollHeight"><a href="#scrollWidth和scrollHeight" class="headerlink" title="scrollWidth和scrollHeight"></a>scrollWidth和scrollHeight</h2><ul><li>scrollWidth: 获取指定标签滚动区的宽度。</li><li>scrollHeight: 获取指定标签滚动区的高度。</li></ul><h2 id="scrollLeft和scrollTop"><a href="#scrollLeft和scrollTop" class="headerlink" title="scrollLeft和scrollTop"></a>scrollLeft和scrollTop</h2><ul><li>scrollLeft: 获取水平滚动条滚动的距离。</li><li>scrollTop: 获取垂直滚动条滚动的距离。</li></ul><p>当一个元素滚动条到达最底部的时候：</p><pre><code>element.scrollHeight = element.scrollTop + element.clientHeight</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式（Regular Expression）：由一些普通字符和特殊字符组成的，用以描述一种特定的字符规则的表达式。<br>正则表达式常用于在一段文本中搜索、匹配或替换特定形式的文本。如：词语出现频率统计、验证字符串是否符合邮箱格式、屏蔽一篇帖子中的限制性词语等。</p><h2 id="定义正则表达式"><a href="#定义正则表达式" class="headerlink" title="定义正则表达式"></a>定义正则表达式</h2><p>/规则/修饰符<br><a id="more"></a></p><h2 id="正则表达式规则"><a href="#正则表达式规则" class="headerlink" title="正则表达式规则"></a>正则表达式规则</h2><table><thead><tr><th>规则</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>字母和数字</td><td style="text-align:left">自身</td></tr><tr><td>[…]</td><td style="text-align:left">⼀个字符集合。匹配⽅括号的中任意字符。你可以使⽤破折号（-）来指定⼀个字符范围。对于点（.）和星号（*）这样的特殊符号在⼀个字符集中没有特殊的意义。</td></tr><tr><td>[^…]</td><td style="text-align:left">⼀个反向字符集。</td></tr><tr><td>{n, m}</td><td style="text-align:left">n 和 m 都是正整数。匹配前⾯的字符⾄少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</td></tr><tr><td>{n}</td><td style="text-align:left">n是⼀个正整数，匹配了前⾯⼀个字符刚好发⽣了n次。</td></tr><tr><td>?</td><td style="text-align:left">匹配前⾯⼀个字符0次或者1 次，和{0,1}有相同的效果。</td></tr><tr><td>+</td><td style="text-align:left">匹配前⾯⼀个字符1 次或者多次，和{1,}有相同的效果。</td></tr><tr><td>*</td><td style="text-align:left">匹配前⼀个字符0次或者是多次。</td></tr><tr><td>^</td><td style="text-align:left">匹配输⼊的开始。如果多⾏标示被设置为true,同时匹配换⾏后紧跟的字符。</td></tr><tr><td>$</td><td style="text-align:left">匹配输⼊的结束，如果多⾏标示被设置为true,同时会匹配换⾏前紧跟的字符。</td></tr></tbody></table><h2 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h2><table><thead><tr><th>修饰符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>i</td><td style="text-align:left">不区分大小写搜索</td></tr><tr><td>g</td><td style="text-align:left">全局搜索</td></tr><tr><td>m</td><td style="text-align:left">多行搜索</td></tr></tbody></table><h2 id="正则表达式中的转义字符"><a href="#正则表达式中的转义字符" class="headerlink" title="正则表达式中的转义字符"></a>正则表达式中的转义字符</h2><p>正则表达式中的所有字母和数字都是按照字面含义进行匹配的。javascript正则表达式语法也支持非字母的字符匹配，这些字符通过反斜线（\）作为前缀进行转义。</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">匹配</th></tr></thead><tbody><tr><td style="text-align:center">\0</td><td style="text-align:center">匹配NULL字符，不要在这后面跟其他小数</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">匹配一个水平制表符</td></tr><tr><td style="text-align:center">\n</td><td style="text-align:center">匹配一个换行符</td></tr><tr><td style="text-align:center">\v</td><td style="text-align:center">匹配一个垂直制表符</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">匹配一个回车符</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">匹配一个换页符</td></tr><tr><td style="text-align:center">\xhh</td><td style="text-align:center">匹配带有两位小数代码（hh）的字符</td></tr><tr><td style="text-align:center">\uhhhh</td><td style="text-align:center">匹配带有四位⼩数代码（hh）的字符</td></tr><tr><td style="text-align:center">\cX</td><td style="text-align:center">当X是处于A到Z之间的字符的时候，匹配字符串中的⼀个控制符。例如， /\cM/ 匹配字符串中的 control-M (U+000D)。</td></tr><tr><td style="text-align:center">.</td><td style="text-align:center">（小数点）匹配除了换行符(\n)之外的任何单个字符</td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">匹配⼀个单字字符（字⺟、数字或者下划线）。等价于[A-Za-z0-9_]。</td></tr><tr><td style="text-align:center">\W</td><td style="text-align:center">匹配⼀个⾮单字字符。等价于[^A-Za-z0-9_]。</td></tr><tr><td style="text-align:center">\s</td><td style="text-align:center">匹配⼀个空⽩字符，包括空格、制表符、换⻚符和换⾏符。</td></tr><tr><td style="text-align:center">\S</td><td style="text-align:center">匹配⼀个⾮空⽩字符。</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">匹配⼀个数字。等价于[0-9]。</td></tr><tr><td style="text-align:center">\D</td><td style="text-align:center">匹配⼀个⾮数字字符。等价于[^0-9]。</td></tr><tr><td style="text-align:center">[\b]</td><td style="text-align:center">匹配⼀个退格. （不要和\b混淆了）</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">匹配⼀个词的边界。⼀个词的边界就是⼀个词不被另外⼀个词跟随的位置或者不是另⼀个词汇字符前边的位置。</td></tr><tr><td style="text-align:center">\B</td><td style="text-align:center">匹配⼀个⾮单词边界。</td></tr><tr><td style="text-align:center">x(?=y)</td><td style="text-align:center">匹配“x”仅仅当“x”后⾯跟着“y”。这种叫做正向肯定查找。</td></tr><tr><td style="text-align:center">x(?!y)</td><td style="text-align:center">匹配“x”仅仅当“x”后⾯不跟着“y”,这个叫做正向否定查找。</td></tr></tbody></table><h1 id="javascript中的正则表达式"><a href="#javascript中的正则表达式" class="headerlink" title="javascript中的正则表达式"></a>javascript中的正则表达式</h1><h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><h3 id="1-字面量方式"><a href="#1-字面量方式" class="headerlink" title="1.字面量方式"></a>1.字面量方式</h3><pre><code>var expression = pattern/attributes</code></pre><ul><li>pattern参数：被称为模式，可以是任何简单或复杂的正则表达式，包括字符类、限定符、分组、向前查找以及反响引用等</li><li>attributes参数：被称为修饰符，用于表明正则表达式的行为</li></ul><h3 id="2-创建对象方式"><a href="#2-创建对象方式" class="headerlink" title="2.创建对象方式"></a>2.创建对象方式</h3><p>javascript可以通过引用类型 RegExp 创建正则表达式对象。</p><pre><code>var expression = new RegExp( pattern, attributes );</code></pre><h2 id="RegExp对象的属性"><a href="#RegExp对象的属性" class="headerlink" title="RegExp对象的属性"></a>RegExp对象的属性</h2><table><thead><tr><th style="text-align:center">属性名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">global</td><td style="text-align:center">（只读） RegExp 对象是否具有 g 修饰符</td></tr><tr><td style="text-align:center">ignoreCase</td><td style="text-align:center">（只读） RegExp 对象是否具有 i 修饰符</td></tr><tr><td style="text-align:center">multiline</td><td style="text-align:center">（只读） RegExp 对象是否具有 m 修饰符</td></tr><tr><td style="text-align:center">lastIndex</td><td style="text-align:center">⽤于设置/获取下次匹配的起始位置</td></tr><tr><td style="text-align:center">source</td><td style="text-align:center">（只读）返回模式匹配所使⽤的⽂本</td></tr></tbody></table><h2 id="RegExp对象的方法"><a href="#RegExp对象的方法" class="headerlink" title="RegExp对象的方法"></a>RegExp对象的方法</h2><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">compile()</td><td style="text-align:center">编译/重新编译正则表达式，将 pattern 转换为内部格式，加快执⾏速度</td></tr><tr><td style="text-align:center">exec()</td><td style="text-align:center">检索字符串中指定的值。返回找到的值，并确定其位置；影响lastIndex 属性的值</td></tr><tr><td style="text-align:center">test()</td><td style="text-align:center">检索字符串中指定的值。返回 true 或 false；影响 lastIndex 属性的值</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO <span class="built_in">exec</span>() 方法，返回匹配的值，以及匹配的位置</span><br><span class="line">    TODO   * 返回的位置，与是否全局搜索无关，返回第一次匹配的位置</span><br><span class="line">    TODO   * 如果没有匹配到，返回 null</span><br><span class="line">    TODO <span class="built_in">test</span>() 方法，返回 <span class="literal">true</span> 或 <span class="literal">false</span></span><br><span class="line">*/</span><br><span class="line">var reg = /abc/;</span><br><span class="line">var str = <span class="string">'abcdefgabcdefg'</span>;</span><br><span class="line">console.log(reg.exec(str)); // [ <span class="string">'abc'</span>, index: 0, input: <span class="string">'abcdefgabcdefg'</span> ]</span><br><span class="line">console.log(reg.test(str)); // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">reg = /abc/g;</span><br><span class="line">console.log(reg.exec(str)); // [ <span class="string">'abc'</span>, index: 0, input: <span class="string">'abcdefgabcdefg'</span> ]</span><br><span class="line">str = <span class="string">'dddd'</span>;</span><br><span class="line">console.log(reg.exec(str)); // null</span><br></pre></td></tr></table></figure><h2 id="字符串的模式匹配"><a href="#字符串的模式匹配" class="headerlink" title="字符串的模式匹配"></a>字符串的模式匹配</h2><p>String对象提供了如下几种方法，用于匹配正则表达式</p><h3 id="替换字符串replace"><a href="#替换字符串replace" class="headerlink" title="替换字符串replace()"></a>替换字符串replace()</h3><p>replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p><p>语法</p><pre><code>stringObject.replace(regexp/substr,replacement)</code></pre><p>参数</p><ul><li>regexp/substr：必需。规定子字符串或要替换的模式的 RegExp 对象。</li><li>replacement：必需。一个字符串值。规定了替换文本或生成替换文本的函数。</li></ul><p>返回值<br>一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO replace返回替换后的字符串</span><br><span class="line">    TODO 原字符串不变</span><br><span class="line"> */</span><br><span class="line">var str = <span class="string">'hello world'</span>;</span><br><span class="line">var reg = /o/g;</span><br><span class="line">console.log(str.replace(reg,<span class="string">'e'</span>)); // helle werld</span><br><span class="line">console.log(str); // hello world</span><br></pre></td></tr></table></figure><h3 id="匹配字符串match"><a href="#匹配字符串match" class="headerlink" title="匹配字符串match()"></a>匹配字符串match()</h3><p>match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。</p><p>语法</p><pre><code>stringObject.match(searchvalue)stringObject.match(regexp)</code></pre><p>参数</p><ul><li>searchvalue：必需。规定要检索的字符串值。</li><li>regexp：必需。规定要匹配的模式的 RegExp 对象。如果该参数不是 RegExp 对象，则需要首先把它传递给 RegExp 构造函数，将其转换为 RegExp 对象。</li></ul><p>返回值<br>存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO match 返回匹配到的值的数组</span><br><span class="line">    TODO 原字符串不变</span><br><span class="line">    TODO 没有匹配，返回 null</span><br><span class="line"> */</span><br><span class="line">var str = <span class="string">'hello world'</span>;</span><br><span class="line">var reg1 = /o/;</span><br><span class="line">var reg2 = /o/g;</span><br><span class="line">var reg3 = /q/;</span><br><span class="line">console.log(str.match(reg1)); // [ <span class="string">'o'</span>, index: 4, input: <span class="string">'hello world'</span> ]</span><br><span class="line">console.log(str.match(reg2)); // [ <span class="string">'o'</span>, <span class="string">'o'</span> ]</span><br><span class="line">console.log(str.match(reg3)); // null</span><br><span class="line">console.log(str); // hello world</span><br></pre></td></tr></table></figure><h3 id="查找字符串search"><a href="#查找字符串search" class="headerlink" title="查找字符串search()"></a>查找字符串search()</h3><p>search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。</p><p>语法</p><pre><code>stringObject.search(regexp)</code></pre><p>参数</p><ul><li>regexp：该参数可以是需要在 stringObject 中检索的子串，也可以是需要检索的 RegExp 对象。</li></ul><p>返回值<br>stringObject 中第一个与 regexp 相匹配的子串的起始位置。<br>注释：如果没有找到任何匹配的子串，则返回 -1。</p><p>说明<br>search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">    TODO search方法返回第一次匹配到的索引</span><br><span class="line">    TODO 原字符串不变</span><br><span class="line"> */</span><br><span class="line">var str = <span class="string">'hello world'</span>;</span><br><span class="line">var reg1 = /o/g;</span><br><span class="line">console.log(str.search(reg1)); // 4</span><br><span class="line">console.log(str); // hello world</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript对象</title>
      <link href="/javascript%E5%AF%B9%E8%B1%A1/"/>
      <url>/javascript%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><p>Javascript是基于原型的面向对象的语言（ECMAScript 5版本）。<br>在Javascript中，一个对象可以是一个单独的拥有属性和类型的实体。对象具有属性和方法。属性用来描述这个对象的信息，方法用来描述这个对象的行为。<br>方法是关联到某个对象的函数，或者简单来说，一个方法是一个值为某个函数的对象属性。定义方法就像定义普通的函数。<br><a id="more"></a></p><h1 id="对象分类"><a href="#对象分类" class="headerlink" title="对象分类"></a>对象分类</h1><p><b>· 内置对象/原生对象</b><br>就是javascript语言预定义的对象。在ECMAScript标准定义，由javascript解释器/引擎提供具体实现。<br><b>· 宿主对象</b><br>指的是javascript运行环境提供的对象。一般是由浏览器厂商提供实现（目前也有独立的javascript解释器/引擎提供实现），主要分为BOM和DOM。<br><b>· 自定义对象</b><br>由开发人员自主创建的对象。</p><h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><h2 id="（一）对象初始化器方式"><a href="#（一）对象初始化器方式" class="headerlink" title="（一）对象初始化器方式"></a>（一）对象初始化器方式</h2><p>使用对象初始化器也被称为通过字面值创建对象。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// obj 为创建的对象名</span><br><span class="line">var obj = &#123;</span><br><span class="line">    // property 为属性或方法名，value 为属性值或函数</span><br><span class="line">    property1: value1, </span><br><span class="line">    property2: value2,</span><br><span class="line">    ...</span><br><span class="line">    propertyn: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        // 方法体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（二）构造函数方式"><a href="#（二）构造函数方式" class="headerlink" title="（二）构造函数方式"></a>（二）构造函数方式</h2><h3 id="javascript预定义类型的构造函数"><a href="#javascript预定义类型的构造函数" class="headerlink" title="javascript预定义类型的构造函数"></a>javascript预定义类型的构造函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var date = new Date(); //创建一个Date对象</span><br><span class="line">var str = new String(<span class="string">"this is string"</span>); //创建一个String对象</span><br><span class="line">var num = new Number(100); //创建一个Number对象</span><br></pre></td></tr></table></figure><h3 id="Object类型的构造函数"><a href="#Object类型的构造函数" class="headerlink" title="Object类型的构造函数"></a>Object类型的构造函数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object(); //创建一个自定义对象</span><br><span class="line">obj.property1 = value1; //对象属性</span><br><span class="line">obj.property2 = <span class="function"><span class="title">function</span></span>()&#123; //对象方法</span><br><span class="line">    //方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="（三）Object-create-方法"><a href="#（三）Object-create-方法" class="headerlink" title="（三）Object.create()方法"></a>（三）Object.create()方法</h2><p>Object.create()方法创建一个拥有指定原型和若干个指定属性的对象。</p><pre><code>Object.create(proto, [propertiesObject])</code></pre><p>参数：<br>    · proto参数：一个对象，作为新创建对象的原型。<br>    · propertiesObject参数：可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 先创建一个作为原型的对象</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    name : <span class="string">'protoObject'</span>,</span><br><span class="line">    sayMe: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">'this is protoObject'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 通过Object.create()方法创建对象</span><br><span class="line">// obj2 拥有与 obj1 相同的属性和方法</span><br><span class="line">var obj2 = Object.create(obj1);</span><br></pre></td></tr></table></figure><p><b>Object.create()方法的一些特殊用法</b></p><p>（1）创建一个原型为null的空对象</p><pre><code>var obj = Object.create( null );</code></pre><p>（2）实现子类型构造函数的原型继承父类型构造函数的原型</p><pre><code>Sub.prototype = Object.create( Super.prototype );</code></pre><p>（3）创建普通空对象</p><pre><code>var obj = Object.create( Object.prototype ); // 等同于 var obj = {}</code></pre><h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><h2 id="定义对象的属性"><a href="#定义对象的属性" class="headerlink" title="定义对象的属性"></a>定义对象的属性</h2><p>一个javascript对象有很多属性。一个对象的属性可以被解释成一个附加到对象上的变量。对象的属性和普通的javascript变量基本没什么区别，仅仅是属性属于某个对象。</p><p>定义属性的方法：<br>1、通过点符号</p><pre><code>obj.attrName = value;</code></pre><p>2、通过方括号。对象有时也被称为关联数组，因为每个属性都有一个用于访问它的字符串值。</p><pre><code>obj[attrName] = value;</code></pre><h2 id="访问对象的属性"><a href="#访问对象的属性" class="headerlink" title="访问对象的属性"></a>访问对象的属性</h2><p>与定义属性类似，访问属性同样可以通过 点符号 和 方括号 两种方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var emp = &#123;</span><br><span class="line">    ename: <span class="string">'Tom'</span>;</span><br><span class="line">    salary: 3500</span><br><span class="line">&#125;</span><br><span class="line">console.log( emp.ename ); // 点符号 方式</span><br><span class="line">console.log( emp[<span class="string">'salary'</span>] ); // 中括号 方式，属性名需要用单引号或双引号括起来</span><br></pre></td></tr></table></figure><h2 id="遍历（枚举）属性"><a href="#遍历（枚举）属性" class="headerlink" title="遍历（枚举）属性"></a>遍历（枚举）属性</h2><p>javascript提供了三种原生方法用于遍历或枚举对象的属性。</p><h3 id="（一）for…in循环"><a href="#（一）for…in循环" class="headerlink" title="（一）for…in循环"></a>（一）for…in循环</h3><p>该方法依次访问一个<em>对象及其原型链</em>中所有可枚举的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name : <span class="string">'杨过'</span>,</span><br><span class="line">    sex : <span class="string">'man'</span>,</span><br><span class="line">    sayMe : <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">        console.log(<span class="string">'我是杨过'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (var attrName <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    console.log(attrName + <span class="string">'='</span> + obj[attrName]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（二）Object-keys-object-方法"><a href="#（二）Object-keys-object-方法" class="headerlink" title="（二）Object.keys( object ) 方法"></a>（二）Object.keys( object ) 方法</h3><p>该方法返回一个对象自身包含（不包括原型中）的所有属性的名称的数组。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var attrs = Object.keys(obj);</span><br><span class="line">console.log(attrs); // 包含所有属性名称的数组</span><br><span class="line">console.log(attrs[0]); // name</span><br><span class="line">console.log(obj[attrs[0]]); // 杨过</span><br><span class="line">//遍历该数组</span><br><span class="line"><span class="keyword">for</span> (var i=0; i&lt;attrs.length; i++)&#123;</span><br><span class="line">    console.log(attrs[i], obj[attrs[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="（三）Object-getOwnPropertyNames-object-⽅法"><a href="#（三）Object-getOwnPropertyNames-object-⽅法" class="headerlink" title="（三）Object.getOwnPropertyNames( object ) ⽅法"></a>（三）Object.getOwnPropertyNames( object ) ⽅法</h3><p>该方法返回一个数组，它包含了一个对象（不包括原型中）所有拥有的属性（无论是否可枚举）的名称。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var attrs = Object.getOwnPropertyNames(obj);</span><br></pre></td></tr></table></figure><h2 id="属性访问出错"><a href="#属性访问出错" class="headerlink" title="属性访问出错"></a>属性访问出错</h2><p>当不确定对象是否存在、对象的属性是否存在时，可以使用错误处理结构 try…catch 语句来捕捉抛出的错误，避免程序异常终止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 访问未声明的变量</span><br><span class="line">console.log( emp ); // ReferenceError</span><br><span class="line"></span><br><span class="line">// 访问未声明的属性</span><br><span class="line">var emp = &#123;&#125;;</span><br><span class="line">console.log( emp.ename ); // undefined</span><br><span class="line"></span><br><span class="line">// 访问未声明的属性的成员</span><br><span class="line">console.log( emp.ename.length ); // TypeError</span><br></pre></td></tr></table></figure><h2 id="检测属性是否存在"><a href="#检测属性是否存在" class="headerlink" title="检测属性是否存在"></a>检测属性是否存在</h2><p>可以使用如下四种方法检测对象中是否存在指定属性：</p><h3 id="1-使用-in-关键字"><a href="#1-使用-in-关键字" class="headerlink" title="1.使用 in 关键字"></a>1.使用 in 关键字</h3><pre><code>console.log( &apos;ename&apos; in emp );</code></pre><h3 id="2-使用Object对象的hasOwnProperty-方法"><a href="#2-使用Object对象的hasOwnProperty-方法" class="headerlink" title="2.使用Object对象的hasOwnProperty()方法"></a>2.使用Object对象的hasOwnProperty()方法</h3><pre><code>console.log( emp.hasOwnProperty(&apos;ename&apos;) );</code></pre><h3 id="3-使用-undefined-进行判断"><a href="#3-使用-undefined-进行判断" class="headerlink" title="3.使用 undefined 进行判断"></a>3.使用 undefined 进行判断</h3><pre><code>console.log( emp.ename == undefined );</code></pre><h3 id="4-使用if语句进行判断"><a href="#4-使用if语句进行判断" class="headerlink" title="4.使用if语句进行判断"></a>4.使用if语句进行判断</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( emp.ename )&#123;</span><br><span class="line">    console.log(<span class="string">'ename属性存在'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h2><p>可以使用 delete 操作符删除一个不是继承而来的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    a: 5,</span><br><span class="line">    b: 10</span><br><span class="line">&#125;</span><br><span class="line">delete obj.a;</span><br></pre></td></tr></table></figure><h1 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h1><h2 id="定义对象的方法"><a href="#定义对象的方法" class="headerlink" title="定义对象的方法"></a>定义对象的方法</h2><p>定义方法就像定义普通的函数，除了它们必须被赋给对象的某个属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj1 = &#123;</span><br><span class="line">    name: <span class="string">'obj1'</span>,</span><br><span class="line">    sayMe: <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">        console.log(<span class="string">'this is obj1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj2 = new Object();</span><br><span class="line">obj2.sayMe = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'this is obj2'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><p>对象方法的调用类似于对象属性的调用，同样具有 点符号 和 方括号 两种方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj1.sayMe(); // 点符号方式</span><br><span class="line">obj2[<span class="string">'sayMe'</span>](); // 方括号方式</span><br></pre></td></tr></table></figure><h2 id="删除对象的方法"><a href="#删除对象的方法" class="headerlink" title="删除对象的方法"></a>删除对象的方法</h2><p>同样使用delete关键字</p><pre><code>delete obj1.sayMe;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 对象 </tag>
            
            <tag> 创建对象 </tag>
            
            <tag> 遍历对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的Date类型</title>
      <link href="/javascript%E4%B8%AD%E7%9A%84Date%E7%B1%BB%E5%9E%8B/"/>
      <url>/javascript%E4%B8%AD%E7%9A%84Date%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>javascript中提供Date对象对日期和时间进行存储或操作。</p><h2 id="创建Date对象"><a href="#创建Date对象" class="headerlink" title="创建Date对象"></a>创建Date对象</h2><pre><code>var myDate = new Date();</code></pre><a id="more"></a><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 使⽤指定的年⽉⽇ [时分秒] 进⾏初始化</span><br><span class="line"> Date对象中月份从0开始，所以月比传入的值加了1</span><br><span class="line">*/</span><br><span class="line">var d = new Date(2017,6,8);</span><br><span class="line">console.log(d.toLocaleDateString()); // 2017-07-08</span><br><span class="line"></span><br><span class="line">var d2 = new Date(2017,6,8,16,58,30);</span><br><span class="line">console.log(d2.toLocaleString()); // 2017-07-08 16:58:30</span><br><span class="line"></span><br><span class="line">// 把string转换为Date</span><br><span class="line">var d3 = new Date(<span class="string">'2017-6-8'</span>);</span><br><span class="line">console.log(d3.toLocaleDateString()); // 2017-06-08</span><br><span class="line"></span><br><span class="line">// new Date() 小括号可省略</span><br><span class="line">var d4 = new Date;</span><br><span class="line">console.log(d4.toLocaleDateString()); // 2017-06-08</span><br><span class="line"></span><br><span class="line">// 构建⼀个string，值为当前系统时间</span><br><span class="line">var d5 = Date();</span><br><span class="line">console.log(d5); // Thu Jun 08 2017 17:03:35 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(typeof d5); // string</span><br><span class="line"></span><br><span class="line">// 初始化为距离计算机元年指定毫秒数的时间</span><br><span class="line">var d6 = new Date(0) ;</span><br><span class="line">console.log(d6.toLocaleDateString()); // 1970-01-01</span><br><span class="line">var d7 = new Date( 1000*3600*24*365 ) ;</span><br><span class="line">console.log(d7.toLocaleDateString()); // 1971-01-01</span><br></pre></td></tr></table></figure><style>    table th:first-child {        width: 150px;    }</style><h2 id="获取日期方法"><a href="#获取日期方法" class="headerlink" title="获取日期方法"></a>获取日期方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>getDate( )</td><td>返回Date对象“⽇期”部分数值(1 ~ 31)。</td></tr><tr><td>getDay( )</td><td>返回Date对象“星期”部分的数值(0 ~ 6)。</td></tr><tr><td>getFullYear( )</td><td>返回Date对象“年份”部分的实际数值。</td></tr><tr><td>getHours( )</td><td>返回Date对象“⼩时”部分的数值(0 ~ 23)。</td></tr><tr><td>getMilliseconds( )</td><td>返回Date对象“毫秒”部分的数值(0 ~ 999)。</td></tr><tr><td>getMinutes( )</td><td>返回Date对象“分钟”部分的数值(0 ~ 59)。</td></tr><tr><td>getMonth( )</td><td>返回Date对象“⽉份”部分的数值(0 ~ 11)。</td></tr><tr><td>getSeconds( )</td><td>返回Date对象“秒”部分的数值(0 ~ 59)。</td></tr><tr><td>getTime( )</td><td>返回Date对象与UTC时间1970年1 ⽉ 1 ⽇午夜之间相差的毫秒数。</td></tr></tbody></table><h2 id="设置日期方法"><a href="#设置日期方法" class="headerlink" title="设置日期方法"></a>设置日期方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>setDate( )</td><td>设置Date对象中“⽇期”部分的数值(1 ~ 31 ，但不限于)。</td></tr><tr><td>setFullYear( )</td><td>设置Date对象中“年份”部分的实际数值。</td></tr><tr><td>setHours( )</td><td>设置Date对象中“⼩时”部分的数值(0 ~ 23，但不限于)。</td></tr><tr><td>setMilliseconds( )</td><td>设置Date对象中“毫秒”部分的数值(0 ~ 999，但不限于)。</td></tr><tr><td>setMinutes( )</td><td>设置Date对象中“分钟”部分的数值(0 ~ 59，但不限于)。</td></tr><tr><td>setMonth( )</td><td>设置Date对象中“⽉份”部分的数值(0 ~ 11 ，但不限于)。</td></tr><tr><td>setSeconds( )</td><td>设置Date对象中“秒”部分的数值(0 ~ 59，但不限于)。</td></tr><tr><td>setTime( )</td><td>以毫秒值设置Date对象。</td></tr><tr><td>setDate( )</td><td>设置Date对象中“⽇期”部分的数值(1 ~ 31 ，但不限于)。</td></tr></tbody></table><h2 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>toString()</td><td>返回Date对象的字符串形式。</td></tr><tr><td>toDateString()</td><td>返回Date对象“⽇期”部分(年⽉⽇ )的字符串形式。</td></tr><tr><td>toTimeString()</td><td>返回Date对象“时间”部分(时分秒)的字符串形式。</td></tr><tr><td>toLocaleString()</td><td>基于本地时间格式，返回Date对象的字符串形式。</td></tr><tr><td>toLocaleDateString()</td><td>基于本地时间格式，返回Date对象“ ⽇期”部分(年⽉⽇ )的字符串形式。</td></tr><tr><td>toLocaleTimeString()</td><td>基于本地时间格式，返回Date对象“时间”部分(时分秒)的字符串形式。</td></tr><tr><td>toGMTString()</td><td>基于GMT时间格式，返回Date对象的字符串形式。</td></tr><tr><td>toUTCString()</td><td>基于UTC时间格式，返回Date对象的字符串形式。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> Date </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中的特殊函数</title>
      <link href="/javascript%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/"/>
      <url>/javascript%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="特殊函数"><a href="#特殊函数" class="headerlink" title="特殊函数"></a>特殊函数</h2><p>JavaScript中拥有5种特殊函数：内部函数、匿名函数、自调函数、回调函数、作为值的函数。<br><a id="more"></a></p><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><p>在指定函数中定义的函数，详见 “作用域” 篇。</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>javascript可以将函数作为数据使用。作为函数主体，它像普通的数据一样，不一定要有名字。默认名字的函数被称之为匿名函数。如下：</p><pre><code>function (a){return a;}</code></pre><p>匿名函数的两种用法：</p><ul><li>回调函数：可以将匿名函数作为参数传递给其他函数。接收方函数能够利用所传递的函数来完成某些事情。</li><li>自调函数：定义匿名函数来执行某些一次性任务。</li></ul><h3 id="自调函数"><a href="#自调函数" class="headerlink" title="自调函数"></a>自调函数</h3><p>自调函数就是函数在定义后自行调用，自调函数只能被调用一次，可以用来做代码优化，节省全局的命名空间。</p><p>自调函数语法结构：</p><ul><li>(function(形参){函数体})(实参)<br>  两对并列小括号，第一对小括号放置一个匿名函数，第二对小括号的作用为“立即调用”</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'这是第一种自调函数'</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><ul><li>(function(形参){函数体}(实参))<br>  与第一种方式类似，同样是两对小括号，不同的是，第二个小括号放在第一个小括号里面，放置在函数体后面。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(str)&#123;</span><br><span class="line">    console.log(<span class="string">'hello'</span> + str);</span><br><span class="line">&#125;(<span class="string">'world'</span>))</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>当一个函数作为参数传递给另一个函数时，作为参数的函数被称之为回调函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> add(a, b)&#123;</span><br><span class="line">    <span class="built_in">return</span> a() + b();</span><br><span class="line">&#125;</span><br><span class="line">var one = <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> 1;&#125;</span><br><span class="line">var two = <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> 2;&#125;</span><br><span class="line">console.log(add(one, two)); // 输出 3</span><br><span class="line">// 可以直接使用匿名函数来替代one和two，以作为目标函数的参数</span><br><span class="line">console.log(add(<span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> 1;&#125;, <span class="function"><span class="title">function</span></span>()&#123;<span class="built_in">return</span> 2;&#125;));</span><br></pre></td></tr></table></figure><p>上述代码中，函数one和two都作为函数add()的参数传递。所以函数one()和two()都是回调函数。<br>如果回调函数是一个匿名函数，就称之为匿名回调函数。</p><p>回调函数的优点：</p><ul><li>它可以在不做命名的情况下传递函数（这意味着可以节省全局变量）。</li><li>可以将一个函数的调用操作委托给另一个函数。</li><li>回调函数也有助于提升性能。</li></ul><h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>将一个函数作为另一个函数的结果进行返回，作为结果返回的函数称之为作为值的函数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(args)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="keyword">function</span> <span class="function"><span class="title">add</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> args + 10;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f = fn(20);</span><br><span class="line">console.log(f()); // 输出 30</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 自调函数 </tag>
            
            <tag> 回调函数 </tag>
            
            <tag> 作为值的函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript作用域</title>
      <link href="/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>　　变量和函数都具有作用域。作用域就是变量和函数的可被访问的范围，控制着变量和函数的可见性和生命周期。<br>　　ES5 中的作用域可被分为全局作用域和函数作用域（局部作用域）。如果变量或函数是被定义在全局作用域的话，在javascript代码中的任何位置都可以访问；如果被定义在函数内部的话，只能在该函数内访问。<br><a id="more"></a></p><blockquote><p>注意：ECMAScript6 之前的javascript没有语句块作用域。</p></blockquote><h2 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h2><ul><li>生命周期：全局作用域在页面打开时创建，在页面关闭时销毁。</li><li>所有在 script 标签中直接编写的内容都在全局作用域。</li><li>在全局作用域中有一个全局对象 window<br>  – window代表的是整个浏览器窗口<br>  – 在全局作用域中创建的变量都会作为window对象的属性保存<br>  – 在全局作用域中创建的函数都会作为window对象的方法保存</li><li>在全局作用域中创建的变量和函数可以在整个页面中使用<br>  – 在全局作用域中创建的变量称为全局变量</li><li>在函数中，不使用 var 关键字声明变量，该变量会默认成为全局变量<br>  – 会造成作用域内变量混乱，不建议使用</li></ul><p><strong>全局变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var msg = <span class="string">'this is message'</span>; // 定义全局变量 msg</span><br><span class="line">//在全局作用域访问变量 msg</span><br><span class="line">console.log(msg); // 输出 this is message</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">    //在函数作用域访问变量 msg</span><br><span class="line">    console.log(msg); // 输出 this is message</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p><p><strong>函数内部不使用var关键字定义全局变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">    // 定义变量没有使用var关键字</span><br><span class="line">    str = <span class="string">'this is string'</span>;</span><br><span class="line">    // 在函数作用域访问变量 str</span><br><span class="line">    console.log(str); // 输出 this is string</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line">// 在全局作用域访问变量 str</span><br><span class="line">console.log(str); // 输出 this is string</span><br></pre></td></tr></table></figure></p><p><strong>全局函数</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(num1, num2)&#123;</span><br><span class="line">    console.log(num1 + num2);</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2); // 输出 3</span><br></pre></td></tr></table></figure></p><h2 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h2><p>每调用一次函数，就会创建一个新的函数作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fun()&#123;</span><br><span class="line">&#125;</span><br><span class="line">创建函数，没有创建函数作用域</span><br><span class="line">fun();</span><br><span class="line">调用函数，创建一个新的函数作用域</span><br></pre></td></tr></table></figure><ul><li>生命周期：函数作用域在<strong>函数调用</strong>时创建，在函数调用结束时销毁。</li><li>在函数作用域，可以访问全局变量。</li><li>在函数作用域中定义的变量称为局部变量，在全局中无法访问局部变量<br>  – 在函数作用域中，如果不使用 var 关键字来声明变量，则该变量将会变为全局变量（避免这样使用）。</li><li>当我们在函数作用域中，使用一个变量时，会先在自身作用域中寻找<br>  – 如果找到了，则直接使用<br>  – 如果没找到，则去上一级作用域中寻找，直到找到为止<br>  – 如果找到全局作用域中，依然没有，则会报错</li><li>如果需要在函数中访问全局变量，也可以使用 window 来访问。</li></ul><p><strong>局部变量</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>()&#123;</span><br><span class="line">    // 定义局部变量 str</span><br><span class="line">    var str = <span class="string">"this is string"</span>;</span><br><span class="line">    // 在函数作用域访问变量 str</span><br><span class="line">    console.log(str); // 输出 this is string</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line">// 在全局作用域访问变量 str</span><br><span class="line">console.log(str); // 输出报错</span><br></pre></td></tr></table></figure></p><p><strong>局部函数</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">outer</span></span>()&#123; // 全局函数</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">inner</span></span>()&#123; // 局部函数</span><br><span class="line">        console.log(<span class="string">"inner"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    inner(); // 调用正常</span><br><span class="line">&#125;</span><br><span class="line">inner(); // 报错</span><br></pre></td></tr></table></figure></p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>JavaScript是基于词法作用域的语言，通过阅读包含变量定义在内的数行源码就能知道变量的作用域。全局变量在程序中始终都是有定义的。局部变量在声明它的函数体内以及其所嵌套的函数内始终是有定义的。</p><p>一个函数 fn <strong>被创建后</strong>，fn 对象内部具有隐含属性 scope（作用域链），scope 是一个数组，该数组中包含函数 fn 的作用域链中的各个对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，全局函数对象 fn 的 scope 属性中，只具有一个对象 window，在 fn 中使用变量时，若 fn 中不存在该变量，则沿着 scope 中的变量对象查找，即在 window 中查找。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn1</span></span>()&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">fn2</span></span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，局部函数对象 fn2 的 scope 属性中，具有两个对象，分别是 fn1 的闭包对象和 window，fn2 中使用的变量，若自身没有，则在 fn1 中找，还没有，在 window 中找。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 作用域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript函数</title>
      <link href="/javascript%E5%87%BD%E6%95%B0/"/>
      <url>/javascript%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="函数的定义与使用"><a href="#函数的定义与使用" class="headerlink" title="函数的定义与使用"></a>函数的定义与使用</h1><p>函数是指一段javascript代码，只需要定义一次，就可以被多次执行或调用。简单来说，函数就是一组可重用的代码。</p><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><a id="more"></a><h3 id="1-函数声明方式"><a href="#1-函数声明方式" class="headerlink" title="1. 函数声明方式"></a>1. 函数声明方式</h3><blockquote><p>function 函数名(参数列表){<br>    函数体<br>}</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'this is function);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-字面量（直接量）方式"><a href="#2-字面量（直接量）方式" class="headerlink" title="2. 字面量（直接量）方式"></a>2. 字面量（直接量）方式</h3><blockquote><p>var 函数名 = function(参数列表){<br>    函数体<br>}</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fun = <span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">'this is function);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>定义一个函数并不会自动执行函数，仅仅是赋予了函数名称以及明确函数被调用时该做些什么。调用函数才会真正执行这些动作。</p><p>调用函数的语法结构为： 函数名()</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun();</span><br></pre></td></tr></table></figure><h2 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h2><p>函数的参数是指定义函数时，小括号中的内容，参数可以在函数体中使用。javascript中的函数定义并未制定函数参数的类型，函数调用时也未对传入的参数做任何的类型检查。</p><p>函数的参数可以分为以下两种：</p><ul><li>形参</li></ul><p>出现在函数定义文法中的参数列表是函数的形式参数，简称形参。简单来说，就是定义函数时使用的参数。</p><ul><li>实参</li></ul><p>函数调用时实际传入的参数是函数的实际参数，简称形参。</p><ul><li>值得注意的是：<br>一般情况下，形参和实参的个数是相同的。但在javascript中，这一点并不强求，特殊情况下，函数形参和实参的个数可以不相同。形参和实参的匹配为从左到右一一对应。遗漏的参数将得到undefined，多余的参数将忽略。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(num1, num2)&#123;    // num1 和 num2 是形参</span><br><span class="line">    console.log( num1 + num2 );</span><br><span class="line">&#125;</span><br><span class="line">fn(1, 2); // 1和2是实参， 输出 3</span><br></pre></td></tr></table></figure><h2 id="函数返回值-–-return语句"><a href="#函数返回值-–-return语句" class="headerlink" title="函数返回值 – return语句"></a>函数返回值 – return语句</h2><p>函数还可以包含一个返回语句（return）。return并不是必需的。return语句使函数可以作为一个值来使用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> fn(msg)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="string">"hello"</span> + msg;</span><br><span class="line">&#125;</span><br><span class="line">var res = fn(<span class="string">"world"</span>);  // 变量res的值为 helloworld</span><br></pre></td></tr></table></figure><ul><li>注意：不明确return或return关键字后面没有内容时，默认返回undefined。</li></ul><h2 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h2><h3 id="替代形参"><a href="#替代形参" class="headerlink" title="替代形参"></a>替代形参</h3><p>在函数代码中，使用arguments对象，无需指明形参参数名，就可以访问传入的实参。</p><p>使用方式为：arguments[index]，index从0开始。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">    <span class="built_in">return</span> arguments[0] + arguments[1];</span><br><span class="line">&#125;</span><br><span class="line">fn(2, 3); // 结果为 5</span><br></pre></td></tr></table></figure><h3 id="检测参数个数"><a href="#检测参数个数" class="headerlink" title="检测参数个数"></a>检测参数个数</h3><p>通过arguments.length属性，可以得到传入的参数的个数。</p><h3 id="模拟函数的重载效果"><a href="#模拟函数的重载效果" class="headerlink" title="模拟函数的重载效果"></a>模拟函数的重载效果</h3><p>用arguments对象判断传入的参数个数，可以模拟函数重载效果。</p><h1 id="预定义函数"><a href="#预定义函数" class="headerlink" title="预定义函数"></a>预定义函数</h1><p>javascript预定义了一组函数，又称为全局函数，允许直接使用。</p><h3 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h3><p>eval()函数用于执行以字符串（String）形式出现的javascript代码。此函数可以动态的执行javascript代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个字符串，内容为javascript代码</span><br><span class="line">var js = <span class="string">'console.log("this is javascript")'</span>;</span><br><span class="line">// 通过<span class="built_in">eval</span>()函数执行上述内容</span><br><span class="line"><span class="built_in">eval</span>(js); // 输出 this is javascript</span><br></pre></td></tr></table></figure><h3 id="字符编码与解码"><a href="#字符编码与解码" class="headerlink" title="字符编码与解码"></a>字符编码与解码</h3><p>encodeURI()函数可把字符串作为URI进行编码。对以下在URI中具有特殊含义的ASCII标点符号，encodeURI()函数是不会进行转义的：</p><pre><code>, / ? : @ &amp; = + $ #</code></pre><p>decodeURI()函数可对encodeURI()函数编码过的URI进行解码。<br>decodeURI()函数和encodeURI()函数主要针对中文进行编解码。<br>对于在URI中具有特殊含义的ASCII标点符号，可以使用encodeURIComponent()函数和decodeURIComponent()函数。</p><h3 id="uneval"><a href="#uneval" class="headerlink" title="uneval()"></a>uneval()</h3><p>创建一个Object的源代码的字符串表示。</p><h3 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h3><p>判断传入的值是否是有限的数值。</p><h3 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h3><p>判断一个值是否为数字。</p><h3 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h3><p>解析字符串参数，并返回指定的整数。</p><h3 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h3><p>解析字符串参数，并返回一个浮点数。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> function </tag>
            
            <tag> 预定义函数 </tag>
            
            <tag> arguments </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript变量和函数声明提前</title>
      <link href="/javascript%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/"/>
      <url>/javascript%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E6%8F%90%E5%89%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="变量声明提前"><a href="#变量声明提前" class="headerlink" title="变量声明提前"></a>变量声明提前</h3><ul><li>javascript变量具有两种作用域：<br>  a 全局作用域<br>  b 函数作用域</li><li>变量在声明它们的脚本或函数中都是有定义的，变量的声明会“被提前”至脚本或函数的顶部</li><li>变量赋值不会提前<a id="more"></a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.log(a); //变量声明提前，因此这里得到undefined</span><br><span class="line">var a = <span class="string">'string1'</span>;</span><br><span class="line">console.log(a); //这里得到 string1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn</span></span>()&#123;</span><br><span class="line">    /*</span><br><span class="line">        这里输出a得到undefined</span><br><span class="line">        下面一行代码定义了一个局部变量a，由于声明提前，局部变量a在整个函数作用域都可以被找到，所以得到undefined</span><br><span class="line">    */</span><br><span class="line">    console.log(a); </span><br><span class="line">    var a = <span class="string">'string2'</span>;</span><br><span class="line">    console.log(a); // string2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数声明提前"><a href="#函数声明提前" class="headerlink" title="函数声明提前"></a>函数声明提前</h3><ul><li>定义函数有两种方式：<br>  a 函数声明语句 – function fn(){}<br>  b 表达式方式 – var fn = function(){}</li><li>函数声明语句定义的函数“被提前”到外表脚本或外部函数作用域的顶部<br>  以这种方式声明的函数，可以被在它定义之前出现的代码所调用。</li><li>以表达式方式定义的函数，与变量提前一样，只有声明提前，而函数创建不会提前，所以在定义之前不能被调用。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1(); // 可以执行</span><br><span class="line">fn2(); // 报错：函数fn2 is not a <span class="keyword">function</span></span><br><span class="line">console.log(fn2); // undefined -- 变量声明提前，得到undefined</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fn1</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">'这是函数声明语句定义的函数'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var fn2 = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">'这是表达式定义的函数'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数和变量同名"><a href="#函数和变量同名" class="headerlink" title="函数和变量同名"></a>函数和变量同名</h3><p>　　变量的声明和函数的创建是在JavaScript引擎预解析代码阶段执行的，所以代码在执行时，会发现变量和函数被提前了。<br>　　在预解析阶段，变量的声明先执行，后执行函数的创建，所以当变量和函数同名时，JavaScript引擎会先声明一个变量，此时值为undefined，再创建函数，函数会覆盖之前声明的变量。<br>　　所以，在变量被赋值的代码执行之前，可以直接调用函数，而变量赋值的代码执行后，变量的值会覆盖该函数，此时，再调用函数就会报错。</p>]]></content>
      
      
      <categories>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> 声明提前 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
