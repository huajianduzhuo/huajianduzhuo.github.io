<!doctype html>




<html class="theme-next mist" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">






<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="typescript,">





  <link rel="alternate" href="/atom.xml" title="勤，以随心" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">






<meta name="description" content="安装与使用全局安装 typescript npm install -g typescript">
<meta name="keywords" content="typescript">
<meta property="og:type" content="article">
<meta property="og:title" content="typescript学习笔记">
<meta property="og:url" content="http://mengyujing.com/typescript学习笔记/index.html">
<meta property="og:site_name" content="勤，以随心">
<meta property="og:description" content="安装与使用全局安装 typescript npm install -g typescript">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-11-27T17:00:17.012Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="typescript学习笔记">
<meta name="twitter:description" content="安装与使用全局安装 typescript npm install -g typescript">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://mengyujing.com/typescript学习笔记/">





  <title>typescript学习笔记 | 勤，以随心</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  















  
  
    
  
  
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">勤，以随心</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-games">
          <a href="/games" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-gamepad"></i> <br>
            
            游戏
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://mengyujing.com/typescript学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="孟玉晶">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="勤，以随心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">typescript学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-30T23:27:09+08:00">
                2018-06-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/typescript/" itemprop="url" rel="index">
                    <span itemprop="name">typescript</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
		  


          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"> 阅读</i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          
            <div class="post-wordcount">
              
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  14,420
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长</span>
                
                <span title="阅读时长">
                  62
                </span>
              
            </div>
           

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h2><p><strong>全局安装 typescript</strong></p>
<p><code>npm install -g typescript</code></p>
<a id="more"></a>
<p><strong>编译</strong></p>
<p>创建后缀名为 <code>.ts</code> 的文件，在该文件夹下，执行 <code>tsc 文件名</code>，得到编译后的 js 文件，运行该 js 文件</p>
<h2 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h2><p>在<strong>项目根目录</strong>创建 <code>tsconfig.json</code> 文件，用来指定编译选项</p>
<p>在拥有 tsconfig.json 文件的项目根目录下直接执行 <code>tsc</code>，则会将项目目录下所有符合条件的 typescript 文件进行编译。</p>
<p>执行 <code>tsc -w</code>，可以监视文件改动，文件保存后实时编译</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>配置介绍：<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/tsconfig-json.html</a></p>
<ul>
<li>compilerOptions：编译选项，详见下一节</li>
<li>files：[]，指定包含文件路径列表</li>
<li>include：[]，包含文件目录列表</li>
<li>exclude：[]，排除文件列表</li>
<li>extends：继承配置</li>
</ul>
<h3 id="编译选项"><a href="#编译选项" class="headerlink" title="编译选项"></a>编译选项</h3><p>编译选项：<a href="https://www.tslang.cn/docs/handbook/compiler-options.html" target="_blank" rel="noopener">https://www.tslang.cn/docs/handbook/compiler-options.html</a></p>
<ul>
<li>outDir：编译输出目录，默认与 typescript 文件同一目录</li>
<li>target：编译目标语言，默认’ES3’</li>
<li>removeComments：删除注释</li>
<li>strictNullChecks</li>
</ul>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/01-basicTypes.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/01-basicTypes.ts</a></p>
<h3 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: boolean = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: number = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: number = <span class="number">0xf00d</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: string = <span class="string">'bob'</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>两种定义方式</p>
<ul>
<li>类型[]</li>
<li>Array&lt;类型&gt;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list1: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<h3 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h3><p>元组：已知数量和类型的数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t1: [string, number, boolean]</span><br><span class="line">t1 = [<span class="string">'盖聂'</span>, <span class="number">10</span>, <span class="literal">true</span>]</span><br></pre></td></tr></table></figure>
<h3 id="枚举（enum）"><a href="#枚举（enum）" class="headerlink" title="枚举（enum）"></a>枚举（enum）</h3><ul>
<li>相当于为对象双向定义 key（编号） 和 value（值）</li>
<li>默认 key 从 0 开始</li>
<li>可以从某一个值开始指定起始编号</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">  RED,</span><br><span class="line">  GREEN,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color) <span class="comment">// &#123; '0': 'RED', '1': 'GREEN', '2': 'BLUE', RED: 0, GREEN: 1, BLUE: 2 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 枚举 enum 指定起始编号</span></span><br><span class="line">enum Color2 &#123;</span><br><span class="line">  RED = <span class="number">3</span>,</span><br><span class="line">  GREEN,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color2) <span class="comment">// &#123; '3': 'RED', '4': 'GREEN', '5': 'BLUE', RED: 3, GREEN: 4, BLUE: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 手动赋值</span></span><br><span class="line">enum Color3 &#123;</span><br><span class="line">  RED = <span class="number">3</span>,</span><br><span class="line">  GREEN = <span class="number">7</span>,</span><br><span class="line">  BLUE = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color3) <span class="comment">// &#123; '1': 'BLUE', '3': 'RED', '7': 'GREEN', RED: 3, GREEN: 7, BLUE: 1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从中间指定起始编号</span></span><br><span class="line">enum Color4 &#123;</span><br><span class="line">  RED,</span><br><span class="line">  GREEN = <span class="number">5</span>,</span><br><span class="line">  BLUE</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color4) <span class="comment">// &#123; '0': 'RED', '5': 'GREEN', '6': 'BLUE', RED: 0, GREEN: 5, BLUE: 6 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="any"><a href="#any" class="headerlink" title="any"></a>any</h3><p>不清楚变量类型，可以使用 any</p>
<p>any 类型，可以赋予任何类型的值，不进行类型检查</p>
<p><strong>any 与 Object 类型的异同点：</strong></p>
<ul>
<li>Object 类型也可以赋予任何类型的值</li>
<li>any 类型不进行类型检查，可以调用任意的方法</li>
<li>Object 类型进行类型检查，不能随意调用方法，即便赋予的值真的有这些方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> any1: any = <span class="string">'卫庄'</span></span><br><span class="line"><span class="keyword">let</span> obj1: <span class="built_in">Object</span> = <span class="string">'盖聂'</span></span><br><span class="line">any1.substring(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// obj1.substring(0) // 报错： [ts] Property 'substring' does not exist on type 'Object'.</span></span><br></pre></td></tr></table></figure>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>函数没有返回值时，其返回类型是 void</p>
<p>声明 void 类型的变量没有用，因为只能赋值为 undefined 和 null</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'no return function, type: void'</span>)</span><br><span class="line">  <span class="comment">// return null // strictNullChecks 为 true，报错 [ts] Type 'null' is not assignable to type 'void'</span></span><br><span class="line">  <span class="comment">// return</span></span><br><span class="line">  <span class="comment">// return undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let unusable: void = null // strictNullChecks 为 true，会报错</span></span><br></pre></td></tr></table></figure>
<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p>默认情况下，null 和 undefined 是所有类型的子类型。null 和 undefined 可以赋值给任何类型</p>
<p>strictNullChecks 为 true，null 和 undefined 只能赋值给 void 和他们的各自类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let u: undefined = null // 因为可以赋值给任何类型，strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="comment">// let n: null = undefined // strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="comment">// let un: number = undefined // strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="comment">// let ns: string = null // strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="keyword">let</span> uv: <span class="keyword">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><ul>
<li>表示的是那些永不存在的值的类型</li>
<li>never 类型是任何类型的子类型，也可以赋值给任何类型</li>
<li>没有类型是 never 的子类型或可以赋值给 never 类型</li>
<li>即使 any 也不可以赋值给 never</li>
<li>返回 never 的函数必须存在无法达到的终点</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: string</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>表示非原始类型，即除了 number, string, boolean, symbol, null, or undefined 之外的类型</p>
<p>strictNullChecks 不为 true 的情况下，null 和 undefined 为任何类型的子类型，所以可以通过类型检查</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: object</span>): <span class="title">void</span> </span>&#123;&#125;</span><br><span class="line">create(&#123; <span class="attr">name</span>: <span class="string">'卫庄'</span> &#125;)</span><br><span class="line"><span class="comment">// create(null) // strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="comment">// create(undefined) // strictNullChecks 为 true，会报错</span></span><br><span class="line"><span class="comment">// create(23) // 报错</span></span><br><span class="line"><span class="comment">// create(Symbol.for('a')) // 报错</span></span><br></pre></td></tr></table></figure>
<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>好比其它语言里的类型转换，但是不进行特殊的数据检查和解构</p>
<p>两种类型断言方式：</p>
<ul>
<li>&lt;类型&gt;变量</li>
<li>变量 as 类型</li>
</ul>
<blockquote>
<p>在 TypeScript 里使用 JSX 时，只有 as 语法断言是被允许的</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> val1: any = <span class="string">'卫庄'</span></span><br><span class="line"><span class="keyword">let</span> len1: number = (<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>val1).length</span></span><br><span class="line"><span class="xml">console.log(len1)</span></span><br><span class="line"><span class="xml">let val2: any = true</span></span><br><span class="line"><span class="xml">let len2: number = (val2 as string).length</span></span><br><span class="line"><span class="xml">console.log(len2) // undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/02-interface.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/02-interface.ts</a></p>
<p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约</p>
<p>我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。</p>
<blockquote>
<p>接口中每个属性后面不是逗号，而是分号，分号可省略</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printLabel</span>(<span class="params">labeledObj: LabelledValue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(labeledObj.label)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;</span><br><span class="line">  name: <span class="string">'盖聂'</span>,</span><br><span class="line">  label: <span class="string">'卫聂'</span></span><br><span class="line">&#125;</span><br><span class="line">printLabel(obj2)</span><br></pre></td></tr></table></figure>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>指非必需的属性，可存在可不存在</p>
<p><strong>定义</strong>：在属性名后加一个 ?</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">  label: string</span><br><span class="line">  name?: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>只读属性只有在对象创建时才能修改值</p>
<p><strong>定义</strong>：属性名前加 readonly</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">  readonly x: number</span><br><span class="line">  y: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;</span><br><span class="line"><span class="comment">//  p1.x = 30 // 报错</span></span><br><span class="line">p1.y = <span class="number">30</span></span><br></pre></td></tr></table></figure>
<h3 id="ReadonlyArray"><a href="#ReadonlyArray" class="headerlink" title="ReadonlyArray"></a>ReadonlyArray<t></t></h3><p>TypeScript 具有 ReadonlyArray<t> 类型，它与 Array<t> 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改</t></t></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;number&gt; = a</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span> <span class="comment">// error!</span></span><br><span class="line">ro.push(<span class="number">5</span>) <span class="comment">// error!</span></span><br><span class="line">ro.length = <span class="number">100</span> <span class="comment">// error!</span></span><br><span class="line">a = ro <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，可以看到就算把整个 ReadonlyArray 赋值到一个普通数组也是不可以的。但是你可以用类型断言重写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> number[]</span><br></pre></td></tr></table></figure>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><p>在 typescript 中，<strong>对象字面量</strong>会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。</p>
<p>如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string</span><br><span class="line">  width?: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  squareConfig: SquareConfig</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): </span>&#123; color: string; area: number &#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> square = &#123; <span class="attr">color</span>: <span class="string">'black'</span>, <span class="attr">area</span>: <span class="number">100</span> &#125;</span><br><span class="line">  <span class="keyword">if</span> (squareConfig.color) &#123;</span><br><span class="line">    square.color = squareConfig.color</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (squareConfig.width) &#123;</span><br><span class="line">    square.area = squareConfig.width * squareConfig.width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> square</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = createSquare(&#123;<span class="attr">yanse</span>: <span class="string">'lightblue'</span>, <span class="attr">width</span>: <span class="number">12</span>&#125;)</span><br><span class="line"><span class="comment">// 报错：'yanse' does not exist in type 'SquareConfig'.</span></span><br></pre></td></tr></table></figure>
<p><strong>绕过这些检查的方式：</strong></p>
<ul>
<li>使用类型断言</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> square = createSquare(&#123;<span class="attr">yanse</span>: <span class="string">'lightblue'</span>, <span class="attr">width</span>: <span class="number">12</span>&#125; <span class="keyword">as</span> SquareConfig)</span><br></pre></td></tr></table></figure>
<ul>
<li>为接口添加索引签名，表示该接口可以拥有任意数量的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface SquareConfig &#123;</span><br><span class="line">  color?: string</span><br><span class="line">  width?: number</span><br><span class="line">  [propName: string]: any <span class="comment">// 索引签名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将字面量对象赋值给一个变量，并使用变量</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> squareOption = &#123; <span class="attr">yanse</span>: <span class="string">'lightblue'</span>, <span class="attr">width</span>: <span class="number">12</span> &#125;</span><br><span class="line"><span class="keyword">const</span> square = createSquare(squareOption)</span><br></pre></td></tr></table></figure>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口不止可以描述具有属性的普通对象的外形，也可以描述函数的类型</p>
<p>接口描述函数类型，就像是一个只拥有参数列表和返回值类型的函数定义，参数列表里的每一个参数都要有名字和类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface SearchFunc &#123;</span><br><span class="line">  (source: string, <span class="attr">search</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySearch: SearchFunc</span><br><span class="line">mySearch = <span class="function"><span class="keyword">function</span>(<span class="params">source: string, search: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = source.search(search)</span><br><span class="line">  <span class="keyword">return</span> index &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数的参数名不需要与接口里定义的名字相匹配</li>
<li>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySearch2: SearchFunc</span><br><span class="line">mySearch2 = <span class="function"><span class="keyword">function</span>(<span class="params">src: string, sub: string</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = src.search(sub)</span><br><span class="line">  <span class="keyword">return</span> index &gt; <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>接口也可以描述可以通过索引得到的类型</p>
<p>具有索引签名，描述索引的类型，以及对应的返回值的类型</p>
<p>支持两种索引签名：数字、字符串</p>
<blockquote>
<p>数字索引的返回值必须是字符串索引返回值类型的子类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr: StringArray</span><br><span class="line">arr = [<span class="string">'卫庄'</span>, <span class="string">'盖聂'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>索引类型可以约束某一类型的属性的返回值类型。如下，因为 string 类型的属性设定了返回值类型为 string，所以属性 name 的返回值为 number 就会报错</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  [index: number]: string</span><br><span class="line">  [key: string]: string</span><br><span class="line">  name: number <span class="comment">// 报错：[ts] Property 'name' of type 'number' is not assignable to string index type 'string'.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将索引签名设置为只读，可以防止给索引赋值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface StringArray &#123;</span><br><span class="line">  readonly [index: number]: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr: StringArray</span><br><span class="line">arr = [<span class="string">'卫庄'</span>, <span class="string">'盖聂'</span>]</span><br><span class="line"><span class="comment">// arr[2] = "鲨齿" // 报错：数字索引签名只读</span></span><br></pre></td></tr></table></figure>
<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口也可以用来明确的强制一个类符合某种契约</p>
<p>类实现接口：<code>implements</code></p>
<p>接口定义类的方法：<code>方法名(参数列表)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface ClockInterface &#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="title">implements</span> <span class="title">ClockInterface</span> </span>&#123;</span><br><span class="line">  currentTime: <span class="built_in">Date</span></span><br><span class="line">  setTime(d: <span class="built_in">Date</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentTime = d</span><br><span class="line">  &#125;</span><br><span class="line">  getTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentTime</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
</blockquote>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><ul>
<li>接口也可以相互继承</li>
<li>一个接口可以继承多个接口</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">interface int1 &#123;</span><br><span class="line">  a: string;</span><br><span class="line">&#125;</span><br><span class="line">interface int2 &#123;</span><br><span class="line">  b: string;</span><br><span class="line">&#125;</span><br><span class="line">interface int3 extends int1, int2 &#123;</span><br><span class="line">  c: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> d: int3 = &#123;</span><br><span class="line">  c: <span class="string">'岑岑'</span>,</span><br><span class="line">  a: <span class="string">'灿灿'</span>,</span><br><span class="line">  b: <span class="string">'柒夜'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>接口可以描述多种类型</p>
<p>比如：一个对象同时作为对象和函数使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (start: number): string</span><br><span class="line">  interval: number</span><br><span class="line">  count: number</span><br><span class="line">  reset (): <span class="keyword">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span> (<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span>&gt;</span>function(start: number) &#123;</span></span><br><span class="line"><span class="xml">    counter.count = start</span></span><br><span class="line"><span class="xml">    return `The number is $&#123;counter.count&#125;`</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  counter.interval = 1</span></span><br><span class="line"><span class="xml">  counter.reset = function () &#123;</span></span><br><span class="line"><span class="xml">    counter.start = 0</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">  return counter</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">let counter = getCounter()</span></span><br><span class="line"><span class="xml">counter(10)</span></span><br></pre></td></tr></table></figure>
<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。</p>
<p>接口同样会继承到类的 private 和 protected 成员。这意味着这个接口类型只能被这个类或其子类所实现。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    private state: any;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface SelectableControl extends Control &#123;</span><br><span class="line">    select(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Control</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBox</span> <span class="keyword">extends</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Image</span> <span class="title">implements</span> <span class="title">SelectableControl</span> </span>&#123;</span><br><span class="line">    select() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/03-classes.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/03-classes.ts</a></p>
<blockquote>
<p>注意：typescript 中的类，与 ES6 中类的定义方式不一样，不能想当然的认为两种是一样的写法！！！</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeter</span> </span>&#123;</span><br><span class="line">  greeting: string</span><br><span class="line">  <span class="keyword">constructor</span>(msg: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.greeting = msg</span><br><span class="line">  &#125;</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello, '</span> + <span class="keyword">this</span>.greeting + <span class="string">'!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>派生类：子类；</p>
<p>基类：超类</p>
<p>派生类的构造函数里<strong>必须调用</strong> <code>super()</code>，即基类的构造函数。并且，必须在构造函数里<strong>访问 this 之前</strong>调用 super()。</p>
<p>派生类的构造函数仍然可以省略，会默认调用基类的构造函数。</p>
<p>派生类可以重写基类的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  move(discInMeters: number = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;discInMeters&#125;</span>m!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">  &#125;</span><br><span class="line">  move(discInMeters: number = <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'climb~~~'</span>)</span><br><span class="line">    <span class="keyword">super</span>.move(discInMeters)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dage: Animal = <span class="keyword">new</span> Cat(<span class="string">'大哥'</span>)</span><br><span class="line">dage.move(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>如上面定义变量 dage 的方法，dage 为 Cat 类的实例，但是类型可以是基类 Animal。</p>
<h3 id="修饰符-public"><a href="#修饰符-public" class="headerlink" title="修饰符 public"></a>修饰符 public</h3><p>public 是默认的修饰符，成员都默认为 public</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  public name: string</span><br><span class="line">  public <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  public move (discInMeters: number = <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> moved <span class="subst">$&#123;discInMeters&#125;</span>m!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修饰符-private"><a href="#修饰符-private" class="headerlink" title="修饰符 private"></a>修饰符 private</h3><p>当成员被标记成 private 时，它就不能在声明它的类的外部访问。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  public <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animal = <span class="keyword">new</span> Animal(<span class="string">'白凤'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(animal.name) <span class="comment">// 报错：[ts] Property 'name' is private and only accessible within class 'Animal'.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>虽然访问 private 成员 typescript 检测会到错误，编译时报错，但是编译出的 javascript 文件仍能正常执行</p>
</blockquote>
<p>TypeScript 使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。</p>
<p>然而，当我们比较带有 private 或 protected 成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private 成员，那么只有当另外一个类型中也存在这样一个 private 成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected 成员也使用这个规则。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  public <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal2</span> </span>&#123;</span><br><span class="line">  private name: string</span><br><span class="line">  public <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xiaodi: Animal = <span class="keyword">new</span> Animal2(<span class="string">'小弟'</span>) <span class="comment">// 报错：Type 'Animal2' is not assignable to type 'Animal'.</span></span><br></pre></td></tr></table></figure>
<p>如上，因为含有私有属性 name，所以尽管两个类结构一模一样，但是仍然不能将 Animal2 的实例赋值给 Animal 类型的变量。如果将 name 的属性改为 public，则不会报错。</p>
<h3 id="修饰符-protected"><a href="#修饰符-protected" class="headerlink" title="修饰符 protected"></a>修饰符 protected</h3><p>protected 与 private 相似，不同的是，<strong>protected 成员在派生类中仍然可以访问</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  private department: string</span><br><span class="line">  <span class="keyword">constructor</span>(name: string, department: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name)</span><br><span class="line">    <span class="keyword">this</span>.department = department</span><br><span class="line">  &#125;</span><br><span class="line">  introduce (): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi, I'm <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> and I work in <span class="subst">$&#123;<span class="keyword">this</span>.department&#125;</span>!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> weizhuang = <span class="keyword">new</span> Person(<span class="string">'卫庄'</span>)</span><br><span class="line"><span class="comment">// weizhuang.name // 报错：[ts] Property 'name' is protected and only accessible within class 'Person' and its subclasses.</span></span><br><span class="line"><span class="keyword">let</span> genie = <span class="keyword">new</span> Employee(<span class="string">'盖聂'</span>, <span class="string">'秦国'</span>)</span><br><span class="line">genie.introduce()</span><br></pre></td></tr></table></figure>
<p>构造函数也可以被标记成 protected。 这意味着这个类<strong>不能在包含它的类外被实例化，但是能被继承</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  protected name: string</span><br><span class="line">  protected <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let weizhuang = new Person('卫庄') // 报错：[ts] Constructor of class 'Person' is protected and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure>
<h3 id="修饰符-readonly"><a href="#修饰符-readonly" class="headerlink" title="修饰符 readonly"></a>修饰符 readonly</h3><p>readonly 将属性设置为只读，初始化后不可修改。</p>
<p>初始化方式：</p>
<ul>
<li>声明时</li>
<li>构造函数里</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>&#123;</span><br><span class="line">  readonly name: string</span><br><span class="line">  readonly numOfLegs: number = <span class="number">4</span></span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> diandian = <span class="keyword">new</span> Dog(<span class="string">'点点'</span>)</span><br><span class="line">diandian.name = <span class="string">'贝贝'</span> <span class="comment">// 报错：[ts] Cannot assign to 'name' because it is a constant or a read-only property.</span></span><br></pre></td></tr></table></figure>
<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>通过给构造函数添加一个限定符来声明参数属性，可以方便的在一个地方定义并初始化一个成员。</p>
<p>简化了先声明一个属性，构造函数接收参数，然后将参数的值赋值给属性的步骤。</p>
<p>public 类型属性，<strong>public 不可省略</strong>，否则便是构造函数接收一个参数，但是不会赋值给成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上编译结果为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>通过 getters/setters 截取对对象成员的访问</p>
<p>使用存取器需要注意：</p>
<ul>
<li>编译器设置为输出 ECMAScript 5 或更高，不支持降级到 ECMAScript 3</li>
<li>只带有 get 不带有 set 的存取器自动被推断为 readonly</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> password = <span class="string">'1234'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  private _fullname: string</span><br><span class="line">  <span class="keyword">get</span> fullname (): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullname</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> fullname (name: string) &#123;</span><br><span class="line">    <span class="keyword">if</span> (password &amp;&amp; password === <span class="string">'0000'</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._fullname = name</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Error: Unauthorized update of employee!"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user1 = <span class="keyword">new</span> User()</span><br><span class="line">user1.fullname = <span class="string">'岑岑'</span> <span class="comment">// Error: Unauthorized update of employee!</span></span><br></pre></td></tr></table></figure>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>静态属性：存在于类本身上而不是类实例上的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> king: string = <span class="string">'嬴政'</span></span><br><span class="line">  <span class="keyword">static</span> say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'赳赳老秦，共赴国难！'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Qin.say()</span><br></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Qin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> say() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'赳赳老秦，共赴国难！'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Qin.king = <span class="string">'嬴政'</span></span><br><span class="line">Qin.say()</span><br></pre></td></tr></table></figure>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类做为其它派生类的<strong>基类</strong>使用。 它们一般<strong>不会直接被实例化</strong>。</p>
<ul>
<li><p>不同于接口，抽象类<strong>可以包含成员的实现细节</strong>。</p>
</li>
<li><p><code>abstract</code> 关键字是用于定义<strong>抽象类</strong>和在抽象类内部定义<strong>抽象方法</strong>。</p>
</li>
<li><p>不可以创建抽象类的实例。</p>
</li>
<li><p>创建派生类的实例，变量的类型可以是抽象类。但是这样如果派生类中包含抽象类中不存在的方法，则无法调用。</p>
</li>
</ul>
<p>抽象类中的抽象方法：</p>
<ul>
<li>与接口类似，都是只包含方法签名，不包含方法体</li>
<li>必需包含 abstract 关键字，可以有访问修饰符</li>
<li>必须在派生类中实现</li>
<li>抽象方法只能存在于抽象类中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  abstract move(): <span class="keyword">void</span></span><br><span class="line">  ring (sound: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`say <span class="subst">$&#123;sound&#125;</span>~~~`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// let veh = new Vehicle() // 报错：[ts] Cannot create an instance of an abstract class.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Train</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">  move(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The train moved 10km!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  run(): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The train runned'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> car: Vehicle = <span class="keyword">new</span> Train()</span><br><span class="line">car.move()</span><br><span class="line">car.ring(<span class="string">'wu wu '</span>)</span><br><span class="line"><span class="comment">// car.run() // 报错：[ts] Property 'run' does not exist on type 'Vehicle'.</span></span><br></pre></td></tr></table></figure>
<h3 id="把类当接口使用"><a href="#把类当接口使用" class="headerlink" title="把类当接口使用"></a>把类当接口使用</h3><p>类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。</p>
<blockquote>
<p>接口可以继承类</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x: number</span><br><span class="line">  y: number</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Point3d extends Point &#123;</span><br><span class="line">  z: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/04-functions.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/04-functions.ts</a></p>
<h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><p>函数类型包含两部分：参数类型和返回值类型。函数的类型只是由<strong>参数类型和返回值</strong>组成的。</p>
<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。</p>
<p>对于返回值，我们在函数和返回值类型之前使用( =&gt; )符号，使之清晰明了。返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void 而不能留空。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  x: <span class="built_in">number</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  y: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add2 = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 add2 函数，如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript 编译器会自动识别出类型。</p>
<p>这叫做“按上下文归类”，是类型推论的一种。</p>
<h3 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h3><p>TypeScript 里的每个函数参数都是必须的。编译器检查用户是否为每个参数都传入了值。编译器还会假设只有这些参数会被传递进函数。</p>
<p>简短地说，<strong>传递给一个函数的参数个数必须与函数期望的参数个数一致。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">sayName(<span class="string">'赵'</span>, <span class="string">'云澜'</span>, <span class="string">'d'</span>) <span class="comment">// 报错：Expected 2 arguments, but got 3.</span></span><br><span class="line">sayName(<span class="string">'赵'</span>, <span class="string">'云澜'</span>) <span class="comment">// 正常</span></span><br><span class="line">sayName(<span class="string">'赵'</span>) <span class="comment">// 报错：Expected 2 arguments, but got 1.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以在参数名旁使用 ? 实现 可选参数 的功能</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName2</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">sayName2(<span class="string">'赵'</span>, <span class="string">'云澜'</span>)</span><br><span class="line">sayName2(<span class="string">'赵'</span>)</span><br><span class="line">sayName2(<span class="string">'赵'</span>, <span class="string">'云澜'</span>, <span class="string">'d'</span>) <span class="comment">// 报错：Expected 1-2 arguments, but got 3.</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可选参数必须跟在必须参数后面。</p>
</blockquote>
<ul>
<li>可以为参数提供一个默认值当用户没有传递这个参数或传递的值是 undefined 时。它们叫做有默认初始化值的参数</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName3</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName = '处长'</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">sayName3(<span class="string">'赵'</span>, <span class="string">'云澜'</span>)</span><br><span class="line">sayName3(<span class="string">'赵'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在所有必须参数后面的带默认初始化的参数都是可选的<br>与普通可选参数不同的是，带默认值的参数不需要放在必须参数的后面。如果带默认值的参数出现在必须参数前面，用户必须明确的传入 undefined 值来获得默认值。</p>
</blockquote>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>当不知道有多少参数会被传递进来时，可以把所有参数收集到一个变量里。</p>
<p>剩余参数会被当做个数不限的可选参数。可以一个都没有，同样也可以有任意个。编译器创建参数数组，名字是你在省略号（…）后面给定的名字，你可以在函数体内使用这个数组。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName4</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfNames: <span class="built_in">string</span>[]</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;restOfNames.join(<span class="string">' '</span>)&#125;</span>`</span></span><br><span class="line">&#125;</span><br><span class="line">sayName4(<span class="string">'赵'</span>)</span><br><span class="line">sayName4(<span class="string">'赵'</span>, <span class="string">'云澜'</span>)</span><br><span class="line">sayName4(<span class="string">'赵'</span>, <span class="string">'云'</span>, <span class="string">'澜'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h3><p>可以为函数提供一个显式的 this 参数。this 参数是个假的参数，它出现在参数列表的最前面。</p>
<p>当在 tsconfig.json 中配置 <code>noImplicitThis</code> 为 true 时，this 表达式的值为 any 类型时，会生成一个错误。提供一个具有类型的 this 参数，告诉 typescript 函数期待在那个对象上调用，就不会报错了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">  suit: <span class="built_in">string</span></span><br><span class="line">  card: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.card) <span class="comment">// 报错：'this' implicitly has type 'any' because it does not have a type annotation.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"><span class="keyword">this</span>: Card</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 提供 this 参数，就不报错了</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.card)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为 this 是假的参数，编译时不会被编译到参数中，调用时也不用传递</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params"><span class="keyword">this</span>: Card, extraParam: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.card, extraParam)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 typescript 代码编译结果为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testThis</span>(<span class="params">extraParam</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.card, extraParam)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>有时候，函数会根据传进来的参数的类型，决定返回类型。</p>
<p>可以通过为一个函数提供多个函数类型定义来进行函数重载。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overloadTest</span>(<span class="params">x: &#123; firstName: <span class="built_in">string</span>; lastName: <span class="built_in">string</span> &#125;</span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">overloadTest</span>(<span class="params">x: <span class="built_in">string</span></span>): </span>&#123; <span class="title">firstName</span>: <span class="title">string</span></span>; lastName: <span class="built_in">string</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">overloadTest</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;x.firstName&#125;</span> <span class="subst">$&#123;x.lastName&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; firstName: x, lastName: <span class="string">'云澜'</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(overloadTest(<span class="string">'小'</span>))</span><br></pre></td></tr></table></figure>
<p>为了让编译器能够选择正确的检查类型，它与 JavaScript 里的处理流程相似。它查找重载列表，尝试使用第一个重载定义。如果匹配的话就使用这个。因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p>
<blockquote>
<p>function overloadTest(x): any 并不是重载列表的一部分。<br>以其他方式调用 overloadTest 会报错</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/05-generics.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/05-generics.ts</a></p>
<p>定义一个 identify 函数，会返回任何传入它的值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，第一想法是使用 any 类型。但是使用 any 类型，无法保证传入的参数类型与返回值类型一致。</p>
<p>可以使用<strong>类型变量</strong>，它是一种特殊的变量，只用于表示类型而不是值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型函数：</p>
<ul>
<li><p>传入所有的参数，包含类型参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output1 = identify&lt;<span class="built_in">string</span>&gt;(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>利用<strong>类型推论</strong> – 即编译器会根据传入的参数自动地帮助我们确定 T 的类型</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> output2 = identify(<span class="string">'a'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="使用泛型变量"><a href="#使用泛型变量" class="headerlink" title="使用泛型变量"></a>使用泛型变量</h3><p>使用泛型创建像 identity 这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。换句话说，你必须把这些参数当做是任意或所有类型。</p>
<p>如下使用泛型，会报错：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x.length) <span class="comment">// 报错：Property 'length' does not exist on type 'T'.</span></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 x 可能是不包含 length 属性的类型，如 number 类型。</p>
<p><strong>我们可以把泛型变量 T 当做类型的一部分使用，而不是整个类型，增加了灵活性。</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify2</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，泛型变量 T 代表的是数组类型的参数 x 中的元素的类型，而不是参数整体的类型。</p>
<h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><p>为泛型函数 identify 定义泛型类型的接口</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> indentifyFn &#123;</span><br><span class="line">  &lt;T&gt;(x: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myIdentify: indentifyFn = identify</span><br></pre></td></tr></table></figure>
<p>可以把泛型参数当作整个接口的一个参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> indentifyFn2&lt;T&gt; &#123;</span><br><span class="line">  (x: T): T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myIdentify2: indentifyFn2&lt;<span class="built_in">string</span>&gt; = identify</span><br></pre></td></tr></table></figure>
<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> genericClass&lt;T&gt; &#123;</span><br><span class="line">  a: T</span><br><span class="line">  <span class="keyword">static</span> b: T <span class="comment">// 报错：Static members cannot reference class type parameters.</span></span><br><span class="line">  add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myGenericClass = <span class="keyword">new</span> genericClass&lt;<span class="built_in">number</span>&gt;()</span><br><span class="line">myGenericClass.a = <span class="number">12</span></span><br><span class="line">myGenericClass.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类有两部分：静态部分和实例部分。 泛型类指的是<strong>实例部分的类型</strong>，所以<strong>类的静态属性不能使用这个泛型类型</strong>。</p>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>如下，访问 x 的 length 属性，会报错，因为不能证明所有类型都有 length 属性：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify4</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x.length) <span class="comment">// 报错：Property 'length' does not exist on type 'T'.</span></span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以定义一个接口为类型参数 T 描述约束条件，并使用 <code>extends</code> 关键字来实现约束</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> lengthWise &#123;</span><br><span class="line">  length: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify4</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">lengthWise</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x.length)</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>可以声明一个被其他类型参数约束的类型参数</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; a: <span class="string">'aaa'</span>, b: <span class="string">'bbb'</span> &#125;</span><br><span class="line">getProperty(obj, <span class="string">'a'</span>)</span><br><span class="line">getProperty(obj, <span class="string">'c'</span>) <span class="comment">// 报错：[ts] Argument of type '"c"' is not assignable to parameter of type '"a" | "b"'</span></span><br></pre></td></tr></table></figure>
<p>如上，可以保证参数 key 是 obj 的一个属性</p>
<h3 id="在泛型里使用类类型"><a href="#在泛型里使用类类型" class="headerlink" title="在泛型里使用类类型"></a>在泛型里使用类类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">  hasMask: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">  nametag: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Animals &#123;</span><br><span class="line">  numLegs: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animals &#123;</span><br><span class="line">  keeper: BeeKeeper</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animals &#123;</span><br><span class="line">  keeper: ZooKeeper</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>&lt;<span class="title">A</span> <span class="title">extends</span> <span class="title">Animals</span>&gt;(<span class="params">c: <span class="keyword">new</span> () =&gt; A</span>): <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> c()</span><br><span class="line">&#125;</span><br><span class="line">createInstance(Lion).keeper.nametag <span class="comment">// typechecks!</span></span><br><span class="line">createInstance(Bee).keeper.hasMask <span class="comment">// typechecks!</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/06-enums.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/06-enums.ts</a></p>
<p>使用枚举我们可以定义一些带名字的常量。使用枚举可以清晰地表达意图或创建一组有区别的用例。TypeScript 支持数字的和基于字符串的枚举。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  UP,</span><br><span class="line">  DOWN,</span><br><span class="line">  LEFT,</span><br><span class="line">  RIGHT</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direction.DOWN) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>如上，定义一个数字枚举。UP 的值默认为 0，其余的成员会从 0 开始自动增长。即 UP 为 0，DOWN 为 1，LEFT 为 2，RIGHT 为 3.</p>
<p>我们也可以指定数字的初始值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  UP = <span class="number">1</span>,</span><br><span class="line">  DOWN,</span><br><span class="line">  LEFT,</span><br><span class="line">  RIGHT</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Direction.DOWN) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这样，UP 的值为 1，其余成员从 1 开始自动增长。</p>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ABO &#123;</span><br><span class="line">  A = <span class="string">'alpha'</span>,</span><br><span class="line">  B = <span class="string">'beta'</span>,</span><br><span class="line">  O = <span class="string">'omega'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异构枚举（Heterogeneous-enums）"><a href="#异构枚举（Heterogeneous-enums）" class="headerlink" title="异构枚举（Heterogeneous enums）"></a>异构枚举（Heterogeneous enums）</h3><p>从技术的角度来说，枚举可以混合字符串和数字成员</p>
<p>除非你真的想要利用 JavaScript 运行时的行为，否则我们不建议这样做。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> HeterogeneousEnums &#123;</span><br><span class="line">  N = <span class="number">0</span>,</span><br><span class="line">  Y = <span class="string">'yes'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是 <strong>常量</strong> 或 <strong>计算出来的</strong>。</p>
<p>当满足如下条件时，枚举成员被当作是<strong>常量</strong>：</p>
<ul>
<li><p>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 <strong>0</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  X</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>它不带有初始化器且它之前的枚举成员是一个 数字常量。这种情况下，当前枚举成员的值为它上一个枚举成员的值加 1</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  X,</span><br><span class="line">  Y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">  X = <span class="number">2</span>,</span><br><span class="line">  Y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>枚举成员使用 <strong>常量枚举表达式</strong> 初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p>
<ul>
<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li>
<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>
<li>带括号的常量枚举表达式</li>
<li>一元运算符 +, -, ~ 其中之一应用在了常量枚举表达式</li>
<li>常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 的操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错。</li>
</ul>
</li>
</ul>
<p>所有其它情况的枚举成员被当作是需要计算得出的值</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileAccess &#123;</span><br><span class="line">  <span class="comment">// constant members</span></span><br><span class="line">  None,</span><br><span class="line">  Read = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">  Write = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  ReadWrite = Read | Write,</span><br><span class="line">  <span class="comment">// computed member</span></span><br><span class="line">  G = <span class="string">'123'</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>数字枚举成员具有 <strong>反向映射</strong></p>
<p>下面的代码：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">  UP = <span class="number">1</span>,</span><br><span class="line">  DOWN,</span><br><span class="line">  LEFT,</span><br><span class="line">  RIGHT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会被编译为：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Direction</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">Direction</span>) </span>&#123;</span><br><span class="line">  Direction[(Direction[<span class="string">'UP'</span>] = <span class="number">1</span>)] = <span class="string">'UP'</span></span><br><span class="line">  Direction[(Direction[<span class="string">'DOWN'</span>] = <span class="number">2</span>)] = <span class="string">'DOWN'</span></span><br><span class="line">  Direction[(Direction[<span class="string">'LEFT'</span>] = <span class="number">3</span>)] = <span class="string">'LEFT'</span></span><br><span class="line">  Direction[(Direction[<span class="string">'RIGHT'</span>] = <span class="number">4</span>)] = <span class="string">'RIGHT'</span></span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;))</span><br></pre></td></tr></table></figure>
<p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。</p>
<blockquote>
<p>不会为字符串枚举成员生成反向映射</p>
</blockquote>
<h3 id="const-枚举"><a href="#const-枚举" class="headerlink" title="const 枚举"></a>const 枚举</h3><p>常量枚举通过在枚举上使用 <code>const</code> 修饰符来定义。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量枚举只能使用常量枚举表达式，常量枚举不允许包含计算成员。</p>
<p>不同于常规的枚举，常量枚举在编译时会被删除。常量枚举成员在使用的地方会被内联进来。</p>
<p><strong>常规枚举：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> enums = [Enum.A, Enum.B]</span><br></pre></td></tr></table></figure>
<p>编译结果为</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Enum</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">Enum</span>) </span>&#123;</span><br><span class="line">  Enum[(Enum[<span class="string">'A'</span>] = <span class="number">1</span>)] = <span class="string">'A'</span></span><br><span class="line">  Enum[(Enum[<span class="string">'B'</span>] = <span class="number">2</span>)] = <span class="string">'B'</span></span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;))</span><br><span class="line"><span class="keyword">var</span> enums = [Enum.A, Enum.B]</span><br></pre></td></tr></table></figure>
<p><strong>常量枚举：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> enums = [Enum.A, Enum.B]</span><br></pre></td></tr></table></figure>
<p>编译结果为</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> enums = [<span class="number">1</span> <span class="comment">/* A */</span>, <span class="number">2</span> <span class="comment">/* B */</span>]</span><br></pre></td></tr></table></figure>
<h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><p>外部枚举用来描述已经存在的枚举类型的形状。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Enum2 &#123;</span><br><span class="line">  A = <span class="number">1</span>,</span><br><span class="line">  B,</span><br><span class="line">  C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>
<blockquote>
<p>? 无编译结果，没明白</p>
</blockquote>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/07-advancedTypes.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/07-advancedTypes.ts</a></p>
<h3 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h3><p>交叉类型是将多个类型合并为一个类型。这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<p>例如，Person &amp; Serializable &amp; Loggable 同时是 Person 和 Serializable 和 Loggable。就是说这个类型的对象同时拥有了这三种类型的成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> first) &#123;</span><br><span class="line">    ;(&lt;<span class="built_in">any</span>&gt;result)[key] = first[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (second.hasOwnProperty(key)) &#123;</span><br><span class="line">      ;(&lt;<span class="built_in">any</span>&gt;result)[key] = second[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h3><p>联合类型表示一个值可以是几种类型之一。</p>
<p>我们用竖线（ | ）分隔每个类型，所以 number | string | boolean 表示一个值可以是 number，string，或 boolean。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim()</span><br><span class="line">  layEggs()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPet</span>(<span class="params"></span>): <span class="title">Bird</span> | <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Bird | Fish&gt;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pet = getPet()</span><br><span class="line">pet.layEggs()</span><br><span class="line"><span class="comment">// pet.fly() // 报错：Property 'fly' does not exist on type 'Bird | Fish'. Property 'fly' does not exist on type 'Fish'.</span></span><br></pre></td></tr></table></figure>
<h3 id="类型保护与区分类型"><a href="#类型保护与区分类型" class="headerlink" title="类型保护与区分类型"></a>类型保护与区分类型</h3><p>上一节的代码中，访问 <code>pet.fly</code> 报错。为了能够访问联合类型中不属于共有成员的其他成员，可以使用类型断言：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((&lt;Bird&gt;pet).fly) &#123;</span><br><span class="line">  ;(&lt;Bird&gt;pet).fly()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ;(&lt;Fish&gt;pet).swim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><p>上面的代码中多次使用了类型断言。</p>
<p>typescript 的 <strong>类型保护机制</strong> 可以让我们一旦检查过 pet 的类型，就能在之后的每个分支里知道 pet 的类型。</p>
<p>类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。</p>
<p>要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 <strong>类型谓词</strong>。</p>
<p>谓词为 <code>parameterName is Type</code> 这种形式， parameterName 必须是来自于当前函数签名里的一个参数名。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Bird | Fish</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">  pet.swim()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  pet.fly()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：TypeScript 不仅知道在 if 分支里 pet 是 Fish 类型；它还清楚在 else 分支里，一定不是 Fish 类型，一定是 Bird 类型。</p>
</blockquote>
<h4 id="typeof-类型保护"><a href="#typeof-类型保护" class="headerlink" title="typeof 类型保护"></a>typeof 类型保护</h4><p>对于原始类型，不需要定义一个函数来进行类型保护。可以直接使用 <code>typeof x === &#39;number&#39;</code>，因为 typescript 可以将他识别为一个类型保护。</p>
<p>这些 <strong>typeof 类型保护</strong> 只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>，”typename” 必须是 <strong>number，string，boolean 或 symbol</strong>。但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft2</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">'number'</span>) &#123;</span><br><span class="line">    padding.toFixed(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">' '</span>) + value</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    padding.charAt(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> padding + value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="instanceof-类型保护"><a href="#instanceof-类型保护" class="headerlink" title="instanceof 类型保护"></a>instanceof 类型保护</h4><p><code>instanceof</code> 类型保护是通过构造函数来细化类型的一种方式。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">  getPaddingStr(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> spaceNum: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">  getPaddingStr(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.spaceNum + <span class="number">1</span>).join(<span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> value: <span class="built_in">string</span></span>) &#123;&#125;</span><br><span class="line">  getPaddingStr(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>): <span class="title">Padder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span></span><br><span class="line">    ? <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>)</span><br><span class="line">    : <span class="keyword">new</span> StringPadder(<span class="string">'  '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder()</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">  <span class="comment">// padder.value // 报错：Property 'value' does not exist on type 'SpaceRepeatingPadder'.</span></span><br><span class="line">  <span class="built_in">console</span>.log(padder.spaceNum)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">  <span class="comment">// padder.spaceNum // 报错：[ts] Property 'spaceNum' does not exist on type 'StringPadder'.</span></span><br><span class="line">  <span class="built_in">console</span>.log(padder.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>instanceof 的右侧要求是一个构造函数，TypeScript 将细化为：</p>
<ul>
<li>此构造函数的 prototype 属性的类型，如果它的类型不为 any 的话</li>
<li>构造签名所返回的类型的联合<br>以此顺序。</li>
</ul>
<h3 id="可以为-null-的类型"><a href="#可以为-null-的类型" class="headerlink" title="可以为 null 的类型"></a>可以为 null 的类型</h3><p>TypeScript 具有两种特殊的类型， null 和 undefined，它们分别具有值 null 和 undefined.</p>
<p>默认情况下，类型检查器认为 null 与 undefined 可以赋值给任何类型。</p>
<p>–strictNullChecks 标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null 或 undefined。</p>
<blockquote>
<p>注意，按照 JavaScript 的语义，TypeScript 会把 null 和 undefined 区别对待。 string | null， string | undefined 和 string | undefined | null 是不同的类型。</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'abc'</span></span><br><span class="line"><span class="comment">// s = undefined // 报错：Type 'undefined' is not assignable to type 'string'</span></span><br><span class="line"><span class="comment">// s = null // 报错：Type 'null' is not assignable to type 'string'</span></span><br></pre></td></tr></table></figure>
<h4 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h4><p>使用了 <code>--strictNullChecks</code>，可选参数会被自动地加上 <code>| undefined</code>:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a: <span class="built_in">number</span>, b?: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + (b || <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line"><span class="comment">// f(1, null) // 报错：Argument of type 'null' is not assignable to parameter of type 'number | undefined'.</span></span><br></pre></td></tr></table></figure>
<p>可选属性也会有同样的处理：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> a: <span class="built_in">number</span>, <span class="keyword">public</span> b?: <span class="built_in">number</span></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cc = <span class="keyword">new</span> C(<span class="number">1</span>, <span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">let</span> cc2 = <span class="keyword">new</span> C(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// let cc3 = new C(1, null) // 报错：Argument of type 'null' is not assignable to parameter of type 'number | undefined'.</span></span><br></pre></td></tr></table></figure>
<h4 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h4><p>当一个变量的类型为联合类型，并且包含 null 时，使用这个变量时需要使用类型保护来去除 null。</p>
<p>可以使用 if 语句</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'default'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以用 || 短路运算符</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str || <span class="string">'default'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果编译器不能够去除 null 或 undefined，你可以使用类型断言手动去除。 语法是添加 <code>!</code> 后缀： <code>identifier!</code> 从 identifier 的类型里去除了 null 和 undefined：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">str: <span class="built_in">string</span> | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str!.charAt(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名会给一个类型起个新名字。类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<p>起别名<strong>不会新建一个类型</strong> - 它创建了一个新名字来引用那个类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> s = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="comment">// let sss: s = true // 报错：[ts] Type 'true' is not assignable to type 'string | number'</span></span><br></pre></td></tr></table></figure>
<p>给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，<strong>类型别名也可以是泛型</strong> - 我们可以添加类型参数并在别名声明的右侧传入：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> GenericType&lt;T&gt; = <span class="function">(<span class="params">c: T</span>) =&gt;</span> T</span><br></pre></td></tr></table></figure>
<h4 id="接口-vs-类型别名"><a href="#接口-vs-类型别名" class="headerlink" title="接口 vs 类型别名"></a>接口 vs 类型别名</h4><p>类型别名像接口一样，但是仍有细微差别</p>
<ul>
<li>接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新名字 — 比如，错误信息就不会使用别名。</li>
<li>类型别名不能被 extends 和 implements（自己也不能 extends 和 implements 其它类型）。</li>
</ul>
<blockquote>
<p>如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。</p>
</blockquote>
<h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><p>字符串字面量类型允许你 <strong>指定字符串必须的固定值</strong>。</p>
<p>在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。通过结合使用这些特性，你可以实现类似枚举类型的字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">'ease-in'</span> | <span class="string">'ease-out'</span> | <span class="string">'ease-in-out'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">translate</span>(<span class="params">easing: Easing</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (easing === <span class="string">'ease-in'</span>) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">'ease-out'</span>) &#123;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">translate(<span class="string">'ease-in-out'</span>)</span><br><span class="line"><span class="comment">// translate('linear') // 报错：[ts] Argument of type '"linear"' is not assignable to parameter of type 'Easing'.</span></span><br></pre></td></tr></table></figure>
<p><strong>字符串字面量类型还可以用于区分函数重载：</strong></p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagname: 'INPUT'</span>): <span class="title">HTMLInputElement</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagname: 'IMG'</span>): <span class="title">HTMLImageElement</span></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagname: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">  <span class="title">return</span> <span class="title">document</span>.<span class="title">createElement</span>(<span class="params">tagname</span>)</span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Num = <span class="number">1</span> | <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> nn: Num = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<h3 id="枚举成员类型"><a href="#枚举成员类型" class="headerlink" title="枚举成员类型"></a>枚举成员类型</h3><p>如我们在 枚举一节里提到的，当每个枚举成员都是用字面量初始化的时候枚举成员是具有类型的。</p>
<p>在我们谈及“ <strong>单例类型</strong> ”的时候，多数是指<strong>枚举成员类型和数字/字符串字面量类型</strong>，尽管大多数用户会<strong>互换使用“单例类型”和“字面量类型”</strong>。</p>
<h3 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h3><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 <strong>可辨识联合</strong> 的高级模式，它也称做 <strong>标签联合</strong> 或 <strong>代数数据类型</strong>。</p>
<p>可辨识联合在函数式编程很有用处。一些语言会自动地为你辨识联合；而 TypeScript 则基于已有的 JavaScript 模式。</p>
<p>它具有 3 个要素：</p>
<ul>
<li>具有共同的单例类型属性 — 可辨识的特征。</li>
<li>一个类型别名包含了那些类型的联合 — 联合。</li>
<li>共同属性上的类型保护。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">'square'</span></span><br><span class="line">  size: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> RectAngle &#123;</span><br><span class="line">  kind: <span class="string">'rectangle'</span></span><br><span class="line">  width: <span class="built_in">number</span></span><br><span class="line">  height: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">'circle'</span></span><br><span class="line">  radius: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们声明了将要联合的接口。每个接口都有 kind 属性但有不同的字符串字面量类型。kind 属性称做 <strong>可辨识的特征</strong> 或 <strong>标签</strong>。其它的属性则特定于各个接口。注意，目前各个接口间是没有联系的。下面我们把它们联合到一起：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = Square | RectAngle | Circle</span><br></pre></td></tr></table></figure>
<p>现在我们使用可辨识联合:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h3><p>当没有涵盖所有可辨识联合的变化时，我们想让编译器可以通知我们。比如，如果我们添加了 Triangle 到 Shape，我们希望编译器可以提醒我们 area 函数应该涵盖这一情况。</p>
<p>一种方法是开启 <code>strictNullChecks</code>，并<strong>指定返回值类型</strong>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape = Square | RectAngle | Circle | Triangle</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 报错：Function lacks ending return statement and return type does not include 'undefined'.</span></span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 area 函数没有包含所有情况，所以编译器认为可能返回 undefined，指定返回 number 类型便会报错。</p>
<p>第二种方法使用 <code>never</code> 类型，编译器用它来进行完整性检查：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">n</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unexpected object: '</span> + n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'square'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'rectangle'</span>:</span><br><span class="line">      <span class="keyword">return</span> s.width * s.height</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'circle'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> assertNever(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多态的-this-类型"><a href="#多态的-this-类型" class="headerlink" title="多态的 this 类型"></a>多态的 this 类型</h3><p>多态的 this 类型表示的是<strong>某个包含类或接口的 子类型</strong>。 这被称做 <strong>F-bounded 多态性</strong>。它能很容易的表现连贯接口间的继承。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasicCalculator &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123;&#125;</span><br><span class="line">  <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value += operand</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value *= operand</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="keyword">super</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> sin(): <span class="keyword">this</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">  .add(<span class="number">3</span>)</span><br><span class="line">  .multiply(<span class="number">6</span>)</span><br><span class="line">  .sin()</span><br><span class="line">  .currentValue()</span><br></pre></td></tr></table></figure>
<h3 id="索引类型（Index-types）"><a href="#索引类型（Index-types）" class="headerlink" title="索引类型（Index types）"></a>索引类型（Index types）</h3><p>使用索引类型，编译器就能够检查使用了动态属性名的代码。</p>
<p>一个常见的 JavaScript 模式是从对象中选取属性的子集：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>(<span class="params">o, names</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 TypeScript 里使用此函数，通过 <strong>索引类型查询</strong> 和 <strong>索引访问操作符</strong>：</p>
<ul>
<li>索引类型查询操作符：<code>keyof T</code>。对于任何类型 <code>T</code>，<code>keyof T</code> 的结果为 T 上已知的公共属性名的联合。</li>
<li>索引访问操作符：<code>T[K]</code>。</li>
</ul>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pers = &#123;</span><br><span class="line">  name: <span class="string">'赵云澜'</span>,</span><br><span class="line">  age: <span class="number">26</span></span><br><span class="line">&#125;</span><br><span class="line">pluck(pers, [<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br><span class="line"><span class="comment">// pluck(pers, ['name', 'ds']) // 报错：Argument of type '("name" | "ds")[]' is not assignable to parameter of type '("name" | "age")[]'</span></span><br></pre></td></tr></table></figure>
<h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><p>没明白作用</p>
<p>TODO</p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/08-modules.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/08-modules.ts</a></p>
<p>模块在其自身的作用域里执行，而不是在全局作用域里。</p>
<p>模块是自声明的；两个模块之间的关系是通过在文件级别上使用 <code>imports</code> 和 <code>exports</code> 建立的。</p>
<p>模块使用<strong>模块加载器</strong>去导入其它的模块。在运行时，模块加载器的作用是在执行此模块代码前去查找并执行这个模块的所有依赖。大家最熟知的 JavaScript 模块加载器是服务于 Node.js 的 <code>CommonJS</code> 和服务于 Web 应用的 <code>Require.js</code>。</p>
<p>TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。</p>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><h4 id="导出声明"><a href="#导出声明" class="headerlink" title="导出声明"></a>导出声明</h4><p>任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加 <code>export</code> 关键字来导出。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> MobileReg = <span class="regexp">/^[0-9]&#123;11&#125;$/</span></span><br></pre></td></tr></table></figure>
<h4 id="导出语句"><a href="#导出语句" class="headerlink" title="导出语句"></a>导出语句</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MobileValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MobileReg.test(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; MobileValidator &#125;</span><br><span class="line"><span class="keyword">export</span> &#123; MobileValidator <span class="keyword">as</span> MainValidator &#125;</span><br></pre></td></tr></table></figure>
<h4 id="重新导出"><a href="#重新导出" class="headerlink" title="重新导出"></a>重新导出</h4><p>有时候我们会把导入的模块的部分重新导出。重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'./MobileValidator'</span></span><br></pre></td></tr></table></figure>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><h4 id="导入一个模块中的某个导出内容"><a href="#导入一个模块中的某个导出内容" class="headerlink" title="导入一个模块中的某个导出内容"></a>导入一个模块中的某个导出内容</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span></span><br></pre></td></tr></table></figure>
<p>可以对导入内容重命名：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator <span class="keyword">as</span> SV &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span></span><br></pre></td></tr></table></figure>
<h4 id="将整个模块导入到一个变量"><a href="#将整个模块导入到一个变量" class="headerlink" title="将整个模块导入到一个变量"></a>将整个模块导入到一个变量</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Validation <span class="keyword">from</span> <span class="string">'./Validation'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> MobileValidator <span class="keyword">implements</span> Validation.StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> MobileReg.test(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="具有副作用的导入模块"><a href="#具有副作用的导入模块" class="headerlink" title="具有副作用的导入模块"></a>具有副作用的导入模块</h4><p>尽管不推荐这么做，一些模块会设置一些全局状态供其它模块使用。这些模块可能没有任何的导出或用户根本就不关注它的导出。使用下面的方法来导入这类模块：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./my-module.js'</span></span><br></pre></td></tr></table></figure>
<h3 id="默认导出"><a href="#默认导出" class="headerlink" title="默认导出"></a>默认导出</h3><p>每个模块都可以有且<strong>只能有一个</strong> <code>default</code> 导出。</p>
<h3 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export = 和 import = require()"></a>export = 和 import = require()</h3><p>CommonJS 和 AMD 都有一个 exports 对象的概念，它包含了一个模块的所有导出内容。</p>
<p>TypeScript 模块支持 <code>export =</code> 语法以支持传统的 CommonJS 和 AMD 的工作流模型。</p>
<p><code>export =</code> 语法定义一个模块的导出对象。它可以是类，接口，命名空间，函数或枚举。</p>
<p>若要导入一个使用了<code>export =</code>的模块时，必须使用 TypeScript 提供的特定语法<code>import module = require(&quot;module&quot;)</code>。</p>
<p>ZipCodeValidator.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StringValidator &#125; <span class="keyword">from</span> <span class="string">'./Validation'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> zipCodeReg = <span class="regexp">/^[0-9]&#123;6&#125;$/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">  isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> zipCodeReg.test(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> = ZipCodeValidator</span><br></pre></td></tr></table></figure>
<p>test.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ZipCodeValidator = <span class="built_in">require</span>(<span class="string">'./ZipCodeValidator'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> zipCodeValidator = <span class="keyword">new</span> ZipCodeValidator()</span><br></pre></td></tr></table></figure>
<h3 id="使用其他的-javascript-库"><a href="#使用其他的-javascript-库" class="headerlink" title="使用其他的 javascript 库"></a>使用其他的 javascript 库</h3><p>要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的 API。</p>
<p>我们叫它声明因为它不是“外部程序”的具体实现。它们通常是在 <code>.d.ts</code> 文件里定义的。</p>
<h4 id="外部模块"><a href="#外部模块" class="headerlink" title="外部模块"></a>外部模块</h4><p>我们可以使用顶级的 export 声明来为每个模块都定义一个 <code>.d.ts</code> 文件，但最好还是写在一个大的 <code>.d.ts</code> 文件里。我们使用与构造一个外部命名空间相似的方法，但是这里使用 <code>module</code> 关键字并且把名字用引号括起来，方便之后 import。</p>
<p>node.d.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'path' &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">p: <span class="built_in">string</span></span>): <span class="title">string</span></span></span><br><span class="line"><span class="function">  <span class="title">export</span> <span class="function"><span class="keyword">function</span> <span class="title">join</span>(<span class="params">...paths: <span class="built_in">any</span>[]</span>): <span class="title">string</span></span></span></span><br><span class="line"><span class="function"><span class="function">&#125;</span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function"><span class="title">declare</span> <span class="title">module</span> '<span class="title">axios</span>' </span>&#123;</span></span><br><span class="line"><span class="function">  <span class="title">export</span> <span class="title">interface</span> <span class="title">AxiosProxyConfig</span> </span>&#123;</span><br><span class="line">    host: <span class="built_in">string</span></span><br><span class="line">    port: <span class="built_in">number</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们可以 <code>/// &lt;reference&gt; node.d.ts</code> 并且使用 <code>import module = require(&quot;module&quot;);</code> 或 <code>import * as module from &quot;module&quot;</code> 加载模块。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="node.d.ts" /&gt;</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line">path.join(<span class="string">'./'</span>, <span class="string">'Validation.ts'</span>)</span><br></pre></td></tr></table></figure>
<p>如上，声明了 <code>.d.ts</code> 文件后，import 的 path 依赖，会指向 <code>node.d.ts</code> 文件，且不能调用未在 <code>node.d.ts</code> 文件中导出的方法。</p>
<h4 id="外部模块简写"><a href="#外部模块简写" class="headerlink" title="外部模块简写"></a>外部模块简写</h4><p>假如你不想在使用一个新模块之前花时间去编写声明，你可以采用声明的简写形式以便能够快速使用它。</p>
<p><strong>简写模块里所有导出的类型将是 any。</strong></p>
<p>node.d.ts</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'axios'</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="node.d.ts" /&gt;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">'/api'</span>, <span class="function"><span class="params">data</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="模块声明通配符"><a href="#模块声明通配符" class="headerlink" title="模块声明通配符"></a>模块声明通配符</h4><p>某些模块加载器如 SystemJS 和 AMD 支持导入非 JavaScript 内容。 它们通常会使用一个前缀或后缀来表示特殊的加载语法。模块声明通配符可以用来表示这些情况。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> '*!text' &#123;</span><br><span class="line">  <span class="keyword">const</span> content: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> content</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Some do it the other way around.</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'json!*' &#123;</span><br><span class="line">  <span class="keyword">const</span> value: <span class="built_in">any</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在你可以就导入匹配”<em>!text”或”json!</em>“的内容了。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fileContent <span class="keyword">from</span> <span class="string">'./xyz.txt!text'</span></span><br><span class="line"><span class="keyword">import</span> data <span class="keyword">from</span> <span class="string">'json!http://example.com/data.json'</span></span><br></pre></td></tr></table></figure>
<h3 id="创建模块结构指导"><a href="#创建模块结构指导" class="headerlink" title="创建模块结构指导"></a>创建模块结构指导</h3><p><strong>导出</strong></p>
<ul>
<li>尽可能的在顶层导出<br>用户应该更容易地使用你模块导出的内容。 嵌套层次过多会变得难以处理，因此仔细考虑一下如何组织你的代码。</li>
<li>如果仅导出单个 class 或 function，使用 export default</li>
<li>如果要导出多个对象，把它们放在顶层里导出<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> SomeType &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">someFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>导入</strong></p>
<ul>
<li>明确地列出导入的名字</li>
<li>使用命名空间导入模式当你要导出大量内容的时候</li>
<li><p>使用重新导出进行扩展</p>
</li>
<li><p>模块里不要使用命名空间</p>
</li>
</ul>
<p><strong>危险信号</strong></p>
<p>以下均为模块结构上的危险信号。重新检查以确保你没有在对模块使用命名空间：</p>
<ul>
<li>文件的顶层声明是 export namespace Foo { … } （删除 Foo 并把所有内容向上层移动一层）</li>
<li>文件只有一个 export class 或 export function （考虑使用 export default）</li>
<li>多个文件的顶层具有同样的 export namespace Foo { （不要以为这些会合并到一个 Foo 中！）</li>
</ul>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>demos：<a href="https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/09-namespaces.ts" target="_blank" rel="noopener">https://github.com/huajianduzhuo/typescript-learn/blob/master/demos/09-namespaces.ts</a></p>
<p>使用 <code>namespace</code> 定义命名空间，命名空间内可提供给外部访问的内容用 <code>export</code> 导出。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Validation &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> letterRegexp = <span class="regexp">/^[A-Za-z]+$/</span></span><br><span class="line">  <span class="keyword">let</span> numberRegexp = <span class="regexp">/^[0-9]+$/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> LettersOnlyValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> letterRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">class</span> ZipCodeValidator <span class="keyword">implements</span> StringValidator &#123;</span><br><span class="line">    isAcceptable(s: <span class="built_in">string</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> s.length === <span class="number">5</span> &amp;&amp; numberRegexp.test(s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strings = [<span class="string">'Hello'</span>, <span class="string">'10000'</span>, <span class="string">'123'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> validators: &#123;[s: <span class="built_in">string</span>]: Validation.StringValidator;&#125; = &#123;&#125;</span><br><span class="line">validators[<span class="string">'Letters Only'</span>] = <span class="keyword">new</span> Validation.LettersOnlyValidator()</span><br><span class="line">validators[<span class="string">'Zip Code'</span>] = <span class="keyword">new</span> Validation.ZipCodeValidator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> s of strings) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> validators) &#123;</span><br><span class="line">    <span class="keyword">const</span> isMatch = validators[name].isAcceptable(s)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;s&#125;</span> <span class="subst">$&#123;isMatch ? <span class="string">'matches'</span> : <span class="string">'does not match'</span>&#125;</span> <span class="subst">$&#123;name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分离到多文件"><a href="#分离到多文件" class="headerlink" title="分离到多文件"></a>分离到多文件</h3><p>当应用变得越来越大时，我们需要将代码分离到不同的文件中以便于维护。</p>
<p>多个文件可以是<strong>同一个命名空间</strong>，在使用时就<strong>如同他们在一个文件中定义的一样</strong>。</p>
<p>因为不同文件之间存在依赖关系，所以我们加入了引用标签来告诉编译器文件之间的关联。</p>
<p>demos 查看 <code>/demos/namespaces/..</code></p>
<p>将所有的输入文件编译为一个输出文件，需要使用 <code>--outFile</code> 标记。编译器会根据源码里的引用标签自动地对输出进行排序。</p>
<p><code>tsc --outFile dist/namespaces/sample.js demos/namespaces/Test.ts</code></p>
<h3 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h3><p>另一种简化命名空间操作的方法是使用<code>import q = x.y.z</code>给常用的对象起一个短的名字。不要与用来加载模块的<code>import x = require(&#39;name&#39;)</code>语法弄混了，这里的语法是为指定的符号创建一个别名。你可以用这种方法为任意标识符创建别名，也包括导入的模块中的对象。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Shapes &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">namespace</span> Polygons &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Triggle &#123;&#125;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> Square &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Polygons = Shapes.Polygons</span><br><span class="line"><span class="keyword">let</span> tri = <span class="keyword">new</span> Polygons.Triggle()</span><br></pre></td></tr></table></figure>
<p>注意，我们并没有使用<code>require</code>关键字，而是直接使用导入符号的限定名赋值。这与使用 var 相似，但它还适用于类型和导入的具有命名空间含义的符号。重要的是，对于值来讲，<code>import</code>会生成与原始符号不同的引用，所以改变别名的 var 值并不会影响原始变量的值。</p>
<h2 id="Decorators"><a href="#Decorators" class="headerlink" title="Decorators"></a>Decorators</h2><p>装饰器是一种特殊类型的声明，它能够被附加到类声明，方法， 访问符，属性或参数上，可以修改类的行为。</p>
<p>使用方式：<code>@expression</code>，expression 求值后必须是一个函数。</p>
<blockquote>
<p>装饰器是一项实验性特性，若要使用，需要在 <code>tsconfig.json</code> 中的 <code>compilerOptions</code> 里启用 <code>&quot;experimentalDecorators&quot;: true</code></p>
</blockquote>
<h3 id="Decorator-基本使用"><a href="#Decorator-基本使用" class="headerlink" title="Decorator 基本使用"></a>Decorator 基本使用</h3><p>装饰器本身就是一个函数，被声明的信息会作为参数传入装饰器中。如下：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">path</span>(<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am decorator'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@path</span></span><br><span class="line"><span class="keyword">class</span> Hello &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，<code>path</code> 为装饰器函数，用在类 <code>Hello</code> 声明上，<code>Hello</code> 会作为参数传入 <code>path</code> 中。编译后的 js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> __decorate =</span><br><span class="line">  (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">decorators, target, key, desc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length,</span><br><span class="line">      r =</span><br><span class="line">        c &lt; <span class="number">3</span></span><br><span class="line">          ? target</span><br><span class="line">          : desc === <span class="literal">null</span></span><br><span class="line">          ? (desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key))</span><br><span class="line">          : desc,</span><br><span class="line">      d</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Reflect</span> === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Reflect</span>.decorate === <span class="string">'function'</span>)</span><br><span class="line">      r = <span class="built_in">Reflect</span>.decorate(decorators, target, key, desc)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> ((d = decorators[i]))</span><br><span class="line">          r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r</span><br><span class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">path</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'I am decorator'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Hello = <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;&#125;</span><br><span class="line">Hello = __decorate([path], Hello)</span><br></pre></td></tr></table></figure>
<p>如上，<code>__decorate</code> 为处理装饰器的函数。</p>
<h3 id="绑定参数"><a href="#绑定参数" class="headerlink" title="绑定参数"></a>绑定参数</h3><p>有时候可能需要提前为装饰器函数绑定一些参数，可以使用类似 <code>bind</code> 的做法。</p>
<p>可以定义一个<strong>装饰器工厂函数</strong>，用来接收需要绑定的参数，并且该装饰器工厂函数<strong>必须返回一个函数，返回的函数才是真正的装饰器函数</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">path</span>(<span class="params">prePath: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="keyword">new</span> () =&gt; object</span>) </span>&#123;</span><br><span class="line">    target.prototype.prePath = prePath</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@path</span>(<span class="string">'src'</span>)</span><br><span class="line"><span class="keyword">class</span> Hello &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码中，<code>path</code> 不再是装饰器函数，而是装饰器工厂函数，它用来接收预先绑定的参数。<code>path 返回的函数</code> 则是真正的装饰器函数，<code>Hello</code> 会作为参数传入该函数中。编译后的 js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">path</span>(<span class="params">prePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.prototype.prePath = prePath</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Hello = <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;&#125;</span><br><span class="line">Hello = __decorate([path(<span class="string">'src'</span>)], Hello)</span><br></pre></td></tr></table></figure>
<p>可以看到，与 path 未传参数时的结果 <code>__decorate([path], Hello)</code> 对比，传了参数的结果为 <code>__decorate([path(&#39;src&#39;)], Hello)</code>，说明此时装饰器函数已经不是 <code>path</code>，而是 <code>path</code> 执行后返回的函数，并且绑定了一些预传参数。</p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>应用于类构造函数，会将类的构造函数作为参数传入装饰器函数中。</p>
<p>举例参考上面的 <code>Decorator 基本使用</code> 和 <code>绑定参数</code></p>
<h3 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h3><p>会应用在方法的<strong>属性描述符</strong>上，可以用来监视，修改或者替换方法定义。</p>
<p>装饰器函数会接收 3 个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符</li>
</ul>
<blockquote>
<p>如果代码输出目标版本小于 <code>ES5</code>，属性描述符将会是 <code>undefined</code></p>
</blockquote>
<p><strong>装饰器应用于实例方法：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Per &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@Get</span></span><br><span class="line">  say() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，装饰器函数 <code>Get</code> 的参数中，<code>target</code> 为类 <code>Per</code> 的原型对象，<code>key</code> 为方法名 <code>say</code>，<code>desc</code> 为属性描述符。编译后的 js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get</span>(<span class="params">target, key, desc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Per</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  say() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">__decorate([Get], Per.prototype, <span class="string">'say'</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>需要注意，上面 <code>__decorate</code> 的参数中，<code>desc</code> 传的虽然是 <code>null</code>，但是在 <code>__decorate</code> 函数内部，会将 <code>desc</code> 赋值为属性描述符。</p>
<p><strong>装饰器应用于静态方法：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get</span>(<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Per &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="meta">@Get</span></span><br><span class="line">  <span class="keyword">static</span> move() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的 js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Get</span>(<span class="params">target, key, desc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Per</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">static</span> move() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">__decorate([Get], Per, <span class="string">'move'</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>如上，装饰器函数 <code>Get</code> 的参数中，<code>target</code> 为类 <code>Per</code> 的构造函数，<code>key</code> 为方法名 <code>move</code>，<code>desc</code> 为属性描述符。</p>
<blockquote>
<p>如果方法装饰器函数返回一个值，它会被当作该方法的属性描述符。</p>
</blockquote>
<h3 id="访问器装饰器"><a href="#访问器装饰器" class="headerlink" title="访问器装饰器"></a>访问器装饰器</h3><p>访问器装饰器应用于访问器的<strong>属性描述符</strong>并且可以用来监视，修改或替换一个访问器的定义。</p>
<blockquote>
<p>TypeScript 不允许同时装饰一个成员的 get 和 set 访问器。取而代之的是，一个成员的所有装饰器必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个属性描述符时，它联合了 get 和 set 访问器，而不是分开声明的。</p>
</blockquote>
<p>装饰器函数会接收 3 个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>) </span>&#123;</span><br><span class="line">    desc.configurable = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> x () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果访问器装饰器函数返回一个值，它会被用作该访问器属性的属性描述符。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configurable</span>(<span class="params">value: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, key: <span class="built_in">string</span>, desc: PropertyDescriptor</span>): <span class="title">PropertyDescriptor</span> </span>&#123;</span><br><span class="line">    desc.configurable = value</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      enumerable: <span class="literal">true</span>,</span><br><span class="line">      <span class="keyword">get</span> () &#123;<span class="keyword">return</span> x&#125;,</span><br><span class="line">      <span class="keyword">set</span> (v) &#123;x = v&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="meta">@configurable</span>(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">get</span> x () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Point.prototype.x) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>如上代码，编译为 js 之后执行，x 的值为 4，因为装饰器函数返回的属性描述符替换了 x 本身的属性描述符。</p>
<h3 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h3><p>装饰器函数会接收 2 个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
</ul>
<blockquote>
<p>属性描述符不会做为参数传入属性装饰器，这与TypeScript是如何初始化属性装饰器的有关。 因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defaultValue</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    target[key] = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="meta">@defaultValue</span>(<span class="string">'white'</span>) name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Person().name) <span class="comment">// white</span></span><br></pre></td></tr></table></figure>
<h3 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h3><p>应用于类构造函数或方法声明。</p>
<p>装饰器函数会接收 3 个参数：</p>
<ul>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象</li>
<li>成员的名字</li>
<li>参数在函数参数列表中的索引</li>
</ul>
<blockquote>
<p>参数装饰器只能用来监视一个方法的参数是否被传入<br>参数装饰器的返回值会被忽略</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dd</span>(<span class="params">target: <span class="built_in">any</span>, methodName: <span class="built_in">string</span>, index: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(target, methodName, index) <span class="comment">// Person 原型对象，say, 0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  say (<span class="meta">@dd</span> name: <span class="built_in">string</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="装饰器组合"><a href="#装饰器组合" class="headerlink" title="装饰器组合"></a>装饰器组合</h3><p>多个装饰器可以应用到一个声明上。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'A'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'A inner'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'B'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'B inner'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@A</span>()</span><br><span class="line"><span class="meta">@B</span>()</span><br><span class="line"><span class="keyword">class</span> C &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如上代码，编译后运行的结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f</span><br><span class="line">g</span><br><span class="line">g inner</span><br><span class="line">f inner</span><br></pre></td></tr></table></figure>
<p>复合装饰器时，装饰器工厂函数会由上至下依次执行，而装饰器函数则由下至上执行。</p>

      
    </div>

	<div>
	  
		<div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>
	  
	</div>
	
    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/typescript/" rel="tag"><i class="fa fa-tag"></i> typescript</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/generator-学习笔记/" rel="next" title="generator 学习笔记">
                <i class="fa fa-chevron-left"></i> generator 学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/serviceWorker介绍与使用/" rel="prev" title="serviceWorker介绍与使用">
                serviceWorker介绍与使用 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
  <a class="jiathis_button_tsina"></a>
 <!-- <a class="jiathis_button_tqq"></a> -->
  <a class="jiathis_button_weixin"></a>
  <a class="jiathis_button_cqq"></a>
  <a class="jiathis_button_douban"></a>
 <!-- <a class="jiathis_button_renren"></a> -->
  <a class="jiathis_button_qzone"></a>
 <!-- <a class="jiathis_button_kaixin001"></a> -->
  <a class="jiathis_button_copy"></a>
  <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank"></a>
  <a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript">
  var jiathis_config={
    hideMore:false
  }
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/uploads/avatar.jpg" alt="孟玉晶">
          <p class="site-author-name" itemprop="name">孟玉晶</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">57</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">101</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/huajianduzhuo" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://juejin.im/user/5921a68ea0bb9f005f57f51b" target="_blank" title="掘金">
                  
                    <i class="fa fa-fw fa-angle-double-down"></i>
                  
                  掘金
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://segmentfault.com/u/mengyj" target="_blank" title="segmentfault">
                  
                    <i class="fa fa-fw fa-crosshairs"></i>
                  
                  segmentfault
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              推荐阅读
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="https://developer.mozilla.org/zh-CN/" title="Mozilla中文社区" target="_blank">Mozilla中文社区</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.uisdc.com/" title="优设" target="_blank">优设</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.alloyteam.com/" title="腾讯前端" target="_blank">腾讯前端</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://ife.baidu.com/" title="百度前端技术学院" target="_blank">百度前端技术学院</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://taobaofed.org/" title="淘宝前端" target="_blank">淘宝前端</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.zhangxinxu.com/" title="张鑫旭" target="_blank">张鑫旭</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.daqianduan.com/" title="大前端" target="_blank">大前端</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#安装与使用"><span class="nav-number">1.</span> <span class="nav-text">安装与使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tsconfig-json"><span class="nav-number">2.</span> <span class="nav-text">tsconfig.json</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置"><span class="nav-number">2.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编译选项"><span class="nav-number">2.2.</span> <span class="nav-text">编译选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基础类型"><span class="nav-number">3.</span> <span class="nav-text">基础类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#布尔"><span class="nav-number">3.1.</span> <span class="nav-text">布尔</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字"><span class="nav-number">3.2.</span> <span class="nav-text">数字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">3.3.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-number">3.4.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#元组（tuple）"><span class="nav-number">3.5.</span> <span class="nav-text">元组（tuple）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举（enum）"><span class="nav-number">3.6.</span> <span class="nav-text">枚举（enum）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#any"><span class="nav-number">3.7.</span> <span class="nav-text">any</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void"><span class="nav-number">3.8.</span> <span class="nav-text">void</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Null-和-Undefined"><span class="nav-number">3.9.</span> <span class="nav-text">Null 和 Undefined</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#never"><span class="nav-number">3.10.</span> <span class="nav-text">never</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#object"><span class="nav-number">3.11.</span> <span class="nav-text">object</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型断言"><span class="nav-number">3.12.</span> <span class="nav-text">类型断言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接口"><span class="nav-number">4.</span> <span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可选属性"><span class="nav-number">4.1.</span> <span class="nav-text">可选属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#只读属性"><span class="nav-number">4.2.</span> <span class="nav-text">只读属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ReadonlyArray"><span class="nav-number">4.3.</span> <span class="nav-text">ReadonlyArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#额外的属性检查"><span class="nav-number">4.4.</span> <span class="nav-text">额外的属性检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数类型"><span class="nav-number">4.5.</span> <span class="nav-text">函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可索引的类型"><span class="nav-number">4.6.</span> <span class="nav-text">可索引的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类类型"><span class="nav-number">4.7.</span> <span class="nav-text">类类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#继承接口"><span class="nav-number">4.8.</span> <span class="nav-text">继承接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合类型"><span class="nav-number">4.9.</span> <span class="nav-text">混合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接口继承类"><span class="nav-number">4.10.</span> <span class="nav-text">接口继承类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类"><span class="nav-number">5.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承"><span class="nav-number">5.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符-public"><span class="nav-number">5.2.</span> <span class="nav-text">修饰符 public</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符-private"><span class="nav-number">5.3.</span> <span class="nav-text">修饰符 private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符-protected"><span class="nav-number">5.4.</span> <span class="nav-text">修饰符 protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修饰符-readonly"><span class="nav-number">5.5.</span> <span class="nav-text">修饰符 readonly</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数属性"><span class="nav-number">5.6.</span> <span class="nav-text">参数属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存取器"><span class="nav-number">5.7.</span> <span class="nav-text">存取器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态属性"><span class="nav-number">5.8.</span> <span class="nav-text">静态属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抽象类"><span class="nav-number">5.9.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#把类当接口使用"><span class="nav-number">5.10.</span> <span class="nav-text">把类当接口使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">6.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数类型-1"><span class="nav-number">6.1.</span> <span class="nav-text">函数类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选参数和默认参数"><span class="nav-number">6.2.</span> <span class="nav-text">可选参数和默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#剩余参数"><span class="nav-number">6.3.</span> <span class="nav-text">剩余参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-参数"><span class="nav-number">6.4.</span> <span class="nav-text">this 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重载"><span class="nav-number">6.5.</span> <span class="nav-text">重载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#泛型"><span class="nav-number">7.</span> <span class="nav-text">泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用泛型变量"><span class="nav-number">7.1.</span> <span class="nav-text">使用泛型变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型接口"><span class="nav-number">7.2.</span> <span class="nav-text">泛型接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型类"><span class="nav-number">7.3.</span> <span class="nav-text">泛型类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型约束"><span class="nav-number">7.4.</span> <span class="nav-text">泛型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在泛型约束中使用类型参数"><span class="nav-number">7.5.</span> <span class="nav-text">在泛型约束中使用类型参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在泛型里使用类类型"><span class="nav-number">7.6.</span> <span class="nav-text">在泛型里使用类类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举"><span class="nav-number">8.</span> <span class="nav-text">枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数字枚举"><span class="nav-number">8.1.</span> <span class="nav-text">数字枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串枚举"><span class="nav-number">8.2.</span> <span class="nav-text">字符串枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异构枚举（Heterogeneous-enums）"><span class="nav-number">8.3.</span> <span class="nav-text">异构枚举（Heterogeneous enums）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算的和常量成员"><span class="nav-number">8.4.</span> <span class="nav-text">计算的和常量成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#反向映射"><span class="nav-number">8.5.</span> <span class="nav-text">反向映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const-枚举"><span class="nav-number">8.6.</span> <span class="nav-text">const 枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部枚举"><span class="nav-number">8.7.</span> <span class="nav-text">外部枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级类型"><span class="nav-number">9.</span> <span class="nav-text">高级类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#交叉类型（Intersection-Types）"><span class="nav-number">9.1.</span> <span class="nav-text">交叉类型（Intersection Types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#联合类型（Union-Types）"><span class="nav-number">9.2.</span> <span class="nav-text">联合类型（Union Types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型保护与区分类型"><span class="nav-number">9.3.</span> <span class="nav-text">类型保护与区分类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户自定义的类型保护"><span class="nav-number">9.3.1.</span> <span class="nav-text">用户自定义的类型保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typeof-类型保护"><span class="nav-number">9.3.2.</span> <span class="nav-text">typeof 类型保护</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#instanceof-类型保护"><span class="nav-number">9.3.3.</span> <span class="nav-text">instanceof 类型保护</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可以为-null-的类型"><span class="nav-number">9.4.</span> <span class="nav-text">可以为 null 的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可选参数和可选属性"><span class="nav-number">9.4.1.</span> <span class="nav-text">可选参数和可选属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类型保护和类型断言"><span class="nav-number">9.4.2.</span> <span class="nav-text">类型保护和类型断言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型别名"><span class="nav-number">9.5.</span> <span class="nav-text">类型别名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#接口-vs-类型别名"><span class="nav-number">9.5.1.</span> <span class="nav-text">接口 vs 类型别名</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串字面量类型"><span class="nav-number">9.6.</span> <span class="nav-text">字符串字面量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字字面量类型"><span class="nav-number">9.7.</span> <span class="nav-text">数字字面量类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举成员类型"><span class="nav-number">9.8.</span> <span class="nav-text">枚举成员类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可辨识联合（Discriminated-Unions）"><span class="nav-number">9.9.</span> <span class="nav-text">可辨识联合（Discriminated Unions）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整性检查"><span class="nav-number">9.10.</span> <span class="nav-text">完整性检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多态的-this-类型"><span class="nav-number">9.11.</span> <span class="nav-text">多态的 this 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引类型（Index-types）"><span class="nav-number">9.12.</span> <span class="nav-text">索引类型（Index types）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射类型"><span class="nav-number">9.13.</span> <span class="nav-text">映射类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块"><span class="nav-number">10.</span> <span class="nav-text">模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#导出"><span class="nav-number">10.1.</span> <span class="nav-text">导出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导出声明"><span class="nav-number">10.1.1.</span> <span class="nav-text">导出声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导出语句"><span class="nav-number">10.1.2.</span> <span class="nav-text">导出语句</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新导出"><span class="nav-number">10.1.3.</span> <span class="nav-text">重新导出</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入"><span class="nav-number">10.2.</span> <span class="nav-text">导入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导入一个模块中的某个导出内容"><span class="nav-number">10.2.1.</span> <span class="nav-text">导入一个模块中的某个导出内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将整个模块导入到一个变量"><span class="nav-number">10.2.2.</span> <span class="nav-text">将整个模块导入到一个变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具有副作用的导入模块"><span class="nav-number">10.2.3.</span> <span class="nav-text">具有副作用的导入模块</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#默认导出"><span class="nav-number">10.3.</span> <span class="nav-text">默认导出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#export-和-import-require"><span class="nav-number">10.4.</span> <span class="nav-text">export = 和 import = require()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用其他的-javascript-库"><span class="nav-number">10.5.</span> <span class="nav-text">使用其他的 javascript 库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部模块"><span class="nav-number">10.5.1.</span> <span class="nav-text">外部模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外部模块简写"><span class="nav-number">10.5.2.</span> <span class="nav-text">外部模块简写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#模块声明通配符"><span class="nav-number">10.5.3.</span> <span class="nav-text">模块声明通配符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建模块结构指导"><span class="nav-number">10.6.</span> <span class="nav-text">创建模块结构指导</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名空间"><span class="nav-number">11.</span> <span class="nav-text">命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分离到多文件"><span class="nav-number">11.1.</span> <span class="nav-text">分离到多文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#别名"><span class="nav-number">11.2.</span> <span class="nav-text">别名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Decorators"><span class="nav-number">12.</span> <span class="nav-text">Decorators</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Decorator-基本使用"><span class="nav-number">12.1.</span> <span class="nav-text">Decorator 基本使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#绑定参数"><span class="nav-number">12.2.</span> <span class="nav-text">绑定参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类装饰器"><span class="nav-number">12.3.</span> <span class="nav-text">类装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法装饰器"><span class="nav-number">12.4.</span> <span class="nav-text">方法装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问器装饰器"><span class="nav-number">12.5.</span> <span class="nav-text">访问器装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#属性装饰器"><span class="nav-number">12.6.</span> <span class="nav-text">属性装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参数装饰器"><span class="nav-number">12.7.</span> <span class="nav-text">参数装饰器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#装饰器组合"><span class="nav-number">12.8.</span> <span class="nav-text">装饰器组合</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<!-- <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_page_pv">
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</span>
</div> -->

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">孟玉晶</span>
  <a class="theme-link" href="http://www.beian.miit.gov.cn"> 京ICP备20011762号</a>
</div>

<!-- 
 <div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div> 
 -->

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"> 本站访问数</i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"> 本站总访问量</i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/texiao.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>


  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (search_path.endsWith("json")) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.1"></script>


  

  	<a href="https://github.com/huajianduzhuo"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 100;" src="https://camo.githubusercontent.com/c6286ade715e9bea433b4705870de482a654f78a/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f77686974655f6666666666662e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png"></a>

</body>
</html>
