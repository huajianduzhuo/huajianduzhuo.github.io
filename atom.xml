<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>勤，以随心</title>
  <icon>https://www.gravatar.com/avatar/6f43874213f5fd43184a23bec1bff0fe</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mengyujing.com/"/>
  <updated>2019-11-24T14:26:37.228Z</updated>
  <id>http://mengyujing.com/</id>
  
  <author>
    <name>孟玉晶</name>
    <email>yujing_m4370@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Proxy学习笔记</title>
    <link href="http://mengyujing.com/Proxy%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mengyujing.com/Proxy学习笔记/</id>
    <published>2019-11-24T14:24:15.000Z</published>
    <updated>2019-11-24T14:26:37.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>Proxy 用于在目标对象之前架设一层拦截，外界对对象的访问，都必须经过这层拦截。因此可以对外界的访问进行过滤和改写。</p><a id="more"></a><h2 id="Proxy-构造函数"><a href="#Proxy-构造函数" class="headerlink" title="Proxy 构造函数"></a>Proxy 构造函数</h2><p>通过 Proxy 构造函数，来生成 proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure><p><code>target</code> 表示需要被代理的目标对象，<code>handler</code> 用来定义拦截行为，也是一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">29</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(proxy.aaa) <span class="comment">// 29</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.aaa) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>如上，通过定义 <code>get</code> 方法，用来拦截所有对 <code>obj</code> 对象的访问。因此虽然 <code>obj</code> 对象是一个空对象，但是访问 <code>aaa</code> 属性，仍能得到结果 29.</p><blockquote><p>需要注意的是，要使代理起作用，访问 obj 目标对象时，要通过 <code>proxy</code> 实例，直接使用目标对象 obj，代理无作用。</p></blockquote><p>如果 handler 是一个空对象，没有设置任何拦截，则访问 proxy 实例等同于访问 target 目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxy2 = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj2, &#123;&#125;)</span><br><span class="line">proxy2.bbb = <span class="string">'白宇'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.bbb) <span class="comment">// 白宇</span></span><br></pre></td></tr></table></figure><h2 id="handler-代理配置方法"><a href="#handler-代理配置方法" class="headerlink" title="handler 代理配置方法"></a>handler 代理配置方法</h2><p>在 handler 中可以设置的拦截操作如下</p><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get (target, key, receiver)</code></p><p>target 为目标对象，key 为属性名，receiver 为原始的读操作所在的对象，一般是 proxy 实例。</p><p>拦截访问对象的属性的操作，如 proxy.foo 或 proxy[‘foo’]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'白宇'</span>,</span><br><span class="line">  say () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get '</span> + key)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.name <span class="comment">// get name</span></span><br><span class="line">proxy.say <span class="comment">// get say</span></span><br><span class="line">proxy.say() <span class="comment">// get say</span></span><br></pre></td></tr></table></figure><p>receiver 有时候不是 proxy 实例，比如当 proxy 实例作为原型的时候，这时 receiver 指向原始的读操作所在的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pr = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key, receiver) &#123;</span><br><span class="line">    <span class="keyword">return</span> receiver</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(pr.a === pr) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> ob = <span class="built_in">Object</span>.create(pr)</span><br><span class="line"><span class="built_in">console</span>.log(ob.a === pr) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(ob.a === ob) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p><code>set (target, key, value, receiver)</code></p><p>拦截对对象属性的赋值操作，如 <code>proxy.foo = &#39;aaa&#39;</code></p><p><strong>作用：</strong></p><ul><li>赋值时对属性值进行校验</li><li>设置私有属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invariant</span>(<span class="params">key, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Invalid attempt to <span class="subst">$&#123;action&#125;</span> private '<span class="subst">$&#123;key&#125;</span>' property`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span> (target, key) &#123;</span><br><span class="line">    invariant(key, <span class="string">'get'</span>)</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> (target, key, value) &#123;</span><br><span class="line">    invariant(key, <span class="string">'set'</span>)</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'the age is invalid'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    target[key] = value</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxy.age = <span class="number">120</span> <span class="comment">// the age is invalid</span></span><br><span class="line">proxy.age = <span class="number">29</span></span><br><span class="line">proxy._name <span class="comment">// Invalid attempt to get private '_name' property</span></span><br><span class="line">proxy._name = <span class="string">'baiyu'</span> <span class="comment">// Invalid attempt to set private '_name' property</span></span><br></pre></td></tr></table></figure><blockquote><p><code>set</code> 方法不 return true，在严格模式下会报错。</p></blockquote><h3 id="has"><a href="#has" class="headerlink" title="has"></a>has</h3><p><code>has (target, key)</code></p><p>拦截 <code>key in proxy</code> 操作，返回一个布尔值</p><blockquote><p><code>has</code> 拦截对 <code>for...in</code> 循环不生效</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> src = &#123;<span class="attr">name</span>: <span class="string">'白宇'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> tar = <span class="built_in">Object</span>.create(src)</span><br><span class="line">tar.age = <span class="number">29</span></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(tar, &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'in proxy'</span>)</span><br><span class="line">    <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span> <span class="keyword">in</span> p) <span class="comment">// in proxy , true</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> p) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p[key]) <span class="comment">// 29, 白宇</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty"></a>deleteProperty</h3><p><code>deleteProperty (target, key)</code></p><p>拦截 <code>delete proxy[key]</code> 操作，返回一个布尔值</p><p>如果该方法返回 false 或报错，则属性无法被删除</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">_name</span>: <span class="string">'white'</span>, <span class="attr">name</span>: <span class="string">'白宇'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  deleteProperty (target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'_'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`private property <span class="subst">$&#123;key&#125;</span> cannot be deleted`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">delete</span> p.name <span class="comment">// 成功删除</span></span><br><span class="line"><span class="keyword">delete</span> p._name <span class="comment">// 报错：private property _name cannot be deleted</span></span><br></pre></td></tr></table></figure><h3 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys"></a>ownKeys</h3><p><code>ownKeys (target)</code></p><p>拦截以下操作，返回一个数组</p><ul><li><code>Object.getOwnPropertyNames(proxy)</code></li><li><code>Object.getOwnPropertySymbols(proxy)</code></li><li><code>Object.keys(proxy)</code></li><li><code>for...in</code></li></ul><h3 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor"></a>getOwnPropertyDescriptor</h3><p><code>getOwnPropertyDescriptor (target, key)</code></p><p>拦截 <code>Object.getOwnPropertyDescriptor(proxy, key)</code> 操作</p><h3 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty"></a>defineProperty</h3><p><code>defineProperty (target, key, propDesc)</code></p><p>拦截对 target 添加属性、为属性赋值对操作，不拦截删除属性对操作</p><p><code>return false</code> 则对属性的操作不生效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">age</span>: <span class="number">29</span>&#125;, &#123;</span><br><span class="line">  defineProperty (target, key, propDesc) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'propDesc: '</span>, propDesc) <span class="comment">// &#123;configurable: true, enumerable: true, value: "白宇", writable: true&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.name = <span class="string">'白宇'</span> <span class="comment">// 没有生效</span></span><br><span class="line">p.age = <span class="number">30</span> <span class="comment">// 没有生效。  propDesc 为 &#123; value: 30 &#125;</span></span><br><span class="line"><span class="keyword">delete</span> p.age <span class="comment">// 可以生效。  没有进入 defineProperty 拦截方法内</span></span><br></pre></td></tr></table></figure><h3 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions"></a>preventExtensions</h3><p><code>preventExtensions (target)</code></p><p>拦截 <code>Object.preventExtensions(proxy)</code> 操作</p><h3 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h3><p><code>getPrototypeOf (target)</code></p><p>拦截下列操作</p><ul><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myProto = &#123;<span class="attr">name</span>: <span class="string">'白宇'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  getPrototypeOf (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> myProto</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__) <span class="comment">// &#123;name: "白宇"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.name) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>返回值必须是对象或 null。如果目标对象不可扩展，则必须返回目标对象的原型对象。</p></blockquote><h3 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible"></a>isExtensible</h3><p><code>isExtensible (target)</code></p><p>拦截 <code>Object.isExtensible(proxy)</code> 操作</p><ul><li>必须返回布尔值，否则返回值会被自动转为布尔值</li><li>返回值必须与 target 的 isExtensible 属性保持一致，否则会抛出错误</li></ul><h3 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h3><p><code>setPrototypeOf (target, proto)</code></p><p>拦截 <code>Object.setPrototypeOf(proxy, proto)</code> 操作</p><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p><code>apply (target, thisObj, args)</code></p><p>当 target 为函数时使用，拦截 proxy 作为函数调用的操作。如 <code>proxy(...args)</code>、<code>proxy.call(thisObj, ...args)</code>、proxy.apply(thisObj, args)</p><p><code>thisObj</code> 为目标函数对上下文对象 this，<code>args</code> 为参数数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"他的名字是"</span> + name + <span class="string">"，今年"</span> + age + <span class="string">"岁了。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxyFun = <span class="keyword">new</span> <span class="built_in">Proxy</span>(fun, &#123;</span><br><span class="line">  apply (target, thisObj, args) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(thisObj)</span><br><span class="line">    <span class="built_in">console</span>.log(args) <span class="comment">// ['白宇', 29]</span></span><br><span class="line">    <span class="keyword">return</span> target(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">proxyFun(<span class="string">'白宇'</span>, <span class="number">29</span>) <span class="comment">// thisObj 为 undefined</span></span><br><span class="line">proxyFun.apply(&#123;&#125;, [<span class="string">'白宇'</span>, <span class="number">29</span>]) <span class="comment">// thisObj 为 &#123;&#125;</span></span><br></pre></td></tr></table></figure><h3 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h3><p><code>construct (target, args)</code></p><p>当 target 为构造函数时使用，拦截 proxy 作为构造函数调用当操作。如 <code>new proxy(...args)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fun</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.fullName = lastName + firstName</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxyFun = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Fun, &#123;</span><br><span class="line">  construct (target, args) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(args) <span class="comment">// ['宇', '白']</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="keyword">new</span> target(...args)</span><br><span class="line">    res.age = <span class="number">29</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> proxyFun(<span class="string">'宇'</span>, <span class="string">'白'</span>)) <span class="comment">// Fun &#123;fullName: '白宇', age: 29&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Proxy-revocable"><a href="#Proxy-revocable" class="headerlink" title="Proxy.revocable()"></a>Proxy.revocable()</h2><p><code>Proxy.revocable</code> 方法返回一个可取消的 Proxy 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;proxy, revoke&#125; = <span class="built_in">Proxy</span>.revocable(&#123;&#125;, &#123;&#125;)</span><br><span class="line">proxy.name = <span class="string">'白宇'</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// 白宇</span></span><br><span class="line">revoke()</span><br><span class="line"><span class="built_in">console</span>.log(proxy.name) <span class="comment">// 报错：Cannot perform 'get' on a proxy that has been revoked</span></span><br></pre></td></tr></table></figure><p><code>Proxy.revocable</code> 方法返回一个对象，该对象的 <code>proxy</code> 属性是 <code>Proxy</code> 实例，<code>revoke</code> 属性是一个函数，可以取消 <code>Proxy</code> 实例。上面代码中，当执行 <code>revoke</code> 函数之后，再访问 <code>Proxy</code> 实例，就会抛出一个错误。</p><p><code>Proxy.revocable</code> 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。</p><h2 id="this-问题"><a href="#this-问题" class="headerlink" title="this 问题"></a>this 问题</h2><p>Proxy 代理后，目标对象内部的方法中的 <code>this</code> 会指向代理对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;</span><br><span class="line">  fun () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === p)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> === target)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;)</span><br><span class="line">target.fun() <span class="comment">// false true</span></span><br><span class="line">p.fun() <span class="comment">// true false</span></span><br></pre></td></tr></table></figure><blockquote><p>此外，有些原生对象的内部属性，只有通过正确的 <code>this</code> 才能拿到，所以 <code>Proxy</code> 也无法代理这些原生对象的属性。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(t, &#123;&#125;)</span><br><span class="line">p.getDate() <span class="comment">// 报错：this is not a Date object</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Proxy&quot;&gt;&lt;a href=&quot;#Proxy&quot; class=&quot;headerlink&quot; title=&quot;Proxy&quot;&gt;&lt;/a&gt;Proxy&lt;/h1&gt;&lt;p&gt;Proxy 用于在目标对象之前架设一层拦截，外界对对象的访问，都必须经过这层拦截。因此可以对外界的访问进行过滤和改写。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://mengyujing.com/categories/ES6/"/>
    
    
      <category term="Proxy" scheme="http://mengyujing.com/tags/Proxy/"/>
    
  </entry>
  
  <entry>
    <title>实现移动端vue长按指令插件</title>
    <link href="http://mengyujing.com/%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AFvue%E9%95%BF%E6%8C%89%E6%8C%87%E4%BB%A4%E6%8F%92%E4%BB%B6/"/>
    <id>http://mengyujing.com/实现移动端vue长按指令插件/</id>
    <published>2019-11-09T10:59:10.000Z</published>
    <updated>2019-11-09T11:12:38.240Z</updated>
    
    <content type="html"><![CDATA[<p>使用定时器实现移动端长按事件，使用 vue 指令为元素添加长按事件</p><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="http://mengyujing.com/longtapDemo/#/longtap">demo</a>  （在手机上查看）</p><p><a href="https://github.com/huajianduzhuo/vueConfig/tree/master/plugins/LongTap" target="_blank" rel="noopener">插件github地址</a></p><a id="more"></a><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>判断为长按事件的条件：</p><ul><li>手指停留超过一段时间，参见下面的参数<code>time</code></li><li>手指移动小于一定距离，参见下面的参数<code>disX</code>和<code>disY</code></li></ul><h2 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h2><p><code>import LongTap from &#39;./plugins/LongTap&#39;</code></p><p><code>Vue.use(LongTap)</code></p><h2 id="注册长按事件"><a href="#注册长按事件" class="headerlink" title="注册长按事件"></a>注册长按事件</h2><p><code>&lt;div v-longtap:[arg]=&quot;callback&quot;&gt;&lt;/div&gt;</code></p><p>或</p><p><code>&lt;div v-longtap:[arg]=&quot;{handler: cb}&quot;&gt;&lt;/div&gt;</code></p><h2 id="对象字面量配置参数"><a href="#对象字面量配置参数" class="headerlink" title="对象字面量配置参数"></a>对象字面量配置参数</h2><p>使用对象字面量方式绑定长按事件，可以配置一些参数</p><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">类型</th><th style="text-align:center">是否必需</th><th style="text-align:center">默认值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">handler</td><td style="text-align:center">函数</td><td style="text-align:center">是</td><td style="text-align:center">无</td><td style="text-align:center">长按事件回调函数</td></tr><tr><td style="text-align:center">time</td><td style="text-align:center">integer</td><td style="text-align:center">否</td><td style="text-align:center">1200</td><td style="text-align:center">单位：ms，长按间隔时间，必须超过 500ms</td></tr><tr><td style="text-align:center">disX</td><td style="text-align:center">number</td><td style="text-align:center">否</td><td style="text-align:center">10</td><td style="text-align:center">单位：px，判断手指是否移动了的间隔，若为负数，则允许 X 方向上的移动</td></tr><tr><td style="text-align:center">disY</td><td style="text-align:center">number</td><td style="text-align:center">否</td><td style="text-align:center">10</td><td style="text-align:center">单位：px，判断手指是否移动了的间隔，若为负数，则允许 Y 方向上的移动</td></tr></tbody></table><h2 id="长按回调函数参数"><a href="#长按回调函数参数" class="headerlink" title="长按回调函数参数"></a>长按回调函数参数</h2><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">类型</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">event</td><td style="text-align:center">Event</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">data</td><td style="text-align:center">any</td><td style="text-align:center">注册事件时传入的动态指令参数</td></tr><tr><td style="text-align:center">vNode</td><td style="text-align:center">vNode</td><td style="text-align:center">触发长按事件的虚拟节点</td></tr></tbody></table><h2 id="长按时元素样式"><a href="#长按时元素样式" class="headerlink" title="长按时元素样式"></a>长按时元素样式</h2><p>长按元素时，可以为该元素添加激活时的样式，只需要添加一个全局的样式 <code>longtap-active</code> 即可，若有与元素本身的样式重复的，应添加 <code>!important</code>。</p><blockquote><p>该样式在点击时也会应用。</p></blockquote><h2 id="demo-代码"><a href="#demo-代码" class="headerlink" title="demo 代码"></a>demo 代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div class=&quot;item&quot;</span><br><span class="line">        v-for=&quot;(item, index) in list&quot;</span><br><span class="line">        @click=&quot;handleClick&quot;</span><br><span class="line">        v-longtap:[index]=&quot;&#123;handler: longtapCB, time: 1000, disX: 10&#125;&quot;</span><br><span class="line">        :key=&quot;index&quot;&gt;</span><br><span class="line">        &#123;&#123;item&#125;&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    longtapCB (event, index, vNode) &#123;</span><br><span class="line">      this.$menu(event, vNode.elm, &#123;</span><br><span class="line">        menuDirection: &apos;horizontal&apos;,</span><br><span class="line">        data: &#123;index, name: this.list[index]&#125;,</span><br><span class="line">        items: &#123;copy: true&#125;,</span><br><span class="line">        customItems: [&#123;</span><br><span class="line">          menuName: &apos;详情&apos;,</span><br><span class="line">          handler: this.showInfo</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    showInfo (data) &#123;</span><br><span class="line">      this.$message(&#123;message: data.index + &apos;, &apos; + data.name, duration: 1000&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    handleClick (event) &#123;</span><br><span class="line">      this.$menu(event, event.target, &#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.list = [&apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;, &apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;, &apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;, &apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;, &apos;aa&apos;, &apos;bb&apos;, &apos;cc&apos;, &apos;dd&apos;]</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> r = <span class="literal">null</span>, <span class="comment">// setTimeout 标志</span></span><br><span class="line">    cr = <span class="literal">null</span> <span class="comment">// 改变长按元素样式的定时器</span></span><br><span class="line"><span class="keyword">let</span> startX = <span class="number">0</span>, <span class="comment">// touchstart 时手指的位置，用于 touchmove 时判断手指是否移动</span></span><br><span class="line">    startY = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> firstTouch = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inserted (el, binding, vNode) &#123;</span><br><span class="line">    <span class="keyword">let</span> delayTime = <span class="number">1200</span></span><br><span class="line">    <span class="keyword">let</span> disX = <span class="number">10</span>,</span><br><span class="line">        disY = <span class="number">10</span></span><br><span class="line">    <span class="keyword">let</span> value = binding.value</span><br><span class="line">    <span class="keyword">let</span> data = binding.arg</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 可通过传入对象字面量的方式，指定长按时间：v-longtap = "&#123;time: 2000&#125;"</span></span><br><span class="line"><span class="comment">     * 时间必须超过 500ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value.time &amp;&amp; <span class="built_in">Number</span>.isInteger(value.time) &amp;&amp; value.time &gt;= <span class="number">500</span>) &#123;</span><br><span class="line">      delayTime = value.time</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 可通过传入对象字面量的方式，指定手指移动间隔：v-longtap = "&#123;disX: 10, disY: 10&#125;"</span></span><br><span class="line"><span class="comment">     * 如果某一个值为负数，则不判断那个方向</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value.disX &amp;&amp; <span class="built_in">Number</span>.isInteger(value.disX)) &#123;</span><br><span class="line">      disX = value.disX</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; value.disY &amp;&amp; <span class="built_in">Number</span>.isInteger(value.disY)) &#123;</span><br><span class="line">      disY = value.disY</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 给元素绑定 touchstart 事件</span></span><br><span class="line"><span class="comment">     * 添加一个延迟函数，delayTime 后执行长按回调函数</span></span><br><span class="line"><span class="comment">     * 如果正存在一个长按事件，则本次不执行（最下面为 document 绑定 click 事件，用于取消一次已经触发的长按事件）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    el.addEventListener(<span class="string">'touchstart'</span>, event =&gt; &#123;</span><br><span class="line">      firstTouch = <span class="literal">true</span></span><br><span class="line">      <span class="comment">/** </span></span><br><span class="line"><span class="comment">       * touchend 时延迟删除元素样式</span></span><br><span class="line"><span class="comment">       * 防止多次点击样式延迟删除导致长按时样式被删除</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (cr) &#123;</span><br><span class="line">        clearTimeout(cr)</span><br><span class="line">        cr = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      addActiveClass(el, <span class="literal">true</span>)</span><br><span class="line">      <span class="keyword">let</span> touch = event.changedTouches[<span class="number">0</span>]</span><br><span class="line">      startX = touch.clientX</span><br><span class="line">      startY = touch.clientY</span><br><span class="line">      <span class="comment">// settimeout 函数</span></span><br><span class="line">      r = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        r = <span class="literal">null</span></span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 如果绑定的值是函数，则执行</span></span><br><span class="line"><span class="comment">         * v-longtap = "cb"</span></span><br><span class="line"><span class="comment">         * v-longtap = "&#123;handler: cb&#125;"</span></span><br><span class="line"><span class="comment">         * 不能是：v-longtap = "cb()"，这种形式绑定时就会执行 cb</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">          value(event, data, vNode)</span><br><span class="line">          event.preventDefault()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; value.handler &amp;&amp; <span class="keyword">typeof</span> value.handler === <span class="string">'function'</span>) &#123;</span><br><span class="line">          value.handler(event, data, vNode)</span><br><span class="line">          event.preventDefault()</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, delayTime)</span><br><span class="line">      touch = <span class="literal">null</span></span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 给元素绑定 touchmove 事件</span></span><br><span class="line"><span class="comment">     * 若手指移动超过 10 像素，则不是长按事件，取消 timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    el.addEventListener(<span class="string">'touchmove'</span>, event =&gt; &#123;</span><br><span class="line">      <span class="keyword">let</span> touch = event.changedTouches[<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">let</span> diffX = <span class="built_in">Math</span>.abs(touch.clientX - startX)</span><br><span class="line">      <span class="keyword">let</span> diffY = <span class="built_in">Math</span>.abs(touch.clientY - startY)</span><br><span class="line">      <span class="keyword">if</span> ((disX &gt; <span class="number">0</span> &amp;&amp; diffX &gt; disX) || (disY &gt; <span class="number">0</span> &amp;&amp; diffY &gt; disY)) &#123;</span><br><span class="line">        firstTouch &amp;&amp; addActiveClass(el, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (r) &#123;</span><br><span class="line">          clearTimeout(r)</span><br><span class="line">          r = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        firstTouch = <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      touch = <span class="literal">null</span></span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 给元素绑定 touchend 事件</span></span><br><span class="line"><span class="comment">     * 手指离开时，如果时间没有超过 delayTime，则不是长按事件，取消 timeout</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    el.addEventListener(<span class="string">'touchend'</span>, event =&gt; &#123;</span><br><span class="line">      firstTouch = <span class="literal">false</span></span><br><span class="line">      cr = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        addActiveClass(el, <span class="literal">false</span>)</span><br><span class="line">      &#125;, <span class="number">100</span>)</span><br><span class="line">      <span class="keyword">if</span> (r) &#123;</span><br><span class="line">        clearTimeout(r)</span><br><span class="line">        r = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 禁止手机浏览器菜单</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    el.addEventListener(<span class="string">'contextmenu'</span>, event =&gt; &#123;</span><br><span class="line">      event.preventDefault()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addActiveClass</span>(<span class="params">el, opt</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cns = el.className.split(<span class="string">' '</span>)</span><br><span class="line">  <span class="keyword">let</span> index = cns.indexOf(<span class="string">'longtap-active'</span>)</span><br><span class="line">  <span class="keyword">if</span> (opt) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">      el.style.transition = <span class="string">'all 0.3s'</span></span><br><span class="line">      cns.push(<span class="string">'longtap-active'</span>)</span><br><span class="line">      el.className = cns.join(<span class="string">' '</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      cns.splice(index, <span class="number">1</span>)</span><br><span class="line">      el.className = cns.join(<span class="string">' '</span>)</span><br><span class="line">      el.style.transition = <span class="string">'all 0s'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用定时器实现移动端长按事件，使用 vue 指令为元素添加长按事件&lt;/p&gt;
&lt;h1 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://mengyujing.com/longtapDemo/#/longtap&quot;&gt;demo&lt;/a&gt;  （在手机上查看）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/huajianduzhuo/vueConfig/tree/master/plugins/LongTap&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;插件github地址&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mengyujing.com/categories/Vue/"/>
    
    
      <category term="vue" scheme="http://mengyujing.com/tags/vue/"/>
    
      <category term="移动端" scheme="http://mengyujing.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="长按指令" scheme="http://mengyujing.com/tags/%E9%95%BF%E6%8C%89%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>serviceWorker介绍与使用</title>
    <link href="http://mengyujing.com/serviceWorker%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://mengyujing.com/serviceWorker介绍与使用/</id>
    <published>2019-10-31T12:24:09.000Z</published>
    <updated>2019-10-31T13:25:05.564Z</updated>
    
    <content type="html"><![CDATA[<p>Service Worker 是一个运行在浏览器后台的线程，与网页不同的是，Service Worker 为那些无需页面和用户交互的功能开启了一扇大门。目前已经实现的功能包括 推送通知 和 后台同步。</p><p><a href="https://github.com/huajianduzhuo/pwa-learn" target="_blank" rel="noopener">demo 代码 GitHub 地址</a><br><a id="more"></a></p><h1 id="Service-Worker-介绍"><a href="#Service-Worker-介绍" class="headerlink" title="Service Worker 介绍"></a>Service Worker 介绍</h1><h2 id="Service-Worker-生命周期"><a href="#Service-Worker-生命周期" class="headerlink" title="Service Worker 生命周期"></a>Service Worker 生命周期</h2><p>Service Worker 的生命周期与我们的网页是完全分开的。</p><p>想要在网页中使用 Service Worker，需要在我们网页的 javascript 中注册它。注册一个 Service Worker，浏览器会在后台开始一个 Service Worker 的<strong>安装步骤</strong>。</p><p>代表性的，在安装 Service Worker 期间，我们会想要缓存一些静态资源。如果所有文件全部缓存成功，Service Worker 则为 <strong>installed</strong> 状态。如果任何一个文件加载并缓存失败，则安装步骤将会失败，Service Worker 则不会被激活。不过，如果文件加载失败，也无需担心，因为 Service Worker 会重新去尝试加载。</p><p>安装步骤成功之后，接下来便是<strong>激活步骤</strong>。激活步骤可以用来处理一些旧的版本的 Service Worker 中缓存的资源。</p><p>激活成功之后，serviceWorker 就可以控制页面了，但是只针对在成功注册了 Service Worker 后打开的页面。也就是说，页面打开时有没有 Service Worker，决定了接下来页面的生命周期内受不受 Service Worker 控制。所以，只有当页面刷新后，之前不受 Service Worker 控制的页面才有可能被控制起来。</p><p>一旦 Service Worker 控制了页面，它将会有两种状态：terminated（中止状态），可以节省内存，或者在网页发起请求时，处理 fetch 和 message 事件。</p><p>下面是一个简单版本的 Service Worker <strong>第一次安装时</strong>的生命周期图。</p><p><img src="https://developers.google.cn/web/fundamentals/primers/service-workers/images/sw-lifecycle.png" alt="image"></p><h2 id="使用-Service-Worker-的先决条件"><a href="#使用-Service-Worker-的先决条件" class="headerlink" title="使用 Service Worker 的先决条件"></a>使用 Service Worker 的先决条件</h2><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Service Worker 目前已经被 chrome、firefox、opera 支持。Edge 浏览器已经表示了支持，safari 未来也会支持 Service Worker。</p><h3 id="需要-HTTPS"><a href="#需要-HTTPS" class="headerlink" title="需要 HTTPS"></a>需要 HTTPS</h3><p>开发阶段，可以在 <code>localhost</code> 和 <code>127.0.0.1</code> 中使用 Service Worker，但是部署之后，则必需使用 HTTPS。</p><p>使用 Service Worker 我们可以劫持连接，伪造并过滤响应。这个强大的功能容易被黑客恶意使用，为了防止这种情况，我们必须使用 HTTPS 来保证连接不被干扰。</p><blockquote><p>可以使用 Github Pages 来调试我们的 demos。</p></blockquote><h2 id="注册一个-Service-Worker"><a href="#注册一个-Service-Worker" class="headerlink" title="注册一个 Service Worker"></a>注册一个 Service Worker</h2><p>首先需要创建一个 Service Worker 线程的 js 文件（<code>/public/sw.js</code>）</p><p>页面添加下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./sw.js'</span>, &#123;</span><br><span class="line">        scope: <span class="string">'/'</span></span><br><span class="line">      &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册成功</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration successful with scope: '</span>, registration.scope)</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 注册失败:(</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ServiceWorker registration failed: '</span>, err)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在浏览器中打开页面，查看 application –&gt; service wrokers，就可以看到当前 serviceWorker</p><ul><li><p>查看上面 then 方法的参数 <code>registration</code>，是一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/ServiceWorkerRegistration" target="_blank" rel="noopener">ServiceWorkerRegistration</a> 类型的对象</p></li><li><p>在 <code>sw.js</code> 中查看 <code>this</code>，是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerGlobalScope" target="_blank" rel="noopener">ServiceWorkerGlobalScope</a> 类型的对象</p></li></ul><p>我们可以没有负担的在每一次页面加载时调用 <code>register()</code>，浏览器会去查看当前网页是否已经注册过 Service Worker 线程并做出相应的处理。</p><p>需要注意 register 函数的第一个参数 <code>sw.js</code>，即 Service Worker 的 javascript 文件的位置。如果该文件位于项目的根目录，则 Service Worker 的作用域即为整个域名，换句话说，Service Worker 将会捕捉该域名下所有的 fetch 事件。如果 Service Worker 文件放在 <code>/example/sw.js</code>，则 Service Worker 仅捕捉 <code>/example/</code> URL 下的 fetch 事件。</p><p>register 函数的 <code>scope</code> 参数是可选的，用于指定想要 Service Worker 控制的内容的目录。如本例中，因为 <code>sw.js</code> 文件不是位于根目录，指定 scope 为 ‘/‘，则可以让 Service Worker 捕捉整个页面的 fetch 事件。</p><h2 id="安装一个-Service-Worker"><a href="#安装一个-Service-Worker" class="headerlink" title="安装一个 Service Worker"></a>安装一个 Service Worker</h2><p>当页面已经成功注册了一个 Service Worker，我们就可以将注意力转移到 Service Worker 的 js 文件，在该文件中我们可以处理 <code>install</code> 事件。</p><p>最基本的例子，我们需要为 install 事件添加一个 callback，并确定需要缓存的文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform install steps</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 install callback 中，我们需要遵从以下步骤：</p><ul><li>打开一个 Cache</li><li>缓存文件</li><li>确认是否所有需要缓存的文件全部缓存成功</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CACHE_NAME = <span class="string">'my-first-cache-v1'</span></span><br><span class="line"><span class="keyword">var</span> urlsToCache = [</span><br><span class="line">  <span class="string">'/style.css'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, event =&gt; &#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(CACHE_NAME)</span><br><span class="line">      .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'opened cache'</span>)</span><br><span class="line">        <span class="keyword">return</span> cache.addAll(urlsToCache)</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>event.waitUntil()</code> 方法接收一个 promise，并通过它知道安装消耗的时间，以及是否安装成功。</p><p>如果所有文件缓存成功，Service Worker 则为 installed。如果任何一个文件缓存失败，则 Service Worker 安装失败。</p><p>我们还可以在 install 事件中执行其他任务，或者避免把所有任务放在一个 install 事件中。</p><h2 id="缓存和返回请求"><a href="#缓存和返回请求" class="headerlink" title="缓存和返回请求"></a>缓存和返回请求</h2><p>Service Worker 安装成功，并且用户跳转到一个不同的页面或者刷新之后，Service Worker 将开始捕捉 fetch 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// cache 命中 - 返回response</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'response'</span>, response)</span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetch(event.request)</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>在 chrome 中测试发现，仅刷新页面缓存的文件没有从 cache 中获取，新打开一个页面可以看到 Service Worker 的 fetch 事件的效果。</p></blockquote><p>如果你想要渐进式的缓存资源，可以通过处理 fetch request 的 response，将其添加进 cache。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'fetch'</span>, event =&gt; &#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    caches.match(event.request)</span><br><span class="line">      .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// cache 命中 - 返回response</span></span><br><span class="line">        <span class="keyword">if</span> (response) &#123;</span><br><span class="line">          <span class="keyword">return</span> response</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cache 没命中，请求资源并且将响应添加进缓存</span></span><br><span class="line">        <span class="comment">// 因为 request 和 response 都是 stream，仅可以被使用一次，</span></span><br><span class="line">        <span class="comment">// 但是我们的浏览器页面和 cache 都要使用，所有需要复制一份</span></span><br><span class="line">        <span class="keyword">var</span> fetchRequest = event.request.clone()</span><br><span class="line">        <span class="keyword">return</span> fetch(fetchRequest).then(</span><br><span class="line">          response =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (!response || response.status !== <span class="number">200</span> || response.type !== <span class="string">'basic'</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> response</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> responseToCache = response.clone()</span><br><span class="line">            caches.open(CACHE_NAME)</span><br><span class="line">              .then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">                cache.put(event.request, responseToCache)</span><br><span class="line">              &#125;)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> response</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>response 的 type 为 basic，说明请求的资源来自当前域名。上面的代码校验不等于 basic 直接返回，意为来自其他域名的资源不进行缓存。</p><h2 id="Service-Worker-版本更新"><a href="#Service-Worker-版本更新" class="headerlink" title="Service Worker 版本更新"></a>Service Worker 版本更新</h2><p>更新 Service Worker 需要遵从以下步骤：</p><ol><li>更新 Service Worker javascript 文件。当用户打开我们的网站，浏览器会重新加载 Service Worker 的 js 文件，只要有改动，即会被视为新的。</li><li>开启新的 Service Worker，并触发 <code>install</code> 事件。</li><li>此时，旧的 Service Worker 仍然在控制当前页面，所以新的 Service Worker 将会进入 <code>waiting</code> 状态。</li><li>所有已打开的页面关闭之后，旧的 Service Worker 自动停止，新的 Service Worker 会在重新打开的页面生效。</li><li>一旦新的 Service Worker 生效，它的 <code>activate</code> 事件会被触发。</li></ol><p>在 <code>activate</code> 事件回调里，一个共同的任务是 cache 管理。必须在 <code>activate</code> 事件清理旧版本的 Service Worker，而不是在 <code>install</code> 事件中清理的原因是，如果在 <code>install</code> 事件中清理，则包括正在控制当前页面的 Service Worker 在内的所有旧版本 Service Worker，都会被停止，使得当前页面没有可以使用的 Service Worker。</p><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><p>英文：<a href="https://developers.google.cn/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener">https://developers.google.cn/web/fundamentals/primers/service-workers/</a></p><p>中文：<a href="https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/how-to-use-service-worker" target="_blank" rel="noopener">https://lavas.baidu.com/pwa/offline-and-cache-loading/service-worker/how-to-use-service-worker</a></p><h1 id="在项目中使用-Service-Worker"><a href="#在项目中使用-Service-Worker" class="headerlink" title="在项目中使用 Service Worker"></a>在项目中使用 Service Worker</h1><p>目前已经有成熟的 webpack 插件支持我们在项目中使用 Service Worker。</p><h2 id="sw-precache-webpack-plugin"><a href="#sw-precache-webpack-plugin" class="headerlink" title="sw-precache-webpack-plugin"></a>sw-precache-webpack-plugin</h2><p><a href="https://www.npmjs.com/package/sw-precache-webpack-plugin" target="_blank" rel="noopener">sw-precache-webpack-plugin</a> 使用 <code>sw-precache</code> 来生成 service worker 文件，并添加到构建目录。</p><p>由于 <code>sw-precache</code> 和 <code>sw-toolbox</code> 已经被弃用，所以我之前使用此插件到代码就不贴出来了。</p><h2 id="workbox-webpack-plugin"><a href="#workbox-webpack-plugin" class="headerlink" title="workbox-webpack-plugin"></a>workbox-webpack-plugin</h2><p><a href="https://www.npmjs.com/package/workbox-webpack-plugin" target="_blank" rel="noopener">workbox-webpack-plugin</a></p><p>npm 网站上此插件到文档链接无法打开，正确链接为 </p><p><a href="https://developers.google.cn/web/tools/workbox/modules/workbox-webpack-plugin" target="_blank" rel="noopener">https://developers.google.cn/web/tools/workbox/modules/workbox-webpack-plugin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Service Worker 是一个运行在浏览器后台的线程，与网页不同的是，Service Worker 为那些无需页面和用户交互的功能开启了一扇大门。目前已经实现的功能包括 推送通知 和 后台同步。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/huajianduzhuo/pwa-learn&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;demo 代码 GitHub 地址&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="pwa" scheme="http://mengyujing.com/categories/pwa/"/>
    
    
      <category term="pwa" scheme="http://mengyujing.com/tags/pwa/"/>
    
      <category term="serviceWorker" scheme="http://mengyujing.com/tags/serviceWorker/"/>
    
  </entry>
  
  <entry>
    <title>generator 学习笔记</title>
    <link href="http://mengyujing.com/generator-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mengyujing.com/generator-学习笔记/</id>
    <published>2018-06-04T15:45:35.000Z</published>
    <updated>2019-10-24T11:41:37.163Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener">阮一峰ES6 generator教程</a></p><p>demos 代码 github 地址：<a href="https://github.com/huajianduzhuo/es6/tree/master/generator" target="_blank" rel="noopener">https://github.com/huajianduzhuo/es6/tree/master/generator</a></p><h1 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h1><p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。<br><a id="more"></a></p><h2 id="generator-函数"><a href="#generator-函数" class="headerlink" title="generator 函数"></a>generator 函数</h2><ul><li>function 关键字与函数名之间有一个星号</li><li>函数体内部使用 yield 表达式，定义不同的内部状态</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator()</span><br></pre></td></tr></table></figure><p>上面代码定义了一个 Generator 函数 helloWorldGenerator，它内部有两个 yield 表达式（ hello 和 world ），即该函数有三个状态：hello，world 和 return 语句（结束执行）。</p><h2 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h2><p>执行 Generator 函数会返回一个遍历器对象（Iterator），也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>调用 Generator 函数后，该<strong>函数并不执行</strong>，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object）。</p><p>下一步，必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就<strong>从函数头部或上一次停下来的地方开始执行</strong>，直到遇到下一个 yield 表达式（或 return 语句）为止。换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 next 方法，就会返回一个有着 value 和 done 两个属性的对象。value 属性表示当前的内部状态的值，是 yield 表达式后面那个表达式的值；done 属性是一个布尔值，表示是否遍历结束。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo 02-generator.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generatorFun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'卫庄'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'盖聂'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'韩非'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> it = generatorFun() <span class="comment">// 无 log</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 1 &#123; value: "卫庄", done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 2 &#123; value: '盖聂', done: false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// 3 &#123; value: '韩非', done: true &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()) <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><h1 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h1><p>遍历器对象的 next 方法的运行逻辑如下</p><ul><li><p>遇到 yield 表达式，就暂停执行后面的操作，并将紧跟在 yield 后面的那个表达式的值，作为返回的对象的 value 属性值。</p></li><li><p>下一次调用 next 方法时，再继续往下执行，直到遇到下一个 yield 表达式。</p></li><li><p>如果没有再遇到新的 yield 表达式，就一直运行到函数结束，直到 return 语句为止，并将 return 语句后面的表达式的值，作为返回的对象的 value 属性值。</p></li><li><p>如果该函数没有 return 语句，则返回的对象的 value 属性值为 undefined。</p></li></ul><h2 id="yield-和-return"><a href="#yield-和-return" class="headerlink" title="yield 和 return"></a>yield 和 return</h2><ul><li>相同点：都能返回紧跟在语句后面的那个表达式的值</li><li>不同点：<ul><li>每次遇到 yield，函数暂停执行，下一次再从该位置继续向后执行，而 return 语句不具备位置记忆的功能</li><li>一个函数里面，只能执行一次（或者说一个） return 语句，但是可以执行多次（或者说多个） yield 表达式。</li><li>正常函数只能返回一个值，因为只能执行一次 return；Generator 函数可以返回一系列的值，因为可以有任意多个 yield。</li></ul></li></ul><blockquote><p>yield 表达式只能用在 Generator 函数里面，用在其他地方都会报错。</p></blockquote><h2 id="yield-表达式在另一个表达式里面"><a href="#yield-表达式在另一个表达式里面" class="headerlink" title="yield 表达式在另一个表达式里面"></a>yield 表达式在另一个表达式里面</h2><p>yield 表达式如果用在另一个表达式之中，必须放在圆括号里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hello'</span> + (<span class="keyword">yield</span> <span class="number">123</span>)); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h1 id="next-方法的参数"><a href="#next-方法的参数" class="headerlink" title="next 方法的参数"></a>next 方法的参数</h1><p>yield 表达式本身没有返回值，或者说总是返回 undefined。next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; <span class="literal">true</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> reset = <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">if</span> (reset) &#123;</span><br><span class="line">      i = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = f()</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next(<span class="literal">true</span>) <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure><p>这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过 next 方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p><blockquote><p>由于 next 方法的参数表示上一个 yield 表达式的返回值，所以在第一次使用 next 方法时，传递参数是无效的。V8 引擎直接忽略第一次使用 next 方法时的参数，只有从第二次使用 next 方法开始，参数才是有效的。从语义上讲，第一个 next 方法用来启动遍历器对象，所以不用带有参数。</p></blockquote><h1 id="throw"><a href="#throw" class="headerlink" title="throw()"></a>throw()</h1><p>Generator 函数返回的遍历器对象，都有一个 throw 方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g()</span><br><span class="line">i.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>)</span><br><span class="line">  i.throw(<span class="string">'b'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure><p>第一个错误被 Generator 函数体内的 catch 语句捕获。i 第二次抛出错误，由于 Generator 函数内部的 catch 语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了 Generator 函数体，被函数体外的 catch 语句捕获。</p><h2 id="错误捕获"><a href="#错误捕获" class="headerlink" title="错误捕获"></a>错误捕获</h2><ul><li>如果 Generator 函数内部没有部署 try…catch 代码块，那么 throw 方法抛出的错误，将被外部 try…catch 代码块捕获。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g()</span><br><span class="line">i.next()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>)</span><br><span class="line">  i.throw(<span class="string">'b'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 a</span></span><br></pre></td></tr></table></figure><ul><li>如果 Generator 函数内部和外部，都没有部署 try…catch 代码块，那么程序将报错，直接中断执行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.next()</span><br><span class="line">g.throw()</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// Uncaught undefined</span></span><br></pre></td></tr></table></figure><ul><li>throw 方法抛出的错误要被内部捕获，前提是必须至少执行过一次 next 方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.throw(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// Uncaught 1</span></span><br></pre></td></tr></table></figure><ul><li>throw 方法被捕获以后，会附带执行下一条 yield 表达式。也就是说，会附带执行一次 next 方法。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'a'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line">g.next() <span class="comment">// a</span></span><br><span class="line">g.throw() <span class="comment">// b</span></span><br><span class="line">g.next() <span class="comment">// c</span></span><br></pre></td></tr></table></figure><p>上面代码中，g.throw 方法被捕获以后，自动执行了一次 next 方法，所以会打印 b。另外，也可以看到，只要 Generator 函数内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误，不影响下一次遍历。</p><ul><li>Generator 函数体外抛出的错误，可以在函数体内捕获；反过来，Generator 函数体内抛出的错误，也可以被函数体外的 catch 捕获。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase()</span><br><span class="line">  <span class="keyword">yield</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo()</span><br><span class="line"></span><br><span class="line">it.next() <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，第二个 next 方法向函数体内传入一个参数 42，数值是没有 toUpperCase 方法的，所以会抛出一个 TypeError 错误，被函数体外的 catch 捕获。</p><ul><li>一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用 next 方法，将返回一个 value 属性等于 undefined、done 属性等于 true 的对象，即 JavaScript 引擎认为这个 Generator 已经运行结束了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'throwing an exception'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'generator broke!'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">generator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> v</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'starting generator'</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第一次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    v = generator.next()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第三次运行next方法'</span>, v)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'捕捉错误'</span>, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'caller done'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(g())</span><br><span class="line"><span class="comment">// starting generator</span></span><br><span class="line"><span class="comment">// 第一次运行next方法 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// throwing an exception</span></span><br><span class="line"><span class="comment">// 捕捉错误 &#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">// 第三次运行next方法 &#123; value: undefined, done: true &#125;</span></span><br><span class="line"><span class="comment">// caller done</span></span><br></pre></td></tr></table></figure><h1 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h1><p>Generator 函数返回的遍历器对象，还有一个 return 方法，可以返回给定的值，并且终结遍历 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen()</span><br><span class="line"></span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.return(<span class="string">'foo'</span>) <span class="comment">// &#123; value: "foo", done: true &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果 return 方法调用时，不提供参数，则返回值的 value 属性为 undefined。</p></blockquote><h2 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h2><p>如果 Generator 函数内部有 try…finally 代码块，那么 return 方法会<strong>推迟到 finally 代码块执行完再执行。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers()</span><br><span class="line">g.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">g.return(<span class="number">7</span>) <span class="comment">// &#123; value: 4, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 5, done: false &#125;</span></span><br><span class="line">g.next() <span class="comment">// &#123; value: 7, done: true &#125;</span></span><br></pre></td></tr></table></figure><h1 id="yield-表达式"><a href="#yield-表达式" class="headerlink" title="yield* 表达式"></a>yield* 表达式</h1><p>yield* 表达式，用来在一个 Generator 函数里面执行另一个 Generator 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">yield</span>* foo()</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'a'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'b'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">    <span class="keyword">yield</span> v</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'y'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> bar()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "x"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br><span class="line"><span class="comment">// "b"</span></span><br><span class="line"><span class="comment">// "y"</span></span><br></pre></td></tr></table></figure><p>从语法角度看，如果 yield 表达式后面跟的是一个遍历器对象，需要在 yield 表达式后面加上星号，表明它返回的是一个遍历器对象。这被称为 yield*表达式。</p><p>yield*后面的 Generator 函数（<strong>没有 return 语句时</strong>），等同于在 Generator 函数内部，部署一个 for…of 循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1</span><br><span class="line">  <span class="keyword">yield</span>* iter2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码说明，yield<em> 后面的 Generator 函数（没有 return 语句时），不过是 for…of 的一种简写形式，完全可以用后者替代前者。反之，在<strong>有 return 语句时</strong>，则需要用 `var value = yield</em> iterator` 的形式获取 return 语句的值。</p><h2 id="yield-数组"><a href="#yield-数组" class="headerlink" title="yield* 数组"></a>yield* 数组</h2><p>如果 yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen().next() <span class="comment">// &#123; value:"a", done:false &#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>实际上，任何数据结构只要有 Iterator 接口，就可以被 yield*遍历。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> read = (<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span></span><br><span class="line">  <span class="keyword">yield</span>* <span class="string">'hello'</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">read.next().value <span class="comment">// "hello"</span></span><br><span class="line">read.next().value <span class="comment">// "h"</span></span><br></pre></td></tr></table></figure><h2 id="展开嵌套数组"><a href="#展开嵌套数组" class="headerlink" title="展开嵌套数组"></a>展开嵌套数组</h2><p>demo 05-yield-xing.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> element = tree[i]</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], [[<span class="number">4</span>, <span class="number">5</span>], <span class="number">6</span>]]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([...iterTree(arr)]) <span class="comment">// [ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure><h1 id="作为对象属性的-generator-函数"><a href="#作为对象属性的-generator-函数" class="headerlink" title="作为对象属性的 generator 函数"></a>作为对象属性的 generator 函数</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="generator-函数的-this"><a href="#generator-函数的-this" class="headerlink" title="generator 函数的 this"></a>generator 函数的 this</h1><ul><li>Generator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也 <strong>继承了 Generator 函数的 prototype 对象上的方法</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">g.prototype.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hi!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g()</span><br><span class="line"></span><br><span class="line">obj <span class="keyword">instanceof</span> g <span class="comment">// true</span></span><br><span class="line">obj.hello() <span class="comment">// 'hi!'</span></span><br></pre></td></tr></table></figure><p>上面代码表明，Generator 函数 g 返回的遍历器 obj，是 g 的实例，而且继承了 g.prototype。</p><ul><li>但是，如果把 g 当作普通的构造函数，并不会生效，因为 <strong>g 返回的总是遍历器对象，而不是 this 对象</strong>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = g()</span><br><span class="line">obj.next()</span><br><span class="line">obj.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>Generator 函数也<strong>不能跟 new 命令一起用</strong>，会报错。</li></ul><h1 id="使用-generator-封装异步任务"><a href="#使用-generator-封装异步任务" class="headerlink" title="使用 generator 封装异步任务"></a>使用 generator 封装异步任务</h1><p>使用 generator 封装异步任务，由下面的例子可以看出，异步任务定义很简单，但是流程管理很复杂。</p><p>demo: 07-async.js，在 index.html 中引入，使用浏览器查看结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> <span class="keyword">let</span> url = <span class="string">'https://api.github.com/users/github'</span></span><br><span class="line"> <span class="keyword">let</span> result = <span class="keyword">yield</span> fetch(url)</span><br><span class="line"> <span class="built_in">console</span>.log(result.bio)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = gen()</span><br><span class="line"><span class="keyword">let</span> pro = it.next().value</span><br><span class="line"></span><br><span class="line">pro.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> res.json()</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line"> it.next(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/generator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰ES6 generator教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;demos 代码 github 地址：&lt;a href=&quot;https://github.com/huajianduzhuo/es6/tree/master/generator&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/huajianduzhuo/es6/tree/master/generator&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Generator&quot;&gt;&lt;a href=&quot;#Generator&quot; class=&quot;headerlink&quot; title=&quot;Generator&quot;&gt;&lt;/a&gt;Generator&lt;/h1&gt;&lt;p&gt;Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://mengyujing.com/categories/ES6/"/>
    
    
      <category term="generator" scheme="http://mengyujing.com/tags/generator/"/>
    
      <category term="yield" scheme="http://mengyujing.com/tags/yield/"/>
    
  </entry>
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="http://mengyujing.com/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mengyujing.com/C语言学习笔记/</id>
    <published>2018-04-22T08:28:02.000Z</published>
    <updated>2019-10-24T11:41:37.155Z</updated>
    
    <content type="html"><![CDATA[<p>慕课网课程地址：<a href="https://www.imooc.com/learn/249" target="_blank" rel="noopener">https://www.imooc.com/learn/249</a></p><a id="more"></a><h1 id="认识C程序"><a href="#认识C程序" class="headerlink" title="认识C程序"></a>认识C程序</h1><p>简单来说，一个C程序就是由若干<strong>头文件</strong>和<strong>函数</strong>组成。</p><p>一个简单的 Hello World C 程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上C程序代码中，<code>#include&lt;stdio.h&gt;</code> 为包含头文件，<code>int main(){}</code> 为主函数。</p><ul><li><p><code>#include&lt;stdio.h&gt;</code> 就是一条预处理命令，它的作用是通知C语言编译系统在对C程序进行正式编译之前需要做一些预处理工作</p></li><li><p>函数就是实现代码逻辑的一个小的单元</p><blockquote><p>在最新的C标准中，main 函数前的类型为 int 而不是 void</p></blockquote></li></ul><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>一个C程序<strong>有且只有一个主函数</strong>，即 <strong>main</strong> 函数。C程序就是执行主函数里的代码，也可以说主函数就是C语言中的<strong>唯一入口</strong>。</p><p>main 前面的 <strong>int</strong> 就是主<strong>函数的类型</strong>。</p><p>printf() 是格式输出函数，功能就是在屏幕上输出指定的信息。</p><p><strong>return 是函数的返回值</strong>，根据函数类型的不同，返回的值也是不同的。</p><p>\n 是转义字符。</p><h2 id="编写规范"><a href="#编写规范" class="headerlink" title="编写规范"></a>编写规范</h2><ul><li>一个说明或一个语句占一行，例如：包含头文件、一个可执行语句结束都需要换行</li><li>函数体内的语句要有明显缩进</li><li>括号要成对写</li><li>当一句可执行语句结束的时候末尾需要有分号</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>多行注释： /* 注释内容 */<br>单行注释： // 注释一行</p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>C语言中，数据类型可分为：<strong>基本数据类型、构造数据类型、指针类型、空类型</strong>四大类。</p><p><img src="http://ovqy85q1k.bkt.clouddn.com/datatype.jpg" alt="datatype"></p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>给变量或者函数起的名字就是标识符，标识符可以是<strong>字母（A~Z, a~z）、数字（0~9）、下划线_</strong>组成的字符串，并且<strong>第一个字符必须是字母或者下划线</strong>。</p><p>在使用标识符时还要注意以下几点：</p><ul><li>长度最好不要超过8位，因为在某些版本的C中规定标识符前8位有效，当两个标识符前8位相同时，则被认为是同一个标识符</li><li>标识符是严格<strong>区分大小写</strong>的</li><li>最好选择有意义的英文单词</li><li>标识符<strong>不能是C语言的关键字</strong></li></ul><h2 id="变量及赋值"><a href="#变量及赋值" class="headerlink" title="变量及赋值"></a>变量及赋值</h2><p>变量定义的一半形式：<strong>数据类型 变量名;</strong></p><p>多个类型相同的变量：<strong>数据类型 变量名, 变量名, 变量名…;</strong></p><p>变量的赋值：</p><ul><li>先声明再赋值</li><li>声明的同时赋值</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h2 id="基本数据类型-1"><a href="#基本数据类型-1" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">说明</th><th style="text-align:center">字节</th><th style="text-align:center">应用</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">char</td><td style="text-align:center">字符型</td><td style="text-align:center">1</td><td style="text-align:center">用于存储单个字符</td><td style="text-align:center">char sex = ‘m’;</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">整型</td><td style="text-align:center">2</td><td style="text-align:center">用于存储整数</td><td style="text-align:center">int height = 18;</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">单精度浮点型</td><td style="text-align:center">4</td><td style="text-align:center">用于存储小数</td><td style="text-align:center">float price = 11.1;</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">双精度浮点型</td><td style="text-align:center">8</td><td style="text-align:center">用于存储位数更多的小数</td><td style="text-align:center">double pi = 3.1415926;</td></tr></tbody></table><blockquote><p>C语言中不存在字符串变量，字符串只能存在于字符数组中。</p></blockquote><h2 id="格式化输出语句"><a href="#格式化输出语句" class="headerlink" title="格式化输出语句"></a>格式化输出语句</h2><p>格式化输出语句，也可以说是占位输出，是将各种类型的数据按照格式化后的类型及指定的位置从计算机上显示。</p><p>格式：<strong>printf(“输出格式符”, 输出项);</strong></p><p>常用格式化符：</p><table><thead><tr><th style="text-align:center">格式符</th><th style="text-align:center">说明 </th></tr></thead><tbody><tr><td style="text-align:center">%d</td><td style="text-align:center">带符号十进制整数</td></tr><tr><td style="text-align:center">%c</td><td style="text-align:center">单个字符</td></tr><tr><td style="text-align:center">%s</td><td style="text-align:center">字符串</td></tr><tr><td style="text-align:center">%f</td><td style="text-align:center">6位小数</td></tr></tbody></table><p>输出多个变量，变量之间用逗号隔开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">7.56</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">'c'</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"整数：%d，小数：%f，字符：%c"</span>, a, b, c);</span><br><span class="line"><span class="comment">// 整数：10，小数：7.560000，字符：c</span></span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>C语言中常量可以分为<strong>直接常量和符号常量</strong></p><p>直接常量也成为字面量，可以直接拿来使用，无需定义。</p><p>可以使用一个标识符来表示一个常量，称之为符号常量。符号常量在使用之前必须先定义，一般形式为：</p><p><strong>#define 标识符 常量值</strong></p><p>符号常量的标识符一般习惯使用大写字母，变量的标识符习惯使用小写字母，加以区分。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"圆周率：%f\n"</span>, PI);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><p>自动转换发生在不同数据类型运算时，在编译的时候自动完成。自动转换遵循的规则就好比小盒子可以放进大盒子里，下图表示自动转换规则：</p><p><img src="http://ovqy85q1k.bkt.clouddn.com/typetransform.jpg" alt="typetransform"></p><p>char类型数据转换为int类型数据遵循ASCII码中的对应值</p><blockquote><p>字节小的可以向字节大的自动转换，但字节大的不能向字节小的自动转换</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">int</span> n = c;        <span class="comment">//将c赋值给n</span></span><br><span class="line">    <span class="keyword">float</span> f = c;      <span class="comment">//将c赋值给f</span></span><br><span class="line">    <span class="keyword">double</span> d = c;     <span class="comment">//将c赋值给d</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,n); <span class="comment">// 97</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>,f); <span class="comment">// 97.000000</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,d); <span class="comment">// 97.000000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><p>强制类型转换是通过定义类型转换运算来实现的。一般形式为：</p><p><strong>(数据类型)(表达式)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a = <span class="number">6.777</span>;</span><br><span class="line"><span class="keyword">int</span> b = (<span class="keyword">int</span>)a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f\n"</span>, a); <span class="comment">// 6.777000</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>使用强制类型转换应注意以下问题：</p><ul><li>数据类型和表达式都必须加括号，如 (int)(x/2+y)</li><li><strong>转换后不会改变原数据的类型及变量值</strong>，只在本次运算中临时性转换</li><li>强制转换后的运算结果<strong>不遵循四舍五入原则</strong></li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">运算符号</th></tr></thead><tbody><tr><td style="text-align:center">加法</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">减法</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">乘法</td><td style="text-align:center">*</td></tr><tr><td style="text-align:center">除法</td><td style="text-align:center">/</td></tr><tr><td style="text-align:center">求余（模运算符）</td><td style="text-align:center">%</td></tr><tr><td style="text-align:center">自增</td><td style="text-align:center">++</td></tr><tr><td style="text-align:center">自减</td><td style="text-align:center">--</td></tr></tbody></table><ul><li><p><strong>除法</strong>运算中，如果相除的<strong>两个数都是整数</strong>的话，则<strong>结果也为整数</strong>，小数部分省略。两数中<strong>有一个为小数，结果则为小数</strong>。</p></li><li><p><strong>求余</strong>运算，<strong>只适合用两个整数</strong>进行求余运算。运算后的符号<strong>取决于被模数的符号</strong>，如 (-10)%3 = -1，而 10%(-3) = 1.</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>C语言中的赋值运算符分为<strong>简单赋值运算符和复合赋值运算符</strong>。</p><p>简单赋值运算符：”=”</p><p>复合赋值运算符就是在简单赋值符 “=” 之前加上其他运算符构成，例如：+=、-=、*=、/=、%=</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">></td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">>=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">==</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">!=</td><td style="text-align:center">不等于</td></tr></tbody></table><p>关系表达式的值是“真”和“假”，在C程序用<strong>整数 1 和 0 表示</strong>。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">意义</th></tr></thead><tbody><tr><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">逻辑与</td></tr><tr><td style="text-align:center">&#124;&#124;</td><td style="text-align:center">逻辑或</td></tr><tr><td style="text-align:center">!</td><td style="text-align:center">逻辑非</td></tr></tbody></table><h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><p>格式：</p><p><strong>表达式1 ? 表达式2 : 表达式3;</strong></p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p><img src="http://ovqy85q1k.bkt.clouddn.com/youxianji.jpg" alt="youxianji"></p><p>优先级别为 1 的最高，级别为 10 的最低。</p><h1 id="结构语句"><a href="#结构语句" class="headerlink" title="结构语句"></a>结构语句</h1><h2 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(表达式<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块1;</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(表达式m)</span><br><span class="line">&#123;</span><br><span class="line">  执行代码块m;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  执行代码块n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  执行代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块</span></span><br><span class="line">&#125; <span class="keyword">while</span>(表达式);</span><br></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; 表达式<span class="number">2</span>; 表达式<span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>for 循环中的 表达式1、2、3 均可以省略，但<strong>分号不能缺省</strong></li><li>表达式1和表达式3可以是多个表达式，以<strong>逗号分隔</strong></li><li>表达式2一般是关系表达式或逻辑表达式，但也可以是数值表达式或字符表达式，只要其<strong>值非零</strong>，就执行循环体</li><li>各<strong>表达式中的变量一定要在 for 循环之前定义（与其他语言不同）</strong></li></ul><h2 id="三种循环比较"><a href="#三种循环比较" class="headerlink" title="三种循环比较"></a>三种循环比较</h2><ul><li>在知道循环次数的情况下，更适合使用 for 循环</li><li>不知道循环次数的情况下，使用 while 或 do-while 循环</li></ul><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><p>break 语句可以中断循环</p><ul><li>在没有循环结构的情况下，break <strong>不能用在单独的 if-else 语句中</strong></li><li>在多层循环中，一个 break 语句<strong>只跳出当前循环</strong></li></ul><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><p>continue 语句结束本次循环开始执行下一次循环</p><h2 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">    执行代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">    执行代码块n</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    执行代码块n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>case 子句后如果没有 break，会一直往后执行一直到遇到 break，才跳出 switch 语句</li><li>switch 后面的表达式语句只能是<strong>整型或者字符类型</strong></li><li>在 case 后，允许有多个语句，可以不用 {} 括起来</li></ul><h2 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h2><p>使用格式：</p><p><strong>goto 语句标号;</strong></p><p>其中语句标号是一个标识符，该标识符一般用英文大写并遵守标识符命名规则，这个标识符加上一个“:”一起出现在函数内某处，执行 goto 语句后，程序将跳转到该标号处并执行其后的语句。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// LOOP就是一个有效的标识符</span></span><br><span class="line">  LOOP:<span class="keyword">if</span>(i&lt;=<span class="number">10</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">goto</span> LOOP; <span class="comment">// 跳转到LOOP所在位置继续执行</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sum=%d\n"</span>, sum);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>C语言提供了大量的库函数，比如stdio.h提供输出函数。</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><img src="http://ovqy85q1k.bkt.clouddn.com/defineFun.jpg" alt="defineFun"></p><ul><li>[] 包含的内容可以省略，数据类型省略，默认是 <strong>int</strong> 类型函数；</li><li>自定义函数尽量放在 main 函数之前，如果放在main函数后面，需要在main函数之前先声明，声明格式为：<strong>[数据类型说明] 函数名称 ([参数])</strong></li></ul><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>调用形式：</p><p><strong>函数名([参数]);</strong></p><h2 id="有参函数"><a href="#有参函数" class="headerlink" title="有参函数"></a>有参函数</h2><p>[数据类型说明] 函数名称(<strong>参数类型 参数名</strong>, …)<br>{<br>　　执行代码块;<br>　　return 表达式;<br>}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">learn</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"小明在慕课网上已经参与学习了%d门课程\n"</span>, n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><p>形参是定义函数和函数体时使用的参数，实参是在调用时传递给该函数的参数。</p><ul><li>形参只有在<strong>被调用时才分配内存单元</strong>，在调用结束时，即刻释放所分配的内存单元。因此，形参只有在函数内部有效。</li><li>实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，它们必须具有明确的值。</li><li>在参数传递时，实参和形参在<strong>数量上、类型上、顺序上应严格一致</strong>，否则会发生类型不匹配的错误。</li></ul><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p><strong>return 表达式</strong> 或者 <strong>return (表达式)</strong></p><blockquote><p>如果函数返回值的类型与函数定义中函数的类型不一致，则以函数返回类型为准，自动进行类型转换</p></blockquote><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>在<strong>函数内部、复合语句内部</strong>定义的变量</p><h2 id="变量存储类别"><a href="#变量存储类别" class="headerlink" title="变量存储类别"></a>变量存储类别</h2><p>C语言根据变量的生存周期来划分，可以分为<strong>静态存储方式</strong>和<strong>动态存储方式</strong>。</p><ul><li><p>静态存储方式：是指在程序运行期间分配固定的存储空间的方式。静态存储区中存放了<strong>在整个程序执行过程中都存在的变量，如全局变量</strong>。</p></li><li><p>动态存储方式：是指在程序运行期间根据需要进行动态的分配存储空间的方式。<strong>动态存储区中存放的变量是根据程序运行的需要而建立和释放的</strong>，通常包括：函数形参、自动变量、函数调用时的现场保护和返回地址等。</p></li></ul><p>C语言中存储类别又分为四类：<strong>自动（auto）、静态（static）、寄存器的（register）和外部的（extern）</strong>。</p><ul><li><p>用关键字 auto 定义的变量为自动变量，auto 可以省略，auto不写则隐含定义为“自动存储类别”，属于动态存储方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">int</span> b, c;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 static 修饰的为静态变量，如果定义在函数内部，称之为静态局部变量；如果定义在函数外部，称之为静态外部变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>静态局部变量属于静态存储类别，在静态存储区内分配存储单元，在<strong>整个程序运行期间都不释放</strong>；静态局部变量<strong>在编译时赋初值，即只赋初值一次</strong>；如果在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值0（对数值型变量）或空字符（对字符变量）。</p></blockquote><ul><li>为了提高效率，C语言允许将<strong>局部变量</strong>的值放在 CPU 中的寄存器中，这种变量叫“寄存器变量”，用关键字 register 作声明。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fn</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="keyword">int</span> i;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>只有<strong>局部自动变量和形参</strong>可以作为寄存器变量；一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量；<strong>局部静态变量不能定义为寄存器变量</strong>。</p></blockquote><ul><li>用 extern 声明的变量是外部变量，外部变量的意义是某函数可以调用在该函数之后定义的变量。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> x; <span class="comment">// 这里声明使用的是外部全局变量</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"extern x=%d\n"</span>, x);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li></ul><h2 id="内部函数与外部函数"><a href="#内部函数与外部函数" class="headerlink" title="内部函数与外部函数"></a>内部函数与外部函数</h2><p>在C语言中不能被其他源文件调用的函数称为内部函数，由 static 关键字来定义，又被称为静态函数。形式为：</p><p><strong>static [数据类型] 函数名()</strong></p><p>在C语言中能被其他源文件调用的函数称为外部函数，由 extern 关键字来定义。形式为：</p><p><strong>extern [数据类型] 函数名()</strong></p><p>在没有指定函数的作用范围时，<strong>默认为外部函数</strong>，因此 extern 可以省略。</p><blockquote><p>引入源文件<code>#include &quot;test.c&quot;</code></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;慕课网课程地址：&lt;a href=&quot;https://www.imooc.com/learn/249&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.imooc.com/learn/249&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="C语言" scheme="http://mengyujing.com/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="C语言" scheme="http://mengyujing.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>IOS下input的placeholder不垂直居中的问题</title>
    <link href="http://mengyujing.com/IOS%E4%B8%8Binput%E7%9A%84placeholder%E4%B8%8D%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://mengyujing.com/IOS下input的placeholder不垂直居中的问题/</id>
    <published>2018-03-05T14:34:05.000Z</published>
    <updated>2019-10-24T11:41:37.156Z</updated>
    
    <content type="html"><![CDATA[<p>为 <code>input</code> 设置 <code>lineHeight: 1;</code>, 可以使 input 输入框内用户输入的文本垂直居中，但是在 IOS 的 Safari 浏览器中查看， <code>placeholder</code> 提示文字垂直方向靠上，解决此问题，可以为该 input 设置 <code>lineHeight: normal;</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为 &lt;code&gt;input&lt;/code&gt; 设置 &lt;code&gt;lineHeight: 1;&lt;/code&gt;, 可以使 input 输入框内用户输入的文本垂直居中，但是在 IOS 的 Safari 浏览器中查看， &lt;code&gt;placeholder&lt;/code&gt; 提示文字垂直方向
      
    
    </summary>
    
      <category term="移动端" scheme="http://mengyujing.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="IOS" scheme="http://mengyujing.com/tags/IOS/"/>
    
      <category term="safari" scheme="http://mengyujing.com/tags/safari/"/>
    
      <category term="placeholder" scheme="http://mengyujing.com/tags/placeholder/"/>
    
  </entry>
  
  <entry>
    <title>vue项目使用WebViewJavascriptBridge</title>
    <link href="http://mengyujing.com/vue%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8WebViewJavascriptBridge/"/>
    <id>http://mengyujing.com/vue项目使用WebViewJavascriptBridge/</id>
    <published>2018-01-07T16:01:05.000Z</published>
    <updated>2019-10-24T11:41:37.168Z</updated>
    
    <content type="html"><![CDATA[<p>现在在做的项目是 hybrid 开发，H5 页面会嵌入到 IOS 客户端 app 中，于是就涉及到了 H5 与 IOS 交互的问题。在这里记录一下项目中用到的交互方式，重点介绍 <code>WebViewJavascriptBridge</code>。<br><a id="more"></a></p><h1 id="H5-调用-IOS，无返回"><a href="#H5-调用-IOS，无返回" class="headerlink" title="H5 调用 IOS，无返回"></a>H5 调用 IOS，无返回</h1><p>项目中最简单的一个交互需求，是在客户端打开 H5 页面后，页面上有一个后退按钮，可以退回到客户端页面。这个需求纯前端是无法做到的，前端必须调用 IOS 的退回方法。</p><p>H5 页面需要调用 IOS 端的方法，且不需要获取返回值时，可以很简单的使用 <code>schema</code> 的方式，而不需要通过第三方库来实现。具体方式是：</p><ul><li>前端与客户端约定好一个 schema 的名称，比如退回就叫做 goback</li><li>前端通过 <code>location.href=&quot;goback://&quot;</code> 或 <code>iframe.src=&quot;goback://&quot;</code> 的方式发起请求</li><li>IOS 端拦截 goback 这个 schema，执行后退逻辑</li><li>如果需要向客户端传递参数，直接在该 url 后面拼接参数即可，客户端可以进行解析</li></ul><h1 id="使用-WebViewJavascriptBridge"><a href="#使用-WebViewJavascriptBridge" class="headerlink" title="使用 WebViewJavascriptBridge"></a>使用 WebViewJavascriptBridge</h1><p>当 H5 页面与 IOS 端交互比较复杂时，比如页面需要获取 IOS 端传回的返回值，或者 IOS 端需要调用 js 方法。</p><p>可以通过第三方库来实现，我们项目用的是 <code>WebViewJavascriptBridge</code>。下面介绍我怎么在 vue 项目中使用 <code>WebViewJavascriptBridge</code></p><p><a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="noopener">WebViewJavascriptBridge GitHub 地址</a></p><ul><li>创建 src/config/bridge.js 文件，用于封装 WebViewJavascriptBridge </li><li><p>将以下代码拷贝到 bridge.js 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupWebViewJavascriptBridge</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WebViewJavascriptBridge) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="built_in">window</span>.WebViewJavascriptBridge)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.WVJBCallbacks) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.WVJBCallbacks.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.WVJBCallbacks = [callback]</span><br><span class="line">  <span class="keyword">let</span> WVJBIframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">  WVJBIframe.style.display = <span class="string">'none'</span></span><br><span class="line">  WVJBIframe.src = <span class="string">'https://__bridge_loaded__'</span></span><br><span class="line">  <span class="built_in">document</span>.documentElement.appendChild(WVJBIframe)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.documentElement.removeChild(WVJBIframe)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  callhandler (name, data, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.callHandler(name, data, callback)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  registerhandler (name, callback) &#123;</span><br><span class="line">    setupWebViewJavascriptBridge(<span class="function"><span class="keyword">function</span> (<span class="params">bridge</span>) </span>&#123;</span><br><span class="line">      bridge.registerHandler(name, <span class="function"><span class="keyword">function</span> (<span class="params">data, responseCallback</span>) </span>&#123;</span><br><span class="line">        callback(data, responseCallback)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 main.js 中引入该文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Bridge <span class="keyword">from</span> <span class="string">'./config/bridge.js'</span></span><br><span class="line">Vue.prototype.$bridge = Bridge</span><br></pre></td></tr></table></figure></li><li><p>在需要调用客户端方法的组件中（事先需要与客户端同事约定好方法名）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$bridge.callhandler(<span class="string">'ObjC Echo'</span>, params, (data) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 处理返回数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当客户端需要调用 js 函数时,事先注册约定好的函数即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$bridge.registerhandler(<span class="string">'JS Echo'</span>, (data, responseCallback) =&gt; &#123;</span><br><span class="line">  alert(<span class="string">'JS Echo called with:'</span>, data)</span><br><span class="line">  responseCallback(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在在做的项目是 hybrid 开发，H5 页面会嵌入到 IOS 客户端 app 中，于是就涉及到了 H5 与 IOS 交互的问题。在这里记录一下项目中用到的交互方式，重点介绍 &lt;code&gt;WebViewJavascriptBridge&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="移动端" scheme="http://mengyujing.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="http://mengyujing.com/tags/vue/"/>
    
      <category term="WebViewJavascriptBridge" scheme="http://mengyujing.com/tags/WebViewJavascriptBridge/"/>
    
  </entry>
  
  <entry>
    <title>事件委托touchmove事件获取target</title>
    <link href="http://mengyujing.com/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98touchmove%E4%BA%8B%E4%BB%B6%E8%8E%B7%E5%8F%96target/"/>
    <id>http://mengyujing.com/事件委托touchmove事件获取target/</id>
    <published>2017-12-24T05:59:56.000Z</published>
    <updated>2019-10-24T11:41:37.168Z</updated>
    
    <content type="html"><![CDATA[<p>　　今天做项目时发现，移动端 touchmove 事件获取到的 target 元素，总是 touchstart 事件时的 target，而不能跟随手指的移动动态得到当前 target。</p><a id="more"></a><p>　　最近项目需要做一个通讯录页面，并且要仿照 iPhone 原生的通讯录，其中有一个功能，即滑动右侧的英文字母列表，通讯录列表要相应滑动到对应的位置。如下图所示：</p><style>#imgWrapper {  width: 200px;  overflow: hidden;  margin: 0 auto;}</style><div id="imgWrapper"><br>  <img src="http://ovqy85q1k.bkt.clouddn.com/mobile.gif" alt="mobile"><br></div><p>右侧字母列表的代码如下（vue 实现）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"letter-list"</span> @<span class="attr">touchmove.prevent</span>=<span class="string">"scrollToLetter()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"(letter, index) in letters"</span> <span class="attr">:id</span>=<span class="string">"letter"</span> <span class="attr">:key</span>=<span class="string">"index"</span>&gt;</span></span><br><span class="line">    &#123;&#123; letter &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>　　如代码所示，我想要使用事件委托，为 ul 绑定 touchmove 事件，通过 <code>e.changedTouches[0].target.id</code> ，可以获取当前触摸到的字符，并将联系人列表移动到相应字符的位置。</p><p>　　然而，当我这样写完，测试时发现效果不对，联系人列表只能滑动到 touchstart 时对应的字符位置，通过 log 打印发现，<code>e.changedTouches[0].target</code> 获取到的永远是 touchstart 时的 target，所有这种方式获取 target 是错误的。</p><p>　　通过上网查阅资料，最终通过以下方式获取到了正确的 target：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> touch = event.changedTouches[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">const</span> letterE = <span class="built_in">document</span>.elementFromPoint(touch.clientX, touch.clientY)</span><br><span class="line"><span class="built_in">console</span>.log(letterE);</span><br><span class="line"><span class="keyword">if</span> (!letterE) <span class="keyword">return</span></span><br><span class="line"><span class="keyword">const</span> letter = letterE.id</span><br></pre></td></tr></table></figure><p><code>document.elementFromPoint</code> 方法的浏览器兼容性如下：</p><ul><li><strong>desktop</strong></li></ul><table><thead><tr><th>Feature</th><th>Chrome</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari (WebKit)</th></tr></thead><tbody><tr><td>Basic support</td><td>53.0</td><td>?</td><td>?</td><td></td><td>?</td></tr></tbody></table><ul><li><strong>mobile</strong></li></ul><table><thead><tr><th>Feature</th><th>Android</th><th>Android Webview</th><th>Firefox Mobile (Gecko)</th><th>Firefox OS</th><th>IE Mobile</th><th>Opera Mobile</th><th>Safari Mobile</th><th>Chrome for Android</th></tr></thead><tbody><tr><td>Basic support</td><td>未实现</td><td>53.0</td><td>?</td><td>?</td><td>?</td><td></td><td>?</td><td>53.0</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　今天做项目时发现，移动端 touchmove 事件获取到的 target 元素，总是 touchstart 事件时的 target，而不能跟随手指的移动动态得到当前 target。&lt;/p&gt;
    
    </summary>
    
      <category term="移动端" scheme="http://mengyujing.com/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
    
      <category term="touchmove" scheme="http://mengyujing.com/tags/touchmove/"/>
    
      <category term="target" scheme="http://mengyujing.com/tags/target/"/>
    
  </entry>
  
  <entry>
    <title>Symbol数据类型</title>
    <link href="http://mengyujing.com/Symbol%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://mengyujing.com/Symbol数据类型/</id>
    <published>2017-12-10T10:32:09.000Z</published>
    <updated>2019-10-24T11:41:37.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Symbol-概述"><a href="#Symbol-概述" class="headerlink" title="Symbol 概述"></a>Symbol 概述</h1><p><code>Symbol</code> 是ES6引入的一种新的原始数据类型，表示独一无二的值。<br><a id="more"></a><br>Symbol 值通过 Symbol 函数生成。Symbol 函数前不能使用 <code>new</code> 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// symbol</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="built_in">Symbol</span>() <span class="comment">// TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure><p>Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'haha'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// Symbol(haha)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(&#123;<span class="attr">name</span>: <span class="string">'weizhuang'</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// Symbol([object Object])</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，Symbol 函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的 Symbol 函数的返回值是不相等的。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a === d); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> e = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">let</span> f = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="built_in">console</span>.log(e === f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="Symbol-与其他数据类型"><a href="#Symbol-与其他数据类型" class="headerlink" title="Symbol 与其他数据类型"></a>Symbol 与其他数据类型</h2><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'zhuang'</span>)</span><br><span class="line">a + <span class="string">'lian'</span>  <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line">a + <span class="number">10</span>      <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line">a + <span class="literal">true</span>    <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><p>Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(a)); <span class="comment">// Symbol(zhuang)</span></span><br><span class="line"><span class="built_in">console</span>.log(a.toString()); <span class="comment">// Symbol(zhuang)</span></span><br></pre></td></tr></table></figure><p>Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Boolean</span>(a));  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(a));  <span class="comment">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure><h1 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h1><p>Symbol 值可以作为对象的属性名。由于每一个 Symbol 值都是不相等的，这样就可以保证不会出现同名的属性名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [a]: <span class="string">'weizhuang'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj[a]); <span class="comment">// weizhuang</span></span><br></pre></td></tr></table></figure><blockquote><p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p></blockquote><h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 <code>Object.getOwnPropertySymbols</code> 方法，可以获取指定对象的所有 Symbol 属性名。</p><p><code>Object.getOwnPropertySymbols</code> 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>)</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [a]: <span class="string">'weizhuang'</span>,</span><br><span class="line">  b: <span class="string">'honglian'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">': '</span> + obj[key]); <span class="comment">// b: honglian</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">// ["b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)); <span class="comment">// ["b"]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// &#123;"b":"honglian"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)); <span class="comment">// [Symbol(a)]</span></span><br></pre></td></tr></table></figure><p>另一个新的 API，<code>Reflect.ownKeys</code> 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.ownKeys(obj)); <span class="comment">// ["b", Symbol(a)]</span></span><br></pre></td></tr></table></figure><h1 id="Symbol-for-、Symbol-keyFor"><a href="#Symbol-for-、Symbol-keyFor" class="headerlink" title="Symbol.for()、Symbol.keyFor()"></a>Symbol.for()、Symbol.keyFor()</h1><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code> 方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p><p>Symbol.for() 与 Symbol() 这两种写法，都会生成新的 Symbol。它们的区别是，<strong>前者会被登记在全局环境中供搜索，后者不会</strong>。Symbol.for() 不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的 key 是否已经存在，如果不存在才会新建一个值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s3 === s4); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>(<span class="string">'fei'</span>)</span><br><span class="line"><span class="keyword">let</span> s6 = <span class="built_in">Symbol</span>.for(<span class="string">'fei'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s5 === s6); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>Symbol.keyFor</code> 方法返回一个<strong>已登记</strong>的 Symbol 类型值的key。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'zhuang'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// zhuang</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">'lian'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s3)); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><blockquote><p>上面代码中，变量 s3 属于未登记的 Symbol 值，所以返回 undefined。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Symbol-概述&quot;&gt;&lt;a href=&quot;#Symbol-概述&quot; class=&quot;headerlink&quot; title=&quot;Symbol 概述&quot;&gt;&lt;/a&gt;Symbol 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Symbol&lt;/code&gt; 是ES6引入的一种新的原始数据类型，表示独一无二的值。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://mengyujing.com/categories/ES6/"/>
    
    
      <category term="Symbol" scheme="http://mengyujing.com/tags/Symbol/"/>
    
  </entry>
  
  <entry>
    <title>ES6函数参数解构赋值</title>
    <link href="http://mengyujing.com/ES6%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    <id>http://mengyujing.com/ES6函数参数解构赋值/</id>
    <published>2017-11-26T14:02:18.000Z</published>
    <updated>2019-10-24T11:41:37.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数参数解构赋值"><a href="#函数参数解构赋值" class="headerlink" title="函数参数解构赋值"></a>函数参数解构赋值</h2><p>函数的参数可以使用解构赋值。<br><a id="more"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">5</span>&#125;); <span class="comment">// [3, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move2</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">move2([<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// &#123;x: 4, y: 5&#125;;</span></span><br></pre></td></tr></table></figure><p>但是，以上写法，当函数调用没有传递参数时，就会报错：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move(); <span class="comment">// ​​Cannot destructure property `x` of 'undefined' or 'null'.​</span></span><br><span class="line">move2(); <span class="comment">// ​​Cannot read property 'Symbol(Symbol.iterator)' of undefined​​</span></span><br></pre></td></tr></table></figure><p>所以，当参数使用解构赋值时，需要为参数设置一个默认值。上面的函数改写为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x, y&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">5</span>&#125;); <span class="comment">// [3, 5]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move2</span>(<span class="params">[x, y] = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line">move2([<span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// &#123;x: 4, y: 5&#125;</span></span><br><span class="line">move2([<span class="number">4</span>]); <span class="comment">// &#123;x: 4, y: undefined&#125;</span></span><br><span class="line">move2(); <span class="comment">// &#123;x: undefined, y: undefined&#125;</span></span><br></pre></td></tr></table></figure><h2 id="函数参数解构赋值默认值"><a href="#函数参数解构赋值默认值" class="headerlink" title="函数参数解构赋值默认值"></a>函数参数解构赋值默认值</h2><p>如下函数 move，接受一个对象为参数，并被解构为变量 x 和 y。变量 x 和 y 使用默认值，可以写成如下形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用该函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">1</span>, <span class="attr">y</span>:<span class="number">2</span>&#125;); <span class="comment">// [1, 2]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>:<span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，ES6 内部使用严格相等运算符（===），判断一个位置是否有值，只有一个解构的成员严格等于 undefined，才会触发默认值。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">move(&#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(&#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;); <span class="comment">// [null, 0]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数参数解构赋值&quot;&gt;&lt;a href=&quot;#函数参数解构赋值&quot; class=&quot;headerlink&quot; title=&quot;函数参数解构赋值&quot;&gt;&lt;/a&gt;函数参数解构赋值&lt;/h2&gt;&lt;p&gt;函数的参数可以使用解构赋值。&lt;br&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://mengyujing.com/categories/ES6/"/>
    
    
      <category term="ES6" scheme="http://mengyujing.com/tags/ES6/"/>
    
      <category term="解构赋值" scheme="http://mengyujing.com/tags/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/"/>
    
  </entry>
  
  <entry>
    <title>Vue实现思路简单分析</title>
    <link href="http://mengyujing.com/Vue%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>http://mengyujing.com/Vue源码实现思路简单分析/</id>
    <published>2017-09-12T08:05:21.000Z</published>
    <updated>2019-10-24T11:41:37.162Z</updated>
    
    <content type="html"><![CDATA[<p><div class="vuedata"><br>  <img src="/uploads/Vue/data.png" alt="image"><br></div></p><style>@media screen and (min-width: 768px) {  .posts-expand .post-body .vuedata {    position: relative;    margin: 0 auto;    line-height: 1.2;    width: 300px;    height: 250px;  }  .posts-expand .post-body .vuedata img {    position: absolute;    top: 50%;    left: 50%;    transform: translate(-50%, -50%);    border: 0;    margin: 0 auto;    padding: 0;    width: 450px;    max-width: 450px;  }}</style><a id="more"></a><p>主要分析 Vue 数据代理、模板解析、数据绑定等方面，配合一些代码，简单实现 Vue 基本功能。</p><blockquote><p>注意：本文并没有直接参考 Vue 源码，参考源码为：<a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a></p></blockquote><h1 id="数据代理"><a href="#数据代理" class="headerlink" title="数据代理"></a>数据代理</h1><p>Vue 中，配置对象中的 data 对象中的数据，保存在 vm 对象的 <code>$data</code> 属性中，由 vm 对象进行代理。</p><p>创建如下 vm 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg: <span class="string">'cencen'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>通过 vm 代理读取 <code>$data</code> 中的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(vm.msg); <span class="comment">// cencen</span></span><br></pre></td></tr></table></figure></p><p>通过 vm 代理更改 <code>$data</code> 中的数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.msg = <span class="string">'岑大王'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(vm.$data.msg); <span class="comment">// 岑大王</span></span><br></pre></td></tr></table></figure></p><p><strong>模拟实现原理</strong></p><ul><li><p>将传入的选项对象中的 data 属性值，保存在 vm 实例的 <code>$data</code> 属性中</p></li><li><p>遍历 data 对象的所有属性，添加到 vm 实例上。</p></li><li><p>在 vm 上定义新的属性时，使用访问描述符</p><ul><li>属性的 get 方法返回 vm 实例上的 <code>$data</code> 属性对象上对应的属性值</li><li>set 方法将新的属性值设置到 <code>$data</code> 对象上对应的属性。</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span>(<span class="params">option</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$option = option;</span><br><span class="line">  <span class="comment">// 将 option 选项对象的 data 属性，保存到变量 data和 vm 的 $data 属性</span></span><br><span class="line">  <span class="keyword">let</span> data = <span class="keyword">this</span>.$data = <span class="keyword">this</span>.$option.data;</span><br><span class="line">  <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 遍历 data 对象的所有属性，添加 vm 代理</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    vm._proxy(key);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.prototype = &#123;</span><br><span class="line">  <span class="comment">// 代理方法</span></span><br><span class="line">  _proxy (key)&#123;</span><br><span class="line">    <span class="keyword">let</span> vm = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 在 vm 实例上添加对应的属性，实现对 $data 对象上的属性的代理</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(vm, key, &#123;</span><br><span class="line">      configurable: <span class="literal">false</span>, <span class="comment">// 不可重新定义</span></span><br><span class="line">      enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举</span></span><br><span class="line">      <span class="comment">// 代理读</span></span><br><span class="line">      <span class="keyword">get</span>: function proxyGetter()&#123;</span><br><span class="line">        <span class="keyword">return</span> vm.$data[key];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 代理写</span></span><br><span class="line">      <span class="keyword">set</span>: function proxySetter(newVal)&#123;</span><br><span class="line">        vm.$data[key] = newVal;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h1><p>Vue 使用模板，实现在页面上使用 model 中的数据。</p><p>模板解析，就是操作页面上的节点，按照相应的规则解析所使用的模板语法，并显示出理想的页面。</p><h2 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h2><p>解析模板时，为了防止多次操作页面上的节点，造成过多的重绘重排，可以采用<strong>批量更新</strong>的方法：</p><ul><li>将挂载元素下的所有子节点，移出到代码片段（fragment）中</li><li>在 fragment 中进行模板解析，编译所有子节点</li><li>解析完成后，再将 fragment 插入到挂载元素进行显示</li></ul><p>这样对于页面来说，只进行了移出所有子元素和插入编译好的代码片段两次重排操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compile</span>(<span class="params">el, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.$vm = vm;</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="keyword">this</span>.isElementNode(el) ? el : <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$fragment = <span class="keyword">this</span>.node2Fragment(<span class="keyword">this</span>.$el); <span class="comment">// 移出</span></span><br><span class="line">        <span class="keyword">this</span>.init(); <span class="comment">// 解析 fragment</span></span><br><span class="line">        <span class="keyword">this</span>.$el.appendChild(<span class="keyword">this</span>.$fragment); <span class="comment">// 插入</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Compile.prototype = &#123;</span><br><span class="line">  node2Fragment: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将 el 所有子节点取出，放入暂存元素</span></span><br><span class="line">    <span class="keyword">let</span> childStr = el.innerHTML;</span><br><span class="line">    el.innerHTML = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">let</span> tempEl = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    tempEl.innerHTML = childStr;</span><br><span class="line">    <span class="comment">// 创建fragment</span></span><br><span class="line">    <span class="keyword">let</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">let</span> child;</span><br><span class="line">    <span class="comment">// 遍历暂存元素，将所有子节点放入fragment</span></span><br><span class="line">    <span class="keyword">while</span>(child = tempEl.firstChild)&#123;</span><br><span class="line">      fragment.appendChild(child);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  isElementNode: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.nodeType == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h2><p>在 fragment 中解析模板时，需要遍历 fragment 的所有子节点，根据节点类型，具有不同的解析方式。</p><ul><li>遍历子节点 <code>fragment.chileNodes</code></li><li>判断节点类型 <code>node.nodeType</code></li><li>若为元素节点：对指令属性进行解析<ul><li>事件指令解析</li><li>一般指令解析</li></ul></li><li>若为文本节点：解析表达式<ul><li>通过正则匹配表达式字符串：<code>/\{\{(.*)\}\}/</code></li><li><code>exp = RegExp.$1</code> 获取表达式名</li><li>得到表达式的值<code>vm[exp]</code>后，设置到该文本节点的 textContent</li></ul></li><li>若子节点还包含子节点 <code>if(node.childNodes &amp;&amp; node.childNodes.length)</code>，递归解析该子节点的所有子节点</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.compileElement(<span class="keyword">this</span>.$fragment);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  compileElement: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> childNodes = el.childNodes, <span class="comment">// 获取所有子节点</span></span><br><span class="line">          me = <span class="keyword">this</span>;</span><br><span class="line">      <span class="comment">// 遍历子节点</span></span><br><span class="line">      [].slice.call(childNodes).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = node.textContent;</span><br><span class="line">          <span class="keyword">var</span> reg = <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (me.isElementNode(node)) &#123; </span><br><span class="line">              <span class="comment">// 元素节点，解析指令</span></span><br><span class="line">              me.compile(node);</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (me.isTextNode(node) &amp;&amp; reg.test(text)) &#123; </span><br><span class="line">              <span class="comment">// 包含表达式的文本节点，解析表达式</span></span><br><span class="line">              me.compileText(node, <span class="built_in">RegExp</span>.$<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 元素节点包含子节点，递归解析</span></span><br><span class="line">          <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length) &#123;</span><br><span class="line">              me.compileElement(node);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元素节点指令属性解析"><a href="#元素节点指令属性解析" class="headerlink" title="元素节点指令属性解析"></a>元素节点指令属性解析</h2><ul><li>获取元素所有属性：<code>attrs = node.attributes</code></li><li>遍历属性：<code>[].slice.call(attrs).forEach(function(attr){})</code></li><li>得到属性名：<code>attrName = attr.name</code></li><li>得到属性值（表达式名）：<code>exp = attr.value</code></li><li>判断是否是 Vue 指令：<code>attrName.indexOf(&#39;v-&#39;) == 0</code></li><li>获取指令名（不包含 v-）：<code>direcName = attrName.substring(2)</code></li><li>判断是否为事件指令：<code>direcName.indexOf(&#39;on&#39;) === 0</code><ul><li>事件名：<code>eventType = direcName.split(&#39;:&#39;)[1]</code></li><li>得到回调函数：<code>callback = vm.$options.methods[exp]</code></li><li>给元素绑定事件（事件函数绑定 this 为 vm）：<code>node.addEventListener(eventType, callback.bind(vm), false)</code></li></ul></li><li>不是事件指令，则为一般指令<ul><li><code>v-text</code>：操作节点 textContent</li><li><code>v-model</code>：操作节点 value</li><li><code>v-html</code>：操作节点 innerHTML</li><li><code>v-class</code>：操作节点 className</li></ul></li><li>移除指令属性：<code>node.removeAttribute(attrName)</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Compile.prototype = &#123;</span><br><span class="line">    compile: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nodeAttrs = node.attributes,</span><br><span class="line">            me = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        [].slice.call(nodeAttrs).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> attrName = attr.name; <span class="comment">// 属性名</span></span><br><span class="line">            <span class="comment">// Vue 属性</span></span><br><span class="line">            <span class="keyword">if</span> (me.isDirective(attrName)) &#123;</span><br><span class="line">                <span class="keyword">var</span> exp = attr.value; <span class="comment">// 表达式</span></span><br><span class="line">                <span class="keyword">var</span> dir = attrName.substring(<span class="number">2</span>); <span class="comment">// 指令名</span></span><br><span class="line">                <span class="keyword">if</span> (me.isEventDirective(dir)) &#123;</span><br><span class="line">                    <span class="comment">// 事件指令</span></span><br><span class="line">                    compileUtil.eventHandler(node, me.$vm, exp, dir);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 普通指令</span></span><br><span class="line">                    compileUtil[dir] &amp;&amp; compileUtil[dir](node, me.$vm, exp);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                node.removeAttribute(attrName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isDirective: <span class="function"><span class="keyword">function</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> attr.indexOf(<span class="string">'v-'</span>) == <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    isEventDirective: <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dir.indexOf(<span class="string">'on'</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compileUtil = &#123;</span><br><span class="line">    <span class="comment">// 事件处理</span></span><br><span class="line">    eventHandler: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp, dir</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> eventType = dir.split(<span class="string">':'</span>)[<span class="number">1</span>],</span><br><span class="line">            fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventType &amp;&amp; fn) &#123;</span><br><span class="line">            node.addEventListener(eventType, fn.bind(vm), <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h1><p>数据绑定（model =&gt; view），一旦更新了 data 中的数据，页面中直接或间接使用了该属性的节点都会更新。</p><h2 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h2><p>vue.js 采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><h2 id="实现数据绑定的思想"><a href="#实现数据绑定的思想" class="headerlink" title="实现数据绑定的思想"></a>实现数据绑定的思想</h2><p>Vue 通过数据劫持实现数据绑定，最核心的方法就是<code>Object.defineProperty()</code>，在属性的 getter 方法中，将数据与页面中使用了该数据的节点进行绑定，在 setter 方法中，监视数据变化，当数据发生了变化，通知绑定了该数据的页面节点进行更新。</p><p>实现过程中，比较重要的几点：</p><ul><li>实现一个数据监听器 <strong>Observer</strong>，能够对数据对象 data 的所有属性进行监听，如有变动可拿到最新值并通知订阅者</li><li>实现一个解析器 <strong>Compile</strong>，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 </li><li>实现一个 <strong>Watcher</strong>，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图</li><li>mvvm入口函数，整合以上三者</li></ul><p><img src="/uploads/Vue/2.png" alt="image"></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li><p>定义 <code>observe</code> 方法，传入一个参数，判断参数如果是对象，则调用 Observer 构造函数，监视该对象所有属性。这里传入 data，监视 data 中所有属性。</p></li><li><p><code>Observer</code> 构造函数中，遍历 data 所有属性，进行如下操作：</p><ul><li>重新调用 <code>observe</code> 方法，传入当前属性，若该属性值是对象，则可以实现监视 data 任意层次数据</li><li>为每一个属性创建一个 dep （dependency）对象，该对象包含一个 id 属性（作为该 dep 的唯一标识），和一个 subs 属性（初始为空数组，用于存储订阅了该属性数据变化的 watcher）。</li><li>使用<code>defineProperty()</code>为 data 重新定义所有属性，定义 getter/setter 方法，实现数据劫持。</li><li><code>getter</code> 方法，用于获取值。当一个 watcher 获取值时，getter 方法会判断当前 dep 和 watcher 是否建立了数据订阅关系，如果没有，则在当前属性的 dep 对象的 subs 属性中，存储该 watcher，并在 watcher 对象的 depIds 属性中存储当前 dep。</li><li><code>setter</code> 方法，用于监视当前属性数据变化，当数据发生改变，则通知该属性的 dep，dep 通知 subs 属性中所有 watcher，watcher 则触发绑定的回调函数，更新视图。</li></ul></li></ul><blockquote><p>data 对象中每个层次的属性，都对应一个 dep 对象。</p></blockquote><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><p>Compile 解析模板的过程，在第二章已经分析过，这里需要分析一下 Compile 解析模板过程中，是如何实现订阅数据变化的。</p><p>模板解析过程中，当解析表达式（{ {…} }）和元素节点的非事件指令（v-model、v-text、v-html、v-class等）时，将该模板替换成数据显示到页面后，会调用 Wacther 构造函数，为该节点创建一个 watcher 对象，并为该 watcher 对象绑定一个更新该节点视图的回调函数。</p><h3 id="Wacther"><a href="#Wacther" class="headerlink" title="Wacther"></a>Wacther</h3><p>watcher 对象在编译模板的过程中被创建，作为 data 中的数据和视图页面的桥梁。</p><blockquote><p>页面中每一个表达式、元素非事件指令，都对应一个 watcher 对象。</p></blockquote><p>watcher 对象中包含如下属性：</p><ul><li>vm  ： vm对象</li><li>exp ： 对应指令的表达式</li><li>cb  ： 当表达式所对应的数据发生改变时，用于更新页面的回调函数</li><li>value ： 表达式当前的值</li><li>depIds ： 存储表达式中各级属性所对应的 dep 对象的集合对象。属性名为 dep 的 id, 属性值为 dep</li></ul><p>由于 watcher 对象中存储了模板对应表达式的值，所以创建 watcher 对象时，会调用该表达式的各级属性的 getter 方法来获取当前值。在 Observer 中，已经介绍过，getter 方法会判断当前 watcher 对象的 depIds 属性中，是否包含该数据的 dep 对象，若没有，则会分别在 dep 对象的 subs 属性存储当前 watcher 对象，在 watcher 对象的 depIds 属性中，存储该数据的 dep 对象。</p><h3 id="model-到-view-绑定"><a href="#model-到-view-绑定" class="headerlink" title="model 到 view 绑定"></a>model 到 view 绑定</h3><p>watcher 对象中，存储了更新该对象对应的页面节点的回调函数，并且在相应表达式的各级属性中订阅了数据变化的通知。</p><p>当数据发生变化时，由于数据劫持，在 setter 方法中，会通过该数据对应的 dep 对象，通知所有订阅了该数据变化的 watcher，watcher 对象则调用存储的回调函数，更新视图。</p><h2 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h2><p>前面介绍了 model =&gt; view 的数据绑定，Vue 通过 <code>v-model</code> 指令实现了 view =&gt; model 的数据绑定。</p><p>当解析 <code>v-model</code> 指令时，会给当前元素添加 <code>input</code> 监听事件，当元素的值发生改变时，会将最新的值赋给当前表达式对应的 data 属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">model: <span class="function"><span class="keyword">function</span>(<span class="params">node, vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.bind(node, vm, exp, <span class="string">'model'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> me = <span class="keyword">this</span>,</span><br><span class="line">        val = <span class="keyword">this</span>._getVMVal(vm, exp);</span><br><span class="line">    node.addEventListener(<span class="string">'input'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> newValue = e.target.value;</span><br><span class="line">        <span class="keyword">if</span> (val === newValue) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        me._setVMVal(vm, exp, newValue);</span><br><span class="line">        val = newValue;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_getVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = vm._data;</span><br><span class="line">    exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line">    exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k</span>) </span>&#123;</span><br><span class="line">        val = val[k];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">_setVMVal: <span class="function"><span class="keyword">function</span>(<span class="params">vm, exp, value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> val = vm._data;</span><br><span class="line">    exp = exp.split(<span class="string">'.'</span>);</span><br><span class="line">    exp.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">k, i</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 非最后一个key，更新val的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; exp.length - <span class="number">1</span>) &#123;</span><br><span class="line">            val = val[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            val[k] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;vuedata&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/uploads/Vue/data.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/p&gt;
&lt;style&gt;
@media screen and (min-width: 768px) {
  .posts-expand .post-body .vuedata {
    position: relative;
    margin: 0 auto;
    line-height: 1.2;
    width: 300px;
    height: 250px;
  }
  .posts-expand .post-body .vuedata img {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    border: 0;
    margin: 0 auto;
    padding: 0;
    width: 450px;
    max-width: 450px;
  }
}
&lt;/style&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mengyujing.com/categories/Vue/"/>
    
    
      <category term="数据代理" scheme="http://mengyujing.com/tags/%E6%95%B0%E6%8D%AE%E4%BB%A3%E7%90%86/"/>
    
      <category term="数据绑定" scheme="http://mengyujing.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    
      <category term="模板解析" scheme="http://mengyujing.com/tags/%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket和Socket.io介绍以及聊天室功能实现</title>
    <link href="http://mengyujing.com/socket-io%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E8%81%8A%E5%A4%A9%E5%AE%A4%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0/"/>
    <id>http://mengyujing.com/socket-io介绍以及聊天室功能实现/</id>
    <published>2017-09-04T12:53:44.000Z</published>
    <updated>2019-10-24T11:41:37.167Z</updated>
    
    <content type="html"><![CDATA[<p>我在做“你画我猜”小游戏时，为了实现画面实时传递，以及猜题时的聊天室功能，使用了 Socket.io，本文主要介绍 Socket.io 是什么，以及如何使用。<br><a id="more"></a></p><h1 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h1><p>在介绍 Socket.io 之前，首先需要说一说什么是 WebSocket。</p><p><strong>详细了解参考：</strong></p><ul><li>MDN上的介绍：<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API</a></li><li>知乎上的介绍：<a href="https://www.zhihu.com/question/20215561" target="_blank" rel="noopener">https://www.zhihu.com/question/20215561</a> </li><li>WebSocket 与 Socket.io 介绍：<a href="http://www.cnblogs.com/mazg/p/5467960.html" target="_blank" rel="noopener">http://www.cnblogs.com/mazg/p/5467960.html</a></li></ul><h2 id="为什么需要WebSocket"><a href="#为什么需要WebSocket" class="headerlink" title="为什么需要WebSocket"></a>为什么需要WebSocket</h2><p>我们知道，在 HTML5 之前，客户端和服务器通过 HTTP 协议交换数据，但是，HTTP 协议具有两个特点：</p><ul><li><p><strong>HTTP 协议是一种单向的网络协议</strong>。在建立连接后，它只允许客户端 Browser/UA (User Agent) 向服务器 WebServer 发送请求后，WebServer 才能返回相应的数据。而 WebServer 不能主动推送数据给 Browser/UA。</p></li><li><p><strong>HTTP 协议是无状态的</strong>。客户端向服务器发送连接请求中会包含 identity info（鉴别信息），每次当一个连接结束时，服务器就会将这些鉴别信息丢掉，客户端再次发送 HTTP 请求时，就需要重新发送这些信息。</p></li></ul><p>现在，假设我们需要开发一个基于 Web 的应用程序，需要获取服务器的实时数据，比如股票的实时行情、聊天室的聊天内容等，这就需要客户端和服务器之间反复进行 HTTP 通信，客户端不断发送请求，去获取当前的实时数据。下面介绍两种常见的方式：</p><ul><li><p><strong>ajax 轮询</strong><br>  ajax 轮询的原理非常简单，就是让浏览器定时（隔几秒）向服务器发送一次请求，询问是否有新的数据，如果有就返回最新数据，浏览器接收到后将最新数据显示出来，然后重复这一过程。</p></li><li><p><strong>Long Polling</strong><br>  Long Polling 的原理与 ajax 轮询的原理差不多，都是采用轮询的方式，它是 Polling 的一种改进。客户端发送请求到服务器后，服务器并不立即响应客户端，而是保持住这次连接，当有新的数据时，才返回给客户端，客户端接收到数据，进行展示，再立即发送一个新的请求给服务器，并重复这个过程。如果服务器的数据长期没有更新，一段时间后，这个请求就会超时，客户端收到超时消息后，再立即发送一个新的请求给服务器。</p></li></ul><p>从上面可以看出，这两种方式都需要不断的建立 HTTP 连接，然后等待服务器处理。</p><p>ajax 轮询假如某段时间内服务器没有更新的数据，但是客户端仍然需要定时发送请求，服务器再把以前的老数据返回过来，客户端拿到老数据，再把没有变化的数据再显示出来，即这段时间内，客户端和服务器会定时交换不变的数据信息，这样既浪费了带宽，又浪费了 CPU 的利用率。</p><p>Long Polling 虽然解决了带宽和 CPU 利用率的问题，但是如果服务器的数据更新的过快，服务器在返回给客户端一次数据包之后，只能等待客户端再次发送一次请求来之后，才能发送下一个数据包给客户端。在服务器两次返回数据之间，需要等待客户端接收到数据之后处理数据的时间，以及客户端再次发送连接请求后，服务器验证客户端的鉴别信息，并成功建立连接的时间，在网络拥塞的情况下，这个应该是用户不能接受的。</p><p>另外，由于 HTTP 协议是无状态的，每次建立连接都需要重新传输 identity info（鉴别信息），这些信息不仅浪费处理时间，而且在网络传输中会耗费大量的流量，往往比实际需要传输的数据量还要大。这样的数据包在网络上周期性的传输，对网络带宽也是一直浪费。</p><p>在这样的情况下，假如客户端能有一种新的网络协议，可以支持客户端和服务器的双向通信的就好了。于是，WebSocket 应运而生。</p><h2 id="WebSocket-协议"><a href="#WebSocket-协议" class="headerlink" title="WebSocket 协议"></a>WebSocket 协议</h2><p>WebSocket 是 HTML5 新增的一种通信协议。WebSocket 协议是一种持久化的双向通信协议，它建立在TCP之上，同 HTTP 一样通过 TCP 来传输数据，但是它和 HTTP 最大的不同有两点：</p><ul><li><p>WebSocket 是一种双向通信协议，在建立连接后，WebSocket 服务器和 Browser/UA 都能主动的向对方发送或接收数据，就像 Socket 一样，不同的是 WebSocket 是一种建立在 Web 基础上的一种简单模拟 Socket 的协议。</p></li><li><p>WebSocket 需要通过握手连接，类似于 TCP 它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。</p></li></ul><h2 id="WebSocket-工作流程"><a href="#WebSocket-工作流程" class="headerlink" title="WebSocket 工作流程"></a>WebSocket 工作流程</h2><p>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。因为 WebSocket 连接本质上就是一个 TCP 连接，所以在数据传输的稳定性和数据传输量的大小方面，和传统轮询以技术比较，具有很大的性能优势。</p><p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 “Upgrade: WebSocket” 表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p><h2 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h2><p>下面是一个典型的 WebSocket 发送请求和响应请求的例子：</p><p><strong>浏览器向服务器发起 WebSocket 请求：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Host:127.0.0.1:8088</span><br><span class="line">Origin:null</span><br><span class="line">Sec-WebSocket-Extensions:x-webkit-deflate-frame</span><br><span class="line">Sec-WebSocket-Key:puVOuWb7rel6z2AVZBKnfw==</span><br><span class="line">Sec-WebSocket-Version:13</span><br><span class="line">Upgrade:websocket</span><br></pre></td></tr></table></figure></p><p>这个请求与普通的 HTTP 请求有一些区别</p><blockquote><p>Upgrade: websocket<br>Connection: Upgrade</p></blockquote><p>表示请求的目的就是要将客户端和服务器端的通讯协议从 HTTP 协议升级到 WebSocket 协议</p><blockquote><p>Sec-WebSocket-Key:<br>Sec-WebSocket-Extensions:<br>Sec-WebSocket-Version: </p></blockquote><p>客户端浏览器需要向服务器端提供的握手信息，服务器端解析这些头信息。Sec-WebSocket-Key 是一个 Base64 encode的值，这个是浏览器随机生成的，Sec-WebSocket-Version 是告诉服务器所使用的 Websocket Draft（协议版本）。</p><p><strong>服务器返回：</strong><br>服务器端返回以下信息，以表明服务器端获取了客户端的请求，同意创建 WebSocket 连接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection:Upgrade</span><br><span class="line">Server:beetle websocket server</span><br><span class="line">Upgrade:WebSocket</span><br><span class="line">Date:Mon, 26 Nov 2013 23:42:44 GMT</span><br><span class="line">Access-Control-Allow-Credentials:true</span><br><span class="line">Access-Control-Allow-Headers:content-type</span><br><span class="line">Sec-WebSocket-Accept:FCKgUr8c7OsDsLFeJTWrJw6WO8Q=</span><br></pre></td></tr></table></figure></p><blockquote><p>Upgrade: websocket<br>Connection: Upgrade</p></blockquote><p>告诉客户端即将升级的是Websocket协议</p><blockquote><p>Sec-WebSocket-Accept </p></blockquote><p>这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。</p><h2 id="WebSocket-服务器"><a href="#WebSocket-服务器" class="headerlink" title="WebSocket 服务器"></a>WebSocket 服务器</h2><p>从握手的协议可以看出，如果我们要使用 WebSocket，我们需要一个实现 WebSocket 协议规范的服务器，这不在我们讨论的范围。</p><p>值得一提的是：WebSocket 是可以和 HTTP 共用监听端口的，也就是它可以公用端口完成 socket 任务。</p><h2 id="WebSocket-与-HTTP、TCP-的关系"><a href="#WebSocket-与-HTTP、TCP-的关系" class="headerlink" title="WebSocket 与 HTTP、TCP 的关系"></a>WebSocket 与 HTTP、TCP 的关系</h2><p>WebSocket 与 HTTP 协议一样都是基于 TCP 的，所以他们都是可靠的协议，Web 开发者调用的 WebSocket 的 send 函数在 browser 的实现中最终都是通过 TCP 的系统接口进行传输的。</p><p>WebSocket 和 Http 协议一样都属于应用层的协议，那么他们之间有没有什么关系呢？答案是肯定的，WebSocket 在建立握手连接时，数据是通过 HTTP 协议传输的，正如我们上面所看到的 “GET/chat HTTP/1.1”，这里面用到的只是 HTTP 协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要 HTTP 协议参与的。</p><p><img src="/uploads/websocket/websocket.png" alt="image"></p><h2 id="WebSocket-API"><a href="#WebSocket-API" class="headerlink" title="WebSocket API"></a>WebSocket API</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var ws = new WebSocket(“ws://echo.websocket.org”);</span><br><span class="line">ws.onopen = function()&#123;ws.send(“Test!”); &#125;;</span><br><span class="line">ws.onmessage = function(evt)&#123;console.log(evt.data);ws.close();&#125;;</span><br><span class="line">ws.onclose = function(evt)&#123;console.log(“WebSocketClosed!”);&#125;;</span><br><span class="line">ws.onerror = function(evt)&#123;console.log(“WebSocketError!”);&#125;;</span><br></pre></td></tr></table></figure><p>上面的 JavaScript 代码中，调用了 WebSocket 的 API。</p><p>创建一个 WebSocket 对象，需要调用 WebSocket 的构造函数，并传入需要连接的服务器地址。WebSocket 的 URL 以 ws:// 开头。</p><p>WebSocket 对象具有4个事件：</p><ul><li>onopen：WebSocket 连接成功后触发</li><li>onmessage：浏览器接收到 WebSocket 服务器发送过来的数据时触发</li><li>onclose：浏览器接收到 WebSocket 服务器传来的关闭连接请求时触发</li><li>onerror：连接失败，发送、接收数据失败或者处理数据出现错误时触发</li></ul><h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><style>    table {        font-size: 12px;        line-height: 1.2;    }    th:first-child, td:first-child:not(.gutter) {        width: 30%;    }    .post-body a img{        width: 350px;        height: 300px;    }</style><p><strong>Desktop</strong></p><table><thead><tr><th>Feature</th><th>Chrome</th><th>Edge</th><th>Firefox (Gecko)</th><th>Internet Explorer</th><th>Opera</th><th>Safari</th></tr></thead><tbody><tr><td>Version -76 support</td><td>6</td><td>No support</td><td>4.0 (2.0)</td><td>No support</td><td>11.00 (disabled)</td><td>5.0.1</td></tr><tr><td>Protocol version 7 support</td><td>No support</td><td>No support</td><td>6.0 (6.0)<code>Moz</code></td><td>No support</td><td>No support</td><td>No support</td></tr><tr><td>Protocol version 10 support</td><td>14</td><td>No support</td><td>7.0 (7.0)<code>Moz</code></td><td>HTML5 Labs</td><td>?</td><td>?</td></tr><tr><td>Standard - RFC 6455 Support</td><td>16</td><td>(Yes)</td><td>11.0 (11.0)</td><td>10</td><td>12.10</td><td>6.0</td></tr><tr><td>Usable in Workers</td><td>(Yes)</td><td>(Yes)</td><td>37.0 (37.0)</td><td>?</td><td>?</td><td>?</td></tr></tbody></table><p><strong>Mobile</strong></p><table><thead><tr><th>Feature</th><th>Android</th><th>Edge</th><th>Firefox Mobile (Gecko)</th><th>IE Mobile</th><th>Opera Mobile</th><th>Safari Mobile</th></tr></thead><tbody><tr><td>Version -76 support</td><td>?</td><td>No support</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Protocol version 7 support</td><td>?</td><td>No support</td><td>?</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Protocol version 8 support (IETF draft 10)</td><td>?</td><td>No support</td><td>7.0 (7.0)</td><td>?</td><td>?</td><td>?</td></tr><tr><td>Standard - RFC 6455 Support</td><td>4.4</td><td>(Yes)</td><td>11.0 (11.0)</td><td>?</td><td>12.10</td><td>6.0</td></tr><tr><td>Usable in Workers</td><td>(Yes)</td><td>(Yes)</td><td>37.0 (37.0)</td><td>?</td><td>?</td><td>?</td></tr></tbody></table><h1 id="Socket-io"><a href="#Socket-io" class="headerlink" title="Socket.io"></a>Socket.io</h1><p>Socket.io 用于浏览器与 Node.js 之间实现实时通信。</p><ul><li>官网：<a href="https://socket.io/" target="_blank" rel="noopener">https://socket.io/</a></li><li>官网聊天室案例：<a href="https://socket.io/get-started/chat/" target="_blank" rel="noopener">https://socket.io/get-started/chat/</a></li><li>Socket.io 中文介绍：<a href="http://www.cnblogs.com/xiezhengcai/p/3956401.html" target="_blank" rel="noopener">http://www.cnblogs.com/xiezhengcai/p/3956401.html</a></li><li>Socket.io 简述：<a href="http://blog.csdn.net/yczz/article/details/51743815" target="_blank" rel="noopener">http://blog.csdn.net/yczz/article/details/51743815</a></li></ul><p>在写这篇文章之前，我只是使用了 Socket.io，但对于它却并不是很了解，之前我一直认为 Socket.io 就是对 WebSocket 协议的实现。事实上，这种看法并不完全正确。</p><h2 id="Socket-io-介绍"><a href="#Socket-io-介绍" class="headerlink" title="Socket.io 介绍"></a>Socket.io 介绍</h2><p>Socket.io 是一个完全由 JavaScript 实现、基于 Node.js、支持 WebSocket 协议的用于实时通信、跨平台的开源框架，它包括了客户端的 JavaScript 和服务器端的 Node.js。</p><p>Socket.io 设计的目标是支持任何的浏览器，任何 Mobile 设备。支持主流的 PC 浏览器 (IE,Safari,Chrome,Firefox,Opera等)，Mobile 浏览器(iphone Safari/ipad Safari/Android WebKit/WebOS WebKit等)。</p><p>但是，WebSocket 协议是 HTML5 新推出的协议，浏览器对它的支持并不完善，由此可以看出，Socket.io 不可能仅仅是对 WebSocket 的实现，它还支持其他的通信方式，如上面介绍过的 ajax 轮询和 Long Polling。根据浏览器的支持程度，自主选择使用哪种方式进行通讯。</p><p><strong>Socket.io 支持的通信方式：</strong></p><ul><li>WebSocket</li><li>Adobe Flash Socket</li><li>AJAX long-polling</li><li>AJAX multipart streaming</li><li>Forever IFrame</li><li>JSONP polling</li></ul><h2 id="Socket-io-的使用"><a href="#Socket-io-的使用" class="headerlink" title="Socket.io 的使用"></a>Socket.io 的使用</h2><p>node 端使用 express 框架</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>服务器端：<br><code>npm install --save socket.io</code></p><p>浏览器端（引入本地文件）：<br><code>&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;</code></p><p>浏览器端（CDN 加速）：<br><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js&quot;&gt; &lt;/script&gt;</code></p><h3 id="创建-io-服务器"><a href="#创建-io-服务器" class="headerlink" title="创建 io 服务器"></a>创建 io 服务器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var app = require(&apos;express&apos;)();</span><br><span class="line">var server = require(&apos;http&apos;).Server(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;)(server);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, function(req, res)&#123;</span><br><span class="line">    res.sendFile(__dirname + &apos;/index.html&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log(&apos;App listening on port 3000!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>Socket.IO 提供了默认事件（如：connect, message, disconnect）。另外，Socket.IO允许发送并接收自定义事件。</p><p><strong>监听客户端连接，回调函数会传递本次连接的socket</strong></p><blockquote><p>io.on(‘connection’,function(socket){  });</p></blockquote><p><strong>给所有客户端广播消息</strong></p><blockquote><p>io.sockets.emit(‘String’,data);</p></blockquote><p><strong>给指定的客户端发送自定义事件</strong></p><blockquote><p>socket.emit(‘String’, data);<br>io.sockets.socket(socketid).emit(‘String’, data);</p></blockquote><p><strong>接收客户端发送的自定义事件</strong></p><blockquote><p>socket.on(‘String’,function(data));</p></blockquote><p><strong>给除了自己以外的客户端广播消息</strong></p><blockquote><p>socket.broadcast.emit(“msg”, data); </p></blockquote><h3 id="房间"><a href="#房间" class="headerlink" title="房间"></a>房间</h3><p>房间是 Socket.IO 提供的一个非常好用的功能。房间相当于为指定的一些客户端提供了一个命名空间，所有在房间里的广播和通信都不会影响到房间以外的客户端。</p><p><strong>使用 join() 方法将 socket 加入房间：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">io.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class="line">    socket.on(&apos;group1&apos;, function (data) &#123;</span><br><span class="line">        socket.join(&apos;group1&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(&apos;group2&apos;,function(data)&#123;</span><br><span class="line">        socket.join(&apos;group2&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p><strong>使用 leave() 方法离开房间：</strong></p><blockquote><p>socket.leave(‘some room’);</p></blockquote><p><strong>向房间中除了当前 socket 的其他 socket 发送消息</strong></p><blockquote><p>socket.broadcast.to(‘group1’).emit(‘event_name’, data);<br>broadcast方法允许当前socket client不在该分组内</p></blockquote><p><strong>向房间中所有的 socket 发送消息</strong></p><blockquote><p>io.sockets.in(‘group1’).emit(‘event_name’, data);</p></blockquote><p><strong>获取连接的客户端 socket</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.sockets.clients().forEach(function (socket) &#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><strong>获取所有房间（分组）信息</strong></p><blockquote><p>io.sockets.manager.rooms</p></blockquote><p><strong>来获取此socketid进入的房间信息</strong></p><blockquote><p>io.sockets.manager.roomClients[socket.id]</p></blockquote><p><strong>获取particular room中的客户端，返回所有在此房间的socket实例</strong></p><blockquote><p>io.sockets.clients(‘particular room’)</p></blockquote><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>通过命名空间可以为 Socket.IO 设置子程序。默认命名空间为 “/”，Socket.IO 默认连接该路径。</p><p>使用 of() 函数可以自定义命名空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var chat = io.of(&apos;/chat&apos;);</span><br><span class="line">chat.on(&apos;connection&apos;, function(socket)&#123;</span><br><span class="line">  console.log(&apos;someone connected&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong>建立一个 socket 连接</strong></p><blockquote><p>var socket = io.connect( window.location.protocol + ‘//‘ + window.location.host);</p></blockquote><p>或</p><blockquote><p>var socket = io( window.location.protocol + ‘//‘ + window.location.host);</p></blockquote><p><strong>建立有命名空间的 socket 连接</strong></p><blockquote><p>var chat = io.connect( window.location.protocol + ‘//‘ + window.location.host + ‘/chat’);</p></blockquote><p><strong>监听服务器消息</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&apos;msg&apos;,function(data)&#123;</span><br><span class="line">    console.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><blockquote><p>socket.on(“String”,function(data){}) 监听服务端发送的消息, String 参数与服务器端 socket.emit(‘String’, data) 第一个参数 String 相同。</p></blockquote><p><strong>向服务器发送消息</strong></p><blockquote><p>socket.emit(‘msg’, data);</p></blockquote><p><strong>监听 socket 断开与重连</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">socket.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">    console.log(&quot;与服务器断开&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.on(&apos;reconnect&apos;, function() &#123;</span><br><span class="line">    console.log(&quot;重新连接到服务器&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>客户端 socket.on() 监听的事件</strong></p><ul><li>connect：连接成功</li><li>connecting：正在连接</li><li>disconnect：断开连接</li><li>connect_failed：连接失败</li><li>error：错误发生，并且无法被其他事件类型所处理</li><li>message：同服务器端message事件</li><li>anything：同服务器端anything事件</li><li>reconnect_failed：重连失败</li><li>reconnect：成功重连</li><li>reconnecting：正在重连</li></ul><h1 id="聊天室"><a href="#聊天室" class="headerlink" title="聊天室"></a>聊天室</h1><p>流程：</p><ul><li>创建 socket 服务器</li><li>浏览器建立 socket 连接</li><li>页面输入聊天内容，点击 “发送” 按钮，向自定义 socket 事件 “chat” 发送聊天信息</li><li>服务器监听浏览器 “chat” 事件，当接收到浏览器发来的聊天信息时，将信息发送给所有连接了 socket 的浏览器</li><li>浏览器监听服务器发来的 “chat” 事件，接收到聊天信息时，在页面上显示</li></ul><p><img src="/uploads/gif/chat.gif" alt="image"></p><p>node 端代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var app = express();</span><br><span class="line">var server = require(&apos;http&apos;).Server(app);</span><br><span class="line">var io = require(&apos;socket.io&apos;)(server);</span><br><span class="line"></span><br><span class="line">io.sockets.on(&apos;connection&apos;, function(socket) &#123;</span><br><span class="line">    // 监听客户端发送的 chat 事件</span><br><span class="line">    socket.on(&apos;chat&apos;, function (chatinfo) &#123;</span><br><span class="line">        // 向当前 socket 发送聊天信息</span><br><span class="line">        socket.emit(&apos;chat&apos;, chatinfo);</span><br><span class="line">        // 向除了当前 socket 外的所有 socket 发送聊天信息</span><br><span class="line">        socket.broadcast.emit(&apos;chat&apos;, chatinfo);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(3000, function() &#123;</span><br><span class="line">    console.log(&apos;App listening on port 3000!&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>HTML 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;chat&quot;&gt;</span><br><span class="line">    &lt;ul id=&quot;chatList&quot;&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;form&gt;</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;chatContent&quot; id=&quot;chatContent&quot; /&gt;</span><br><span class="line">        &lt;input type=&quot;button&quot; id=&quot;sendChatContent&quot; value=&quot;发送&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>浏览器 socket 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 建立 socket 连接</span><br><span class="line">var url = window.location.protocol+&apos;//&apos;+window.location.host;</span><br><span class="line">socket = io.connect(url);</span><br><span class="line"></span><br><span class="line">// 点击“发送”，向服务器发送聊天信息</span><br><span class="line">$(&apos;#sendChatContent&apos;).click(function (ev) &#123;</span><br><span class="line">    var username = $(&apos;#username&apos;).text();</span><br><span class="line">    var chatContent = $(&apos;#chatContent&apos;).val().trim();</span><br><span class="line">    if(!chatContent)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(socket)&#123;</span><br><span class="line">        // 向服务器 chat 事件，发送信息</span><br><span class="line">        socket.emit(&apos;chat&apos;, &#123;username: username, chatContent: chatContent&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    $(&apos;#chatContent&apos;).val(&apos;&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 监听服务器发送来的 chat 事件</span><br><span class="line">socket.on(&apos;chat&apos;, function (chatinfo) &#123;</span><br><span class="line">    $(&apos;#chatList&apos;).append(&apos;&lt;li&gt;&lt;span class=&quot;chatusername&quot;&gt;&apos; + chatinfo.username + &apos;&lt;/span&gt;：&lt;span class=&quot;chatcontent&quot;&gt;&apos; + chatinfo.chatContent + &apos;&lt;/span&gt;&lt;/li&gt;&apos;);</span><br><span class="line">    $(&apos;#chatList&apos;).scrollTop(10000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在做“你画我猜”小游戏时，为了实现画面实时传递，以及猜题时的聊天室功能，使用了 Socket.io，本文主要介绍 Socket.io 是什么，以及如何使用。&lt;br&gt;
    
    </summary>
    
      <category term="WebSocket" scheme="http://mengyujing.com/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://mengyujing.com/tags/WebSocket/"/>
    
      <category term="Socket.io" scheme="http://mengyujing.com/tags/Socket-io/"/>
    
  </entry>
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="http://mengyujing.com/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://mengyujing.com/Vue学习笔记/</id>
    <published>2017-09-03T11:51:45.000Z</published>
    <updated>2019-10-24T11:41:37.160Z</updated>
    
    <content type="html"><![CDATA[<p><div class="vuel"><br>  <img src="/uploads/Vue/logo.png" alt="image"><br></div></p><style>  .posts-expand .post-body .vuel {    margin: 0 auto;    line-height: 1.2;  }  .posts-expand .post-body .vuel img {    border: 0;    margin: 0 auto;    padding: 0;    width: 150px;  }</style><a id="more"></a><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li><p><strong>beforeCreate</strong></p><p>数据代理<br>数据绑定</p></li><li><p><strong>created</strong>  =&gt;  异步任务（定时器、ajax、事件监听）</p><p>编译模板</p></li><li><p><strong>beforeMount</strong></p><p>批量更新到挂载元素</p></li><li><p><strong>mounted</strong>  =&gt;  异步任务（定时器、ajax、事件监听）</p><p>更新数据</p></li><li><p><strong>beforeUpdate</strong></p><p>重新渲染虚拟 DOM</p></li><li><p><strong>updated</strong></p><p>vm.$destroy()</p></li><li><p><strong>beforeDestroy</strong>   =&gt;  清除定时器</p></li><li><p><strong>destroyed</strong></p></li></ul><p><div class="lifecycle"><br>  <img src="/uploads/Vue/lifecycle.png" alt="image"><br></div></p><style>.posts-expand .post-body .lifecycle img {  margin: 0 auto;  padding: 0;  width: 380px;}</style><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>指令：自定义元素属性</p><p>Vue 预定义了一些指令，也可以自定义</p><h3 id="全局指令"><a href="#全局指令" class="headerlink" title="全局指令"></a>全局指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">  el.innerHTML = binding.value.toUpperCase()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="局部指令"><a href="#局部指令" class="headerlink" title="局部指令"></a>局部指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  <span class="string">'my-directive'</span>: <span class="function"><span class="keyword">function</span>(<span class="params">el, binding</span>)</span>&#123;</span><br><span class="line">    el.innerHTML = binding.value.toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用指令"><a href="#使用指令" class="headerlink" title="使用指令"></a>使用指令</h3><p>注册指令时，指令名不用写 <code>v-</code>，但是使用指令时，必须添加上。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-my-directive</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;div class=&quot;vuel&quot;&gt;&lt;br&gt;  &lt;img src=&quot;/uploads/Vue/logo.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;/p&gt;
&lt;style&gt;
  .posts-expand .post-body .vuel {
    margin: 0 auto;
    line-height: 1.2;
  }
  .posts-expand .post-body .vuel img {
    border: 0;
    margin: 0 auto;
    padding: 0;
    width: 150px;
  }
&lt;/style&gt;
    
    </summary>
    
      <category term="Vue" scheme="http://mengyujing.com/categories/Vue/"/>
    
    
      <category term="Vue" scheme="http://mengyujing.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览器线程机制与事件机制</title>
    <link href="http://mengyujing.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://mengyujing.com/浏览器线程机制与事件机制/</id>
    <published>2017-08-28T11:25:01.000Z</published>
    <updated>2019-10-24T11:41:37.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p><strong>进程</strong></p><ul><li>程序的一次执行, 它占有一片独有的内存空间</li><li>可以通过 windows 任务管理器查看进程<a id="more"></a></li></ul><p><strong>线程</strong></p><ul><li>是进程内的一个独立执行单元</li><li>是程序执行的一个完整流程</li><li>是CPU的最小的调度单元</li></ul><p><strong>关系</strong></p><ul><li>程序是在某个进程中的某个线程执行的</li><li>一个进程中至少有一个运行的线程：主线程, 进程启动后自动创建</li><li>一个进程中也可以同时运行多个线程, 我们会说程序是多线程运行的</li><li>一个进程内的数据可以供其中的多个线程直接共享</li><li>多个进程之间的数据是不能直接共享的</li><li>线程池( thread pool )：保存多个线程对象的容器, 实现线程对象的反复利用</li></ul><h2 id="多进程与多线程"><a href="#多进程与多线程" class="headerlink" title="多进程与多线程"></a>多进程与多线程</h2><p>多进程：一应用程序可以同时启动多个实例运行。<br>多线程：在一个进程内, 同时有多个线程运行。</p><h2 id="比较单线程与多线程"><a href="#比较单线程与多线程" class="headerlink" title="比较单线程与多线程"></a>比较单线程与多线程</h2><table><thead><tr><th style="text-align:center">比较</th><th style="text-align:center">单线程</th><th style="text-align:center">多线程 </th></tr></thead><tbody><tr><td style="text-align:center">   优点</td><td style="text-align:center">顺序编程简单易懂</td><td style="text-align:center">能有效提升CPU的利用率</td></tr><tr><td style="text-align:center">   缺点</td><td style="text-align:center">效率低</td><td style="text-align:center">创建多线程开销<br>线程间切换开销<br>死锁与状态同步问题</td></tr></tbody></table><h2 id="浏览器运行是单进程还是多进程"><a href="#浏览器运行是单进程还是多进程" class="headerlink" title="浏览器运行是单进程还是多进程?"></a>浏览器运行是单进程还是多进程?</h2><ul><li>有的是单进程<ul><li>firefox</li><li>老版IE</li></ul></li><li>有的是多进程<ul><li>chrome</li><li>新版IE</li></ul></li></ul><blockquote><p>如何查看浏览器是否是多进程运行的呢? == 任务管理器==&gt;进程</p></blockquote><h2 id="浏览器运行是单线程还是多线程"><a href="#浏览器运行是单线程还是多线程" class="headerlink" title="浏览器运行是单线程还是多线程?"></a>浏览器运行是单线程还是多线程?</h2><p>浏览器都是多线程运行的</p><h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核（browser core）是支持浏览器运行的最核心的程序。</p><h2 id="各个浏览器的内核"><a href="#各个浏览器的内核" class="headerlink" title="各个浏览器的内核"></a>各个浏览器的内核</h2><table><thead><tr><th style="text-align:center">浏览器</th><th style="text-align:center">内核</th></tr></thead><tbody><tr><td style="text-align:center">Chrome、Safari</td><td style="text-align:center">webkit</td></tr><tr><td style="text-align:center">firefox</td><td style="text-align:center">Gecko</td></tr><tr><td style="text-align:center">IE</td><td style="text-align:center">Trident</td></tr><tr><td style="text-align:center">360、搜狗等国内浏览器</td><td style="text-align:center">Trident + webkit （双内核）</td></tr></tbody></table><h2 id="浏览器内核模块组成"><a href="#浏览器内核模块组成" class="headerlink" title="浏览器内核模块组成"></a>浏览器内核模块组成</h2><ul><li>主线程<ul><li>js 引擎模块 ：负责 js 程序的编译与运行</li><li>html，css 文档解析模块 ：负责页面文本的解析</li><li>DOM/CSS 模块 ：负责 dom/css 在内存中的相关处理 </li><li>布局和渲染模块 ：负责页面的布局和效果的绘制(内存中的对象)</li></ul></li><li>分线程<ul><li>定时器模块 ：负责定时器的管理</li><li>事件响应模块 ：负责事件的管理</li><li>网络请求模块 ：负责 Ajax 请求</li></ul></li></ul><h1 id="js线程"><a href="#js线程" class="headerlink" title="js线程"></a>js线程</h1><p>JavaScript 的执行是单线程的。所有的 JavaScript 代码，包括回调代码，最终都会在执行栈（execution stack）中执行。</p><p>JavaScript 的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript 的主要用途是与用户互动，以及操作 DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><h1 id="浏览器的事件循环模型"><a href="#浏览器的事件循环模型" class="headerlink" title="浏览器的事件循环模型"></a>浏览器的事件循环模型</h1><p><strong>浏览器将代码分为两类：</strong></p><ul><li>初始化执行代码：普通代码，包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码</li><li>回调执行代码：处理回调逻辑（回调函数）</li></ul><p><strong>模型的2个重要组成部分</strong></p><ul><li>事件管理模块（下图的 Web APIs部分）</li><li>回调队列（callback queue）</li></ul><style>    img {        transform: scale(0.8);    }</style><p><img src="/uploads/thread/事件循环模型.png" alt="image"></p><p><strong>事件循环模型的运转流程</strong></p><ul><li>执行执行栈中的初始化代码，将事件回调函数交给对应模块管理。</li><li>当事件发生时, 管理模块会将回调函数及其数据添加到回调列队（callback queue）中。</li><li>只有当执行栈中的初始化代码执行完后（可能要一定时间）, 才会遍历读取回调队列中的回调函数并执行。</li></ul><h1 id="定时器问题"><a href="#定时器问题" class="headerlink" title="定时器问题"></a>定时器问题</h1><p>通过上面介绍过的事件循环运转流程，可以得知，定时器（setTimeout）回调函数只有在执行栈中的初始化代码全部执行完后才执行。因此，定时器并不能保证真正定时执行，如果在主线程在启动定时器之后执行了一个长时间的操作（时间超过定时器设置的时间），就会导致定时器回调函数延时处理。</p><h1 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h1><p>传统 JavaScript 是单线程运行的，HTML5 新推出了一个 Web Worker 接口，可以实现在分线程中执行一个单独的 js 文件。</p><p>Web Workers是一种机制，通过它可以使一个脚本操作在与Web应用程序的主执行线程分离的后台线程中运行。这样做的优点是可以在单独的线程中执行繁琐的处理，让主（通常是UI）线程运行而不被阻塞/减慢。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API" target="_blank" rel="noopener">Web Workers API</a></p><p>一个 worker 是使用构造函数创建的一个对象（例如,Worker()）, 运行一个命名的 JavaScript文件 — 这个文件包含了将在 worker 线程中运行的代码，并且 worker 在与当前 window 不同的另一个全局上下文中运行。这个上下文由专用worker的情况下的一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/DedicatedWorkerGlobalScope" target="_blank" rel="noopener">DedicatedWorkerGlobalScope</a> 对象表示（标准 workers 由单个脚本使用; 共享 workers 使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/SharedWorkerGlobalScope" target="_blank" rel="noopener">SharedWorkerGlobalScope</a> ）。</p><p>在 worker 线程中可以运行任意的代码，以下情况除外：不能直接在 worker 线程中操纵 DOM 元素, 或者使用某些 window 对象中默认的方法和属性。 但是 window 对象中很多的方法和属性是可以使用的，包括 WebSockets，以及诸如 IndexedDB 和 FireFox OS 中独有的 Data Store API 这一类数据存储机制。</p><p>主线程和 worker 线程之间通过这样的方式互相传输信息：两端都使用 postMessage() 方法来发送信息, 并且通过 onmessage 这个 event handler 来接收信息。 （传递的信息包含在 Message 这个事件的数据属性内) 。数据的交互是通过传递副本，而不是直接共享数据。</p><p>一个 worker 可以生成另外的新的 worker，这些 worker 的宿主和它们父页面的宿主相同。  此外，worker 可以通过 XMLHttpRequest 来访问网络，只是 XMLHttpRequest 的 responseXML 和 channel 这两个属性将总是 null 。</p><h2 id="Web-Workers-使用实例"><a href="#Web-Workers-使用实例" class="headerlink" title="Web Workers 使用实例"></a>Web Workers 使用实例</h2><p><strong>实现效果</strong></p><p>在输入框中输入一个数字 n，点击按钮，得到斐波那契数列中第 n 个数字的值。</p><p><strong>分析</strong></p><p>当数字 n 的值较大时，计算结果耗用时间比较长，如果计算的过程在主线程执行，则这段时间内页面将无法操作。</p><p>这种情况下，可以将计算的过程放在一个分线程中执行，主线程则可以继续执行其他代码，不会导致页面无法操作。当分线程得到结果之后，再将数据返回给主线程，主线程接收到数据，再进行处理。</p><p><strong>代码</strong></p><p>页面（主线程）代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;input type=&quot;text&quot; id=&quot;number&quot; value=&quot;30&quot;&gt;</span><br><span class="line">    &lt;button id=&quot;btn2&quot;&gt;分线程计算fibonacci值&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">        let number = document.getElementById(&apos;number&apos;);</span><br><span class="line">        let btn2 = document.getElementById(&apos;btn2&apos;);</span><br><span class="line"></span><br><span class="line">        btn2.onclick = ev =&gt; &#123;</span><br><span class="line">            let n = number.value * 1;</span><br><span class="line">            let worker = new Worker(&apos;worker.js&apos;);</span><br><span class="line">            console.log(&apos;主线程向子线程发送消息&apos;);</span><br><span class="line">            worker.postMessage(n);</span><br><span class="line">            worker.onmessage = event =&gt; &#123;</span><br><span class="line">                console.log(&apos;主线程接受到子线程发来的消息&apos;);</span><br><span class="line">                alert(event.data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>worker.js文件（分线程）代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fibonacci(n) &#123;</span><br><span class="line">    return n&lt;=2 ? 1 : fibonacci(n-1) + fibonacci(n-2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var onmessage = event =&gt; &#123;</span><br><span class="line">    let n = event.data;</span><br><span class="line">    console.log(&apos;子线程接收到主线程发送的消息&apos;);</span><br><span class="line">    let result = fibonacci(n);</span><br><span class="line">    postMessage(result);</span><br><span class="line">    console.log(&apos;子线程向主线程发送消息&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Web-Workers-不足"><a href="#Web-Workers-不足" class="headerlink" title="Web Workers 不足"></a>Web Workers 不足</h2><ul><li>worker 内代码不能操作 DOM (更新 UI)</li><li>不能跨域加载 JS</li><li>不是每个浏览器都支持这个新特性</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线程与进程&quot;&gt;&lt;a href=&quot;#线程与进程&quot; class=&quot;headerlink&quot; title=&quot;线程与进程&quot;&gt;&lt;/a&gt;线程与进程&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序的一次执行, 它占有一片独有的内存空间&lt;/li&gt;
&lt;li&gt;可以通过 windows 任务管理器查看进程
    
    </summary>
    
      <category term="浏览器" scheme="http://mengyujing.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="事件机制" scheme="http://mengyujing.com/tags/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    
      <category term="回调队列" scheme="http://mengyujing.com/tags/%E5%9B%9E%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
      <category term="Web Workers" scheme="http://mengyujing.com/tags/Web-Workers/"/>
    
  </entry>
  
  <entry>
    <title>npm命令</title>
    <link href="http://mengyujing.com/npm%E5%91%BD%E4%BB%A4/"/>
    <id>http://mengyujing.com/npm命令/</id>
    <published>2017-08-27T15:15:08.000Z</published>
    <updated>2019-10-24T11:41:37.167Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍一下包管理工具 npm 和 yarn 的一些命令。<br><a id="more"></a></p><h2 id="基于node工程"><a href="#基于node工程" class="headerlink" title="基于node工程"></a>基于node工程</h2><h3 id="包-项目，工程"><a href="#包-项目，工程" class="headerlink" title="包(项目，工程)"></a>包(项目，工程)</h3><ul><li><p>概念</p><p>  1、在Node.js语言中，包和模块并没有本质的不同，包是在模块的基础上更深一步的抽象。<br>  2、包将某个独立的功能封装起来，用于发布、更新、依赖管理和进行版本控制。<br>  3、Node.js根据 CommonJS 规范实现了包机制，开发了 npm 来解决包的发布和获取需求。</p></li><li><p>包的说明文件(package.json)</p><ul><li>使用package.json能干什么<br>  1、 相当于你本地项目的一个文档说明。<br>  2、允许你指定你项目中所使用的node包的版本。<br>  3、构建你的项目更加容易，便于给其他人共享。</li><li><p>package.json属性详解</p><ul><li><p>本质：json对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;npm_command&quot;, //包名</span><br><span class="line">    &quot;version&quot;: &quot;1.0.0&quot;, //版本</span><br><span class="line">    &quot;scripts&quot;: &#123; //配置npm运行命令</span><br><span class="line">    &quot;start&quot;: &quot;node bin/www&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;dependencies&quot;: &#123;//运行依赖的包</span><br><span class="line">    &quot;jquery&quot;: &quot;^3.2.1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;devDependencies&quot;: &#123;//开发依赖的包</span><br><span class="line">    &quot;babel&quot;: &quot;^6.23.0&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>扩展:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;jquery&quot;: &quot;^3.2.1&quot; -----向上的尖括号可以管理二级，三级版本</span><br><span class="line">&quot;jquery&quot;: &quot;~3.2.1&quot; -----波浪线可以管理三级版本。</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="npm-包管理工具"><a href="#npm-包管理工具" class="headerlink" title="npm(包管理工具)"></a>npm(包管理工具)</h3><p>1、Node 包管理器 (npm) 是一个由 Node.js 官方提供的第三方包管理工具,<br>2、npm 是一个完全由 JavaScript 实现的命令行工具，通过 Node.js 执行，因此严格来讲它不属于 Node.js 的一部分。<br>3、在最初的版本中，我们需要在安装完 Node.js 以后手动安装npm。<br>    但从Node.js 0.6开始，npm已包含在发行包中了，安装Node.js时会自动安装npm。<br>    现在的版本大都使用6.0以上。。。</p><h2 id="npm命令详解"><a href="#npm命令详解" class="headerlink" title="npm命令详解"></a>npm命令详解</h2><p>使用npm命令来下载依赖模块及对项目包(模块)进行管理<br>常用命令：</p><ul><li>npm init: 生成package.json</li><li>npm install:用来安装package.json里的相关依赖包</li><li>npm install packageName -g(全局安装)</li><li>npm install packageName –save 安装包(局部安装—运行依赖)</li><li>npm install packageName@version –save 安装指定版本的包(局部安装)</li><li>npm install packageName –save-dev(局部安装–开发依赖)</li><li>npm info packageName (显示包的信息)</li><li>npm rm packageName (移除包)</li><li>npm config get prefix (获取全局安装包的所在地址,并且可见对应的cmd命令)</li></ul><p>使用npm导致的问题(更多的是针对5.0以下版本)</p><ul><li>下载慢</li><li>甚至下载不了</li></ul><h2 id="cnpm-淘宝镜像"><a href="#cnpm-淘宝镜像" class="headerlink" title="cnpm(淘宝镜像)"></a>cnpm(淘宝镜像)</h2><ul><li>将npm上的包同步更新到淘宝镜像上，目前是每10分钟同步一次。</li><li>配置：npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>  常用命令：使用 cnpm 代替 npm 即可</li><li>使用 cnpm 的问题：<ul><li>会多下载一些文件/文件夹</li><li>严重者会导致 webstorm 瘫痪，就像帕金森综合征</li></ul></li><li>解决上述问题的办法<ul><li>修改 npm 的下载指向地址<br>  npm config set registry “<a href="https://registry.npm.taobao.org&quot;" target="_blank" rel="noopener">https://registry.npm.taobao.org&quot;</a></li></ul></li><li>修改仓库地址为npm地址：<br>  npm config set registry <a href="https://registry.npmjs.org/" target="_blank" rel="noopener">https://registry.npmjs.org/</a></li></ul><h2 id="yarn-Facebook开发的包管理工具"><a href="#yarn-Facebook开发的包管理工具" class="headerlink" title="yarn Facebook开发的包管理工具"></a>yarn Facebook开发的包管理工具</h2><h3 id="yarn-包管理工具"><a href="#yarn-包管理工具" class="headerlink" title="yarn(包管理工具)"></a>yarn(包管理工具)</h3><ul><li>yarn是Facebook开源的新的包管理器，可以用来代替npm</li><li>安装 npm install yarn -g</li><li>特点：有缓存，没有自己的仓库地址</li><li>常用命令<ul><li>yarn –version</li><li>yarn</li><li>yarn init  //生成package.json   ！！！注意生成的包名不能有中文，大写</li><li>yarn global package (全局安装)</li><li>yarn add package (局部安装)</li><li>yarn add package –dev</li><li>yarn remove package</li><li>yarn list //列出已经安装的包名</li><li>yarn info packageName</li><li>地址：<a href="https://yarnpkg.com/zh-Hans/" target="_blank" rel="noopener">https://yarnpkg.com/zh-Hans/</a></li></ul></li></ul><h3 id="cyarn"><a href="#cyarn" class="headerlink" title="cyarn"></a>cyarn</h3><ul><li>使用淘宝镜像，更快</li><li>配置：npm install cyarn -g –registry “<a href="https://registry.npm.taobao.org&quot;" target="_blank" rel="noopener">https://registry.npm.taobao.org&quot;</a></li><li>常用命令：将 yarn 使用cyarn代替即可</li></ul><h2 id="补充扩展："><a href="#补充扩展：" class="headerlink" title="补充扩展："></a>补充扩展：</h2><p>2017年5月30日发布node 8.0，其中自带的npm也由3.xxx版本升级到5.0</p><p>npm5变化：</p><ul><li>通过npm下载包的时候多了一个 package.lock.json</li><li>package.lock.json可以记录整个 node-modules 中文件夹的树状结构，再次下载的时候不用先去读取包与包之间相关依赖。（就是记录包与包之间的关联 – 依赖关系）</li><li>好处：再次 npm install 下载的时候不用去先读取依赖可以直接下载，速度较快。</li><li>可以利用离线缓存，合理的利用了缓存，提高了下载效率</li><li>在速度上还是和yarn有些差异。</li><li>–save 是一个默认属性，npm install 下载包的时候会在 package.json 里显示依赖</li><li>注意：npm3和npm5并没有完美对接<br>  如果之前的项目是用npm下载的包，当后期用npm下载其他包的时候之前的包的依赖是无法读取到package.lock.json里，导致之前的包无法使用，此时需要npm install重新下载。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍一下包管理工具 npm 和 yarn 的一些命令。&lt;br&gt;
    
    </summary>
    
      <category term="node" scheme="http://mengyujing.com/categories/node/"/>
    
    
      <category term="npm命令" scheme="http://mengyujing.com/tags/npm%E5%91%BD%E4%BB%A4/"/>
    
      <category term="yarn命令" scheme="http://mengyujing.com/tags/yarn%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的重绘与重排</title>
    <link href="http://mengyujing.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92/"/>
    <id>http://mengyujing.com/浏览器的重绘与重排/</id>
    <published>2017-08-27T07:02:24.000Z</published>
    <updated>2019-10-24T11:41:37.169Z</updated>
    
    <content type="html"><![CDATA[<p>　　浏览器从下载文件到显示页面是一个很复杂的过程。浏览器下载完页面中的所有组件 – HTML标记、JavaScript、CSS、图片 – 之后会解析并生成两个内部数据结构：</p><ul><li>DOM 树<br>  表示页面结构</li><li>渲染树<br>  表示 DOM 节点在页面中如何显示（宽高、位置等）</li></ul><a id="more"></a><p>　　DOM 树中的每一个需要显示的节点在渲染树中至少存在一个对应的节点（隐藏的 DOM 元素在渲染树中没有对应的节点）。渲染树中的节点被称为 “帧（frames）” 或 “盒（boxes）” ,符合 CSS 模型的定义，理解页面元素为一个具有内边距（padding）、外边距（margin）、边框（border）和位置（position）的盒子。一旦 DOM 树和渲染树构建完成，浏览器就开始显示（绘制“paint”）页面元素。</p><p>　　当 DOM 的变化影响了元素的几何属性（宽和高） – 比如改变边框宽度或给段落增加文字，导致行数增加 – 浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构建渲染树。这个过程称为 “重排（reflow）”。完成重排后，浏览器会重新绘制受影响的部分到屏幕中，该过程称为 “重绘（repaint）”。</p><p>　　并不是所有的 DOM 变化都会影响几何属性。例如，改变元素的背景色不会影响宽和高，这种情况下，只会发生一次重绘（不需要重排），因为元素的布局并没有改变。</p><blockquote><p>重排一定会引起浏览器的重绘，而重绘则不一定伴随重排。</p></blockquote><p>　　重绘和重排操作都是代价昂贵的操作，它会导致 WEB 应用程序的 UI 反应迟钝。所以，应当尽可能减少这类过程的发生。</p><h1 id="触发重排的情况"><a href="#触发重排的情况" class="headerlink" title="触发重排的情况"></a>触发重排的情况</h1><p>　　当页面布局的几何属性改变时就需要 “重排”。下述情况会导致重排：</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素位置改变</li><li>元素尺寸改变（包括：外边距、内边距、边框厚度、宽度、高度等属性改变）</li><li>内容改变。例如：文本改变或图片被另一个不同尺寸的图片代替</li><li>页面渲染器初始化</li><li>浏览器窗口尺寸改变</li><li>获取会导致渲染队列刷新的属性（详细介绍如下）</li></ul><p>根据改变的范围和程度，渲染树中相应部分也需要重新计算。  </p><blockquote><p>当滚动条出现时，会触发整个页面的重排。</p></blockquote><h2 id="渲染树变化的排队与刷新"><a href="#渲染树变化的排队与刷新" class="headerlink" title="渲染树变化的排队与刷新"></a>渲染树变化的排队与刷新</h2><p>　　由于每次重排都会产生计算消耗，大多数浏览器通过队列化修改并批量执行来优化重排过程。<br>　　然而，你可能会（经常不知不觉）强制刷新队列并要求计划任务立刻执行。获取布局信息的操作会导致队列刷新，比如使用以下属性：</p><ul><li>offsetTop , offsetLeft , offsetWidth , offsetHeight</li><li>scrollTop , scrollLeft , scrollWidth , scrollHeight</li><li>clientTop , clientLeft , clientWidth , clientHeight</li><li>getComputedStyle() ( currentStyle in IE )</li></ul><p>当获取以上的属性和方法时，浏览器为了获取最新的布局信息，不得不执行渲染队列中的 “待处理变化” ，并<strong>触发重排</strong>以返回正确的值。</p><h1 id="最小化重绘和重排"><a href="#最小化重绘和重排" class="headerlink" title="最小化重绘和重排"></a>最小化重绘和重排</h1><p>　　重绘和重排的代价非常昂贵，因此一个好的提高程序响应速度的策略就是减少此类操作的发生。</p><h2 id="合并多次对样式属性的操作"><a href="#合并多次对样式属性的操作" class="headerlink" title="合并多次对样式属性的操作"></a>合并多次对样式属性的操作</h2><p>　　为了减少重绘重排发生的次数，应该合并多次对 DOM 和样式的修改，然后一次处理掉。</p><p>考虑下面的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.style.borderLeft = &apos;1px&apos;;</span><br><span class="line">el.style.borderRight = &apos;2px&apos;;</span><br><span class="line">el.style.padding = &apos;5px&apos;;</span><br></pre></td></tr></table></figure></p><p>　　示例中有三个样式属性被改变，每一个都会影响元素的几何结构。最糟糕的情况下，会导致浏览器触发三次重排。大部分现代浏览器为此做了优化，只会触发一次重排，但是在旧的浏览器中或者有一个分离的异步处理过程时（比如使用计时器），仍然效率低下。如果在上面代码执行时，有其他代码请求布局信息，这会导致三次重排。而且，这段代码四次访问 DOM ，可以被优化。</p><p>　　上面的代码执行效率更高的方式是：将多次改变样式属性的操作合并为一次操作，这样只会修改 DOM 一次。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.style.cssText = &apos;border-left: 1px; border-right: 2px; padding: 5px;&apos;;</span><br></pre></td></tr></table></figure></p><p>　　另一个一次性修改样式的办法是修改 CSS 的 class 名称，而不是修改内联样式。这种方法适用于那些不依赖于运行逻辑和计算的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var el = document.getElementById(&apos;mydiv&apos;);</span><br><span class="line">el.className = &apos;active&apos;;</span><br></pre></td></tr></table></figure></p><h2 id="批量修改DOM"><a href="#批量修改DOM" class="headerlink" title="批量修改DOM"></a>批量修改DOM</h2><p>　　当需要对 DOM 元素进行一系列操作时，可以通过以下步骤来减少重绘和重排的次数：</p><ol><li>使元素脱离文档流</li><li>操作元素</li><li>操作完成后，将元素带回文档中</li></ol><p>这样，只有在第一步和第三步会触发两次重排。</p><p>有三种方式可以实现上面的步骤：</p><ul><li><p>隐藏元素（display: none;），操作元素，重新显示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var ul = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">ul.style.display = &apos;none&apos;;</span><br><span class="line">appendDataToElement(ul, data);</span><br><span class="line">ul.style.display = &apos;block&apos;;</span><br></pre></td></tr></table></figure></li><li><p>使用文档片段（document fragment）在当前 DOM 之外构建一个子树，再把它拷贝回文档</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var fragment = document.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line">document.getElementById(&apos;mylist&apos;).appendChild(fragment);</span><br></pre></td></tr></table></figure></li><li><p>将原始元素拷贝到一个脱离文档的节点中，修改副本，完成后再替换原始元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var old = document.getElementById(&apos;mylist&apos;);</span><br><span class="line">var clone = old.cloneNode(true);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>推荐尽可能的使用文档片段（第二个方案），因为它们所产生的 DOM 遍历和重排次数最少。唯一潜在的问题是文档片段未被充分利用，很多人可能并不熟悉这项技术。</p></blockquote><h2 id="缓存布局信息"><a href="#缓存布局信息" class="headerlink" title="缓存布局信息"></a>缓存布局信息</h2><p>　　浏览器获取元素的 offsetLeft 等属性值时，会导致重排。最好的做法是，将需要获取的布局信息的属性值，赋值给变量，然后再操作变量。</p><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><p>　　将需要多次重排的元素，position 属性设置为 absolute 或 fixed，这样元素就脱离了文档流，它的变化不会影响到其他元素。例如有动画效果的元素就最好设置为绝对定位。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《高性能JavaScript》 第三章–DOM编程</li><li><a href="http://kb.cnblogs.com/page/169820/" target="_blank" rel="noopener">浏览器的重绘与重排</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　浏览器从下载文件到显示页面是一个很复杂的过程。浏览器下载完页面中的所有组件 – HTML标记、JavaScript、CSS、图片 – 之后会解析并生成两个内部数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DOM 树&lt;br&gt;  表示页面结构&lt;/li&gt;
&lt;li&gt;渲染树&lt;br&gt;  表示 DOM 节点在页面中如何显示（宽高、位置等）&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://mengyujing.com/categories/Javascript/"/>
    
    
      <category term="DOM重绘重排" scheme="http://mengyujing.com/tags/DOM%E9%87%8D%E7%BB%98%E9%87%8D%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>自定义bind函数</title>
    <link href="http://mengyujing.com/%E8%87%AA%E5%AE%9A%E4%B9%89bind%E5%87%BD%E6%95%B0/"/>
    <id>http://mengyujing.com/自定义bind函数/</id>
    <published>2017-08-17T08:47:48.000Z</published>
    <updated>2019-10-24T11:41:37.170Z</updated>
    
    <content type="html"><![CDATA[<p>MDN 对 <code>Function.prototype.bind()</code> 函数的介绍：</p><p>　　bind() 方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。<br><a id="more"></a><br><strong>语法：</strong></p><pre><code>fun.bind(thisArg[, arg1[, arg2[, ...]]])</code></pre><p><strong>参数：</strong></p><ul><li>thisArg<br>当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用 new 操作符调用绑定函数时，该参数无效。</li><li>arg1, arg2, …<br>当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。</li></ul><p><strong>返回值：</strong><br>　　返回由指定的 this 值和初始化参数改造的原函数拷贝</p><hr><p>为了更好的理解 bind 函数，我定义了一个 mybind 函数，并通过 mybind 函数实现了 bind 函数的作用。<br>mybind 函数代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.mybind = function() &#123;</span><br><span class="line">    if (arguments.length &lt; 1) &#123;</span><br><span class="line">        throw &apos;Function mybind requires at least one parameter&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    var that = this;</span><br><span class="line">    var $this = arguments[0];</span><br><span class="line">    var args = [];</span><br><span class="line">    for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">        var arg = arguments[i];</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            args.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        var newArgs = [];</span><br><span class="line">        for (var i = 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            var arg = arguments[i];</span><br><span class="line">            newArgs.push(arg);</span><br><span class="line">        &#125;</span><br><span class="line">        that.apply($this, args.concat(newArgs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试 mybind 函数的作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    uname: &apos;测试&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function fun(a, b) &#123;</span><br><span class="line">    console.log(this.uname, a, b);</span><br><span class="line">&#125;</span><br><span class="line">var fun1 = fun.mybind(obj, 12);</span><br><span class="line">fun1(23);</span><br></pre></td></tr></table></figure></p><p>运行后得到： <code>测试 12 23</code> ， mybind 函数基本实现了 bind 函数的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;MDN 对 &lt;code&gt;Function.prototype.bind()&lt;/code&gt; 函数的介绍：&lt;/p&gt;
&lt;p&gt;　　bind() 方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://mengyujing.com/categories/Javascript/"/>
    
    
      <category term="自定义bind函数" scheme="http://mengyujing.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89bind%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LESS 介绍</title>
    <link href="http://mengyujing.com/LESS-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://mengyujing.com/LESS-介绍/</id>
    <published>2017-08-08T12:49:55.000Z</published>
    <updated>2019-10-24T11:41:37.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="less"><a href="#less" class="headerlink" title="less"></a>less</h1><p>　　less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。<br><a id="more"></a><br>　　LESS 做为 CSS 的一种形式的扩展，它并没有阉割 CSS 的功能，而是在现有的 CSS 语法上，添加了很多额外的功能。</p><p>　　less的中文官网：<a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a><br>　　bootstrap中关于less的介绍：<a href="http://www.bootcss.com/p/lesscss/#docs" target="_blank" rel="noopener">http://www.bootcss.com/p/lesscss/#docs</a></p><p><strong>Less编译工具</strong><br>　　koala 官网： <a href="http://www.koala-app.com" target="_blank" rel="noopener">www.koala-app.com</a> </p><h1 id="less中的注释"><a href="#less中的注释" class="headerlink" title="less中的注释"></a>less中的注释</h1><ul><li>以 // 开头的注释，不会被编译到css文件中</li><li>以 /**/ 包裹的注释，会被编译到css文件中  </li></ul><h1 id="less中的变量"><a href="#less中的变量" class="headerlink" title="less中的变量"></a>less中的变量</h1><p>使用 @ 来申明一个变量：<code>@变量名：变量值;</code></p><ol><li><p>作为普通属性值来使用：直接使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@pink: pink;</span><br><span class="line">.box&#123;</span><br><span class="line">    background: @pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为选择器和属性名：@{ 变量名 } 的形式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@wrap: #wrap;</span><br><span class="line">@w: width;</span><br><span class="line"></span><br><span class="line">@&#123;wrap&#125;&#123;</span><br><span class="line">    @&#123;w&#125;: 400px;</span><br><span class="line">    height: 300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>作为 URL：@{url}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@imgUrl: &quot;../img/zdy.jpg&quot;;</span><br><span class="line"></span><br><span class="line">@&#123;wrap&#125;&#123;</span><br><span class="line">    background: url(&quot;@&#123;imgUrl&#125;&quot;) no-repeat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>请注意 LESS 中的变量为完全的 ‘常量’ ，所以只能定义一次.</p></blockquote><h1 id="less中的嵌套规则"><a href="#less中的嵌套规则" class="headerlink" title="less中的嵌套规则"></a>less中的嵌套规则</h1><p>LESS 可以用嵌套的方式编写层叠样式.</p><h2 id="基本嵌套规则"><a href="#基本嵌套规则" class="headerlink" title="基本嵌套规则"></a>基本嵌套规则</h2><p>如下 CSS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list &#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#list span &#123;</span><br><span class="line">    float: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 LESS 可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list&#123;</span><br><span class="line">    width: 200px;</span><br><span class="line">    background: pink;</span><br><span class="line"></span><br><span class="line">    span&#123;</span><br><span class="line">        float: right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="amp-的使用"><a href="#amp-的使用" class="headerlink" title="&amp; 的使用"></a>&amp; 的使用</h2><p>如果你想写串联选择器，而不是写后代选择器，就可以用到 &amp; 了。这点对伪类尤其有用，如 :hover 和 :focus.</p><p>如下 CSS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#list a &#123;</span><br><span class="line">    float: left;</span><br><span class="line">&#125;</span><br><span class="line">#list a:hover &#123;</span><br><span class="line">    color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用 LESS 可以写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#list&#123;</span><br><span class="line">    a&#123;</span><br><span class="line">        float: left; </span><br><span class="line">        &amp;:hover&#123;</span><br><span class="line">            color: red;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="less中的混合"><a href="#less中的混合" class="headerlink" title="less中的混合"></a>less中的混合</h1><p>　　在 LESS 中我们可以定义一些通用的属性集为一个class，然后在另一个 class 中去调用这些属性。<br>　　混合就是将一系列属性从一个规则集引入到另一个规则集的方式。</p><blockquote><p>任何 CSS <em>class</em>, _id_ 或者 _元素_ 属性集都可以以同样的方式引入.</p></blockquote><h2 id="普通混合"><a href="#普通混合" class="headerlink" title="普通混合"></a>普通混合</h2><p>定义一个通用属性集，实现子元素垂直水平居中，在需要居中的子元素上调用该属性集：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.middle&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="不带输出的混合"><a href="#不带输出的混合" class="headerlink" title="不带输出的混合"></a>不带输出的混合</h2><p>使用普通混合方式，在 LESS 中定义的通用属性集会被编译到 CSS 文件中，如果想隐藏通用属性集，不让它暴露到 CSS 中，可以定义不带参数的属性集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.middle() &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带参数的混合"><a href="#带参数的混合" class="headerlink" title="带参数的混合"></a>带参数的混合</h2><p>在 LESS 中，还可以像函数一样定义一个带参数的属性集合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.border-radius (@radius) &#123;</span><br><span class="line">    border-radius: @radius;</span><br><span class="line">    -moz-border-radius: @radius;</span><br><span class="line">    -webkit-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line">#header &#123;</span><br><span class="line">    .border-radius(4px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带参数并且有默认值的混合"><a href="#带参数并且有默认值的混合" class="headerlink" title="带参数并且有默认值的混合"></a>带参数并且有默认值的混合</h2><p>参数可以设置默认值，调用时如果不传参数，则使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.border-radius (@radius: 5px) &#123;</span><br><span class="line">    border-radius: @radius;</span><br><span class="line">    -moz-border-radius: @radius;</span><br><span class="line">    -webkit-border-radius: @radius;</span><br><span class="line">&#125;</span><br><span class="line">#header &#123;</span><br><span class="line">    .border-radius;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="带多个参数的混合"><a href="#带多个参数的混合" class="headerlink" title="带多个参数的混合"></a>带多个参数的混合</h2><p>参数可以传多个，传入的实参与形参从左往右进行匹配。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.middle (@w:100px, @h:100px, @c:pink) &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: @w;</span><br><span class="line">    height:@h;</span><br><span class="line">    background: @c;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner1&#123;</span><br><span class="line">       .middle(50px, 50px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h2><p>在上面的示例代码中，传入的参数会从左往右与形参进行匹配，如果希望 @w 使用默认值，只传入 @h、@c，则实参与形参不能按照默认方式匹配，这时可以使用命名参数传参。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.middle ( @w: 100px, @h: 100px, @c: pink) &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: @w;</span><br><span class="line">    height:@h;</span><br><span class="line">    background: @c;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    #inner2&#123;</span><br><span class="line">        .middle( @h: 200px; @c: deeppink);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h2><p>混合的参数不一定是变量，也可以是固定值。</p><p>变量可以匹配任意的传入值，而固定值就仅仅匹配与其相等的传入值。</p><p>只有被匹配的混合才会被使用。</p><p>如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.triangle( @_, @w:10px)&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(top, @w:10px)&#123;</span><br><span class="line">    border-width: @w;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.triangle(bottom, @w:10px)&#123;</span><br><span class="line">    border-width: @w;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果这样运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#box1&#123;</span><br><span class="line">    .triangle(top);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>则会得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#box1 &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    border-width: 10px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体实现如下：</p><ol><li>第一个混合定义被成功匹配，因为它接受任意值</li><li>第二个混合定义被成功匹配，因为它只接受 top 作为首参</li><li>第三个混合定义未被匹配，因为它只接受 bottom 作为首参</li></ol><p><strong>我们也可以匹配多个参数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.mixin (@a) &#123;</span><br><span class="line">&#125;</span><br><span class="line">.mixin (@a, @b) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当调用 .mixin 时，如果只传入一个参数，则会匹配到第一个 .mixin 混合，如果传入两个参数，则匹配第二个。</p><h2 id="arguments变量"><a href="#arguments变量" class="headerlink" title="@arguments变量"></a>@arguments变量</h2><p>@arguments包含了所有传递进来的参数。如果你不想单独处理每一个参数的话就可以像这样写:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.border(@w:20px, @c:black, @style:solid)&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    border: @arguments;</span><br><span class="line">&#125;</span><br><span class="line">#wrap&#123;</span><br><span class="line">    .border(10px, deeppink, solid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: pink;</span><br><span class="line">    border: 10px #ff1493 solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="less运算"><a href="#less运算" class="headerlink" title="less运算"></a>less运算</h1><p>在 less 中可以进行加减乘除的运算。<br>任何 _数字_、_颜色_ 或者 _变量_ 都可以参与运算。</p><p>如下 LESS 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@base: 5%;</span><br><span class="line">@filler: @base * 2;</span><br><span class="line">@other: @base + @filler;</span><br><span class="line">.box&#123;</span><br><span class="line">    color: #888 / 4;</span><br><span class="line">    background-color: @base - @other + #111;</span><br><span class="line">    height: 100% / 2 + @filler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行后得到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    color: #222222;</span><br><span class="line">    background-color: #070707;</span><br><span class="line">    height: 60%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LESS 的运算已经超出了我们的期望，它能够分辨出颜色和单位。如果像下面这样单位运算的话:  </p><pre><code>@var: 1px + 5;</code></pre><p>LESS 会输出 <code>6px</code>.</p><p>括号也同样允许使用:  </p><pre><code>@width: (@var + 5) * 2;</code></pre><p>可以在复合属性中进行运算:  </p><pre><code>border: (@width * 2) solid black;</code></pre><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>　　LESS 中的作用域跟其他编程语言非常类似，首先会从本地查找变量或者混合模块，如果没找到的话会去父级作用域中查找，直到找到为止。<br>　　内层声明块作用域中的变量，在父级作用域中无法获取。</p><h2 id="变量延迟加载"><a href="#变量延迟加载" class="headerlink" title="变量延迟加载"></a>变量延迟加载</h2><p>　　同一个作用域中，变量的使用会在变量被全部赋值后执行。<br>　　如下代码中，.inner 内定义了两次 @test 变量，less 编译时，会在 .inner 作用域中先将变量定义的代码全部执行，然后才使用该变量，所以在 .inner 使用 @test 变量，得到的结果为 3。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.wrap&#123;</span><br><span class="line">    @test: 1;</span><br><span class="line">    .inner&#123;</span><br><span class="line">        @test: 2;</span><br><span class="line">        width: @test; // 3</span><br><span class="line">        @test: 3;</span><br><span class="line">    &#125;</span><br><span class="line">    width: @test; // 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>有时候，为了更好组织 CSS 或者单纯是为了更好的封装，将一些变量或者混合模块打包起来, 可以像下面这样在 #bundle 中定义一些属性集之后可以重复使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#bundle &#123;</span><br><span class="line">    .button() &#123;</span><br><span class="line">        display: block;</span><br><span class="line">        border: 1px solid black;</span><br><span class="line">        background-color: grey;</span><br><span class="line">        &amp;:hover &#123; background-color: white;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .tab &#123; ... &#125;</span><br><span class="line">    .citation &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只需要这样调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#header a &#123;</span><br><span class="line">    color: orange;</span><br><span class="line">    #bundle &gt; .button;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Importing"><a href="#Importing" class="headerlink" title="Importing"></a>Importing</h1><p>可以在main文件中通过下面的形式引入 .less 文件, .less 后缀可带可不带:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.less&quot;;</span><br><span class="line">@import &quot;lib&quot;;</span><br></pre></td></tr></table></figure></p><p>如果想导入一个CSS文件而且不想LESS对它进行处理，只需要使用.css后缀就可以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &quot;lib.css&quot;;</span><br></pre></td></tr></table></figure></p><p>这样LESS就会跳过它不去处理它.</p><h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><p>变量可以嵌入到字符串中。<br>上面介绍过的变量作为 URL 使用的方式，就是将变量插入到字符串中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@base-url: &quot;http://assets.fnord.com&quot;;</span><br><span class="line">background-image: url(&quot;@&#123;base-url&#125;/images/bg.png&quot;);</span><br></pre></td></tr></table></figure></p><h1 id="避免编译"><a href="#避免编译" class="headerlink" title="避免编译"></a>避免编译</h1><p>有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。<br>要输出这样的值我们可以将避免编译的值用 <code>&quot;&quot;</code> 包含起来，并在字符串前加上一个 <code>~</code>, 例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">    filter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class &#123;</span><br><span class="line">    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;less&quot;&gt;&lt;a href=&quot;#less&quot; class=&quot;headerlink&quot; title=&quot;less&quot;&gt;&lt;/a&gt;less&lt;/h1&gt;&lt;p&gt;　　less是一种动态样式语言，属于css预处理器的范畴，它扩展了 CSS 语言，增加了变量、Mixin、函数等特性，使 CSS 更易维护和扩展。&lt;br&gt;
    
    </summary>
    
      <category term="CSS预处理器" scheme="http://mengyujing.com/categories/CSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    
    
      <category term="LESS" scheme="http://mengyujing.com/tags/LESS/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://mengyujing.com/flex%E5%B8%83%E5%B1%80/"/>
    <id>http://mengyujing.com/flex布局/</id>
    <published>2017-08-06T15:03:40.000Z</published>
    <updated>2019-10-24T11:41:37.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h1><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br><a id="more"></a></p><p>CSS3 弹性盒子（Flexible Box 或 Flexbox），是一种用于在页面上布置元素的布局模式，使得当页面布局必须适应不同的屏幕尺寸和不同的显示设备时，元素可预测的运行行/列。<br>对于许多应用程序，弹性盒子模型提供了对块模型的改进，因为它不使用浮动，flex容器的边缘也不会与其内容的边缘折叠。</p><p>弹性盒模型，分老版与新版</p><ul><li>老版本的通常称之为 box</li><li>新版本的通常称之为 flex</li></ul><p>任何一个容器都可以指定为 Flex 布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>行内元素也可以使用 Flex 布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box&#123;</span><br><span class="line">  display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，设为 Flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。</p></blockquote><h2 id="flex-布局基本概念"><a href="#flex-布局基本概念" class="headerlink" title="flex 布局基本概念"></a>flex 布局基本概念</h2><p>flex 布局重要的两组概念</p><h3 id="容器与项目"><a href="#容器与项目" class="headerlink" title="容器与项目"></a>容器与项目</h3><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><h3 id="主轴与侧轴"><a href="#主轴与侧轴" class="headerlink" title="主轴与侧轴"></a>主轴与侧轴</h3><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。<br>主轴的开始位置（与边框的交叉点）叫做 main start，结束位置叫做 main end；交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。</p><p>主轴由容器的布局方向决定<br>    新版：flex-direction<br>    老版：-webkit-box-orient</p><h1 id="老版"><a href="#老版" class="headerlink" title="老版"></a>老版</h1><p>容器设置为<br>display: webkit-box</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="容器的布局方向"><a href="#容器的布局方向" class="headerlink" title="容器的布局方向"></a>容器的布局方向</h3><p>-webkit-box-orient</p><ul><li>horizontal ：主轴为 X 轴</li><li>vertical ：主轴为 Y 轴</li></ul><h3 id="容器的排列方向"><a href="#容器的排列方向" class="headerlink" title="容器的排列方向"></a>容器的排列方向</h3><p>-webkit-box-direction</p><ul><li>normal ：项目正序排列</li><li>reverse ：项目倒序排列</li></ul><h3 id="富裕空间的管理"><a href="#富裕空间的管理" class="headerlink" title="富裕空间的管理"></a>富裕空间的管理</h3><p>不会给项目区分配空间，只是确定富裕空间的位置。<br>理解：确定容器的布局方向和排列方向后，项目布局的起点。如主轴为 X 轴，排列方向为 normal，主轴富裕空间为 start，则项目在左侧，富裕空间在右侧；主轴富裕空间为 center，则项目在中间，富裕空间在两侧。</p><p><strong>主轴富裕空间</strong></p><p>-webkit-box-pack</p><ul><li>start</li><li>end</li><li>center</li><li>justify</li></ul><p><strong>侧轴富裕空间</strong></p><p>-webkit-box-align</p><ul><li>start</li><li>end</li><li>center</li></ul><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="弹性空间的管理"><a href="#弹性空间的管理" class="headerlink" title="弹性空间的管理"></a>弹性空间的管理</h3><p>将富裕空间按比例分配到各个项目上</p><p>-webkit-box-flex: 1;</p><h1 id="新版"><a href="#新版" class="headerlink" title="新版"></a>新版</h1><p>容器设置为<br>display: flex;</p><h2 id="容器-1"><a href="#容器-1" class="headerlink" title="容器"></a>容器</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>新版中，容器的布局方向和排列方向使用同一个属性。</p><p>flex-direction</p><ul><li>row：主轴为水平方向，起点在左端。</li><li>column：主轴为水平方向，起点在右端。</li><li>row-reverse：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p>定义了项目在主轴上的对齐方式。<br>可以看做主轴上富裕空间的管理。</p><ul><li>flex-start：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，项目之间的间隔都相等。</li><li>space-around(box 没有的)：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3><p>定义项目在交叉轴（侧轴）上如何对齐。</p><ul><li>flex-start：交叉轴的起点对齐。</li><li>flex-end：交叉轴的终点对齐。</li><li>center：交叉轴的中点对齐。</li><li>baseline(box 没有的)：项目的第一行文字的基线对齐。</li><li>stretch(默认值)：等高布局，如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul><h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。</p><p>控制容器为单行/列还是多行/列。并且定义了侧轴的方向，新行/列将沿侧轴方向堆砌。</p><p>继承性：不可继承</p><ul><li>nowrap：默认值，不换行</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方。</li></ul><h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>“flex-direction”和“flex-wrap”的简写，控制主轴和侧轴的位置以及方向</p><p>继承性：不可继承</p><p>默认值：row nowrap</p><h3 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h3><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><ul><li>flex-start：与交叉轴的起点对齐。<br>  所有行/列从侧轴起点开始填充。第一行/列的侧轴起点边和容器的侧轴起点边对齐。接下来的每一行/列紧跟前一行/列。</li><li>flex-end：与交叉轴的终点对齐。<br>  所有弹性元素从侧轴末尾开始填充。最后一个弹性元素的侧轴终点和容器的侧轴终点对齐。同时所有后续元素与前一个对齐。</li><li>center：与交叉轴的中点对齐。<br>  所有行/列朝向容器的中心填充。每行/列互相紧挨，相对于容器居中对齐。容器的侧轴起点边和第一行/列的距离相等于容器的侧轴终点边和最后一行/列的距离。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>  所有行/列在容器中平均分布。相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的边对齐。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>  所有行/列在容器中平均分布，相邻两行/列间距相等。容器的侧轴起点边和终点边分别与第一行/列和最后一行/列的距离是相邻两行/列间距的一半。</li><li>stretch（默认值）：轴线占满整个交叉轴。<br>  拉伸所有行/列来填满剩余空间。剩余空间平均的分配给每一行/列。</li></ul><h2 id="项目-1"><a href="#项目-1" class="headerlink" title="项目"></a>项目</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><p><code>order: &lt;integer&gt;;</code></p><h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。</p><p><code>flex-grow: &lt;number&gt;; /* default 0 */</code></p><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p><code>flex-shrink: &lt;number&gt;; /* default 1 */</code></p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><p>定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小（width的值）。</p><p><code>flex-basis: &lt;length&gt; | auto; /* default auto */</code></p><p>可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex-grow, flex-shrink 和 flex-basis的简写，默认值为 0 1 auto。后两个属性可选。</p><p><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><p>align-self属性允许单个项目侧轴有与其他项目不一样的对齐方式，可覆盖align-items属性。<br>默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><ul><li>auto<br>  设置为父元素的 align-items 值，如果该元素没有父元素的话，就设置为 stretch。</li><li>flex-start<br>  flex 元素会对齐到 cross-axis 的首端。</li><li>flex-end<br>  flex 元素会对齐到 cross-axis 的尾端。</li><li>center<br>  flex 元素会对齐到 cross-axis 的中间，如果该元素的 cross-size 的尺寸大于 flex 容器，将在两个方向均等溢出。</li><li>baseline<br>  所有的 flex 元素会沿着基线对齐。</li><li>stretch<br>  flex 元素将会基于容器的宽和高，按照自身 margin box 的 cross-size 拉伸。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" target="_blank" rel="noopener">阮一峰 flex 布局教程：语法篇</a><br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">阮一峰 flex 布局教程：实例篇</a><br><a href="http://flexboxfroggy.com/" target="_blank" rel="noopener">青蛙游戏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;flex-布局&quot;&gt;&lt;a href=&quot;#flex-布局&quot; class=&quot;headerlink&quot; title=&quot;flex 布局&quot;&gt;&lt;/a&gt;flex 布局&lt;/h1&gt;&lt;p&gt;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。&lt;br&gt;
    
    </summary>
    
      <category term="CSS3" scheme="http://mengyujing.com/categories/CSS3/"/>
    
    
      <category term="flex" scheme="http://mengyujing.com/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>块级元素水平垂直居中</title>
    <link href="http://mengyujing.com/%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    <id>http://mengyujing.com/块级元素水平垂直居中/</id>
    <published>2017-08-04T12:37:26.000Z</published>
    <updated>2019-10-24T11:41:37.169Z</updated>
    
    <content type="html"><![CDATA[<p>将一个块级元素水平垂直居中的方法<br><a id="more"></a><br>元素 HTML 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;wrap&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>要实现的效果：</p><style>#wrap {    position: relative;    width: 120px;    height: 120px;    background: lightblue;}#inner {    position: absolute;    left: 50%;    top: 50%;    margin-left: -25px;    margin-top: -25px;    width: 50px;    height: 50px;    background: yellow;}</style><div id="wrap"><br>    <div id="inner"></div><br></div><h3 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin-left: -50px;</span><br><span class="line">    margin-top: -50px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h3><p>子元素的 width + padding + margin + left + right = 包含块宽度。<br>当子元素的 width 确定，padding、left、right 都为 0 ，margin 为 auto 时，包含块的宽度 - width 剩余的值，则为 margin 的值，margin-left 和 margin-right 平分这个值的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    right: 0;</span><br><span class="line">    bottom: 0;</span><br><span class="line">    margin: auto;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h3><p>使用第一种方式，必须知道元素的宽高，当元素宽高不确定时，可以使用平移的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#wrap &#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    width: 300px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    margin: 100px auto;</span><br><span class="line">    background: lightblue;</span><br><span class="line">&#125;</span><br><span class="line">#inner &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%, -50%);</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;将一个块级元素水平垂直居中的方法&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://mengyujing.com/categories/CSS/"/>
    
    
      <category term="水平垂直居中" scheme="http://mengyujing.com/tags/%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
</feed>
